
// Generated from Hplsql.g4 by ANTLR 4.9.2

#include <strings.h>
#include "HplsqlListener.h"
#include "HplsqlVisitor.h"

#include "HplsqlParser.h"


using namespace antlrcpp;
using namespace antlr4;

HplsqlParser::HplsqlParser(TokenStream *input) : Parser(input) {
  _interpreter = new atn::ParserATNSimulator(this, _atn, _decisionToDFA, _sharedContextCache);
}

HplsqlParser::~HplsqlParser() {
  delete _interpreter;
}

std::string HplsqlParser::getGrammarFileName() const {
  return "Hplsql.g4";
}

const std::vector<std::string>& HplsqlParser::getRuleNames() const {
  return _ruleNames;
}

dfa::Vocabulary& HplsqlParser::getVocabulary() const {
  return _vocabulary;
}


//----------------- ProgramContext ------------------------------------------------------------------

HplsqlParser::ProgramContext::ProgramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::BlockContext* HplsqlParser::ProgramContext::block() {
  return getRuleContext<HplsqlParser::BlockContext>(0);
}


size_t HplsqlParser::ProgramContext::getRuleIndex() const {
  return HplsqlParser::RuleProgram;
}

void HplsqlParser::ProgramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProgram(this);
}

void HplsqlParser::ProgramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProgram(this);
}


antlrcpp::Any HplsqlParser::ProgramContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitProgram(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::ProgramContext* HplsqlParser::program() {
  ProgramContext *_localctx = _tracker.createInstance<ProgramContext>(_ctx, getState());
  enterRule(_localctx, 0, HplsqlParser::RuleProgram);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(450);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockContext ------------------------------------------------------------------

HplsqlParser::BlockContext::BlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HplsqlParser::Begin_end_blockContext *> HplsqlParser::BlockContext::begin_end_block() {
  return getRuleContexts<HplsqlParser::Begin_end_blockContext>();
}

HplsqlParser::Begin_end_blockContext* HplsqlParser::BlockContext::begin_end_block(size_t i) {
  return getRuleContext<HplsqlParser::Begin_end_blockContext>(i);
}

std::vector<HplsqlParser::StmtContext *> HplsqlParser::BlockContext::stmt() {
  return getRuleContexts<HplsqlParser::StmtContext>();
}

HplsqlParser::StmtContext* HplsqlParser::BlockContext::stmt(size_t i) {
  return getRuleContext<HplsqlParser::StmtContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::BlockContext::T_GO() {
  return getTokens(HplsqlParser::T_GO);
}

tree::TerminalNode* HplsqlParser::BlockContext::T_GO(size_t i) {
  return getToken(HplsqlParser::T_GO, i);
}


size_t HplsqlParser::BlockContext::getRuleIndex() const {
  return HplsqlParser::RuleBlock;
}

void HplsqlParser::BlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlock(this);
}

void HplsqlParser::BlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlock(this);
}


antlrcpp::Any HplsqlParser::BlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitBlock(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::BlockContext* HplsqlParser::block() {
  BlockContext *_localctx = _tracker.createInstance<BlockContext>(_ctx, getState());
  enterRule(_localctx, 2, HplsqlParser::RuleBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(459); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(454);
              _errHandler->sync(this);
              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx)) {
              case 1: {
                setState(452);
                begin_end_block();
                break;
              }

              case 2: {
                setState(453);
                stmt();
                break;
              }

              default:
                break;
              }
              setState(457);
              _errHandler->sync(this);

              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx)) {
              case 1: {
                setState(456);
                match(HplsqlParser::T_GO);
                break;
              }

              default:
                break;
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(461); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Begin_end_blockContext ------------------------------------------------------------------

HplsqlParser::Begin_end_blockContext::Begin_end_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Begin_end_blockContext::T_BEGIN() {
  return getToken(HplsqlParser::T_BEGIN, 0);
}

HplsqlParser::BlockContext* HplsqlParser::Begin_end_blockContext::block() {
  return getRuleContext<HplsqlParser::BlockContext>(0);
}

HplsqlParser::Block_endContext* HplsqlParser::Begin_end_blockContext::block_end() {
  return getRuleContext<HplsqlParser::Block_endContext>(0);
}

HplsqlParser::Declare_blockContext* HplsqlParser::Begin_end_blockContext::declare_block() {
  return getRuleContext<HplsqlParser::Declare_blockContext>(0);
}

HplsqlParser::Exception_blockContext* HplsqlParser::Begin_end_blockContext::exception_block() {
  return getRuleContext<HplsqlParser::Exception_blockContext>(0);
}


size_t HplsqlParser::Begin_end_blockContext::getRuleIndex() const {
  return HplsqlParser::RuleBegin_end_block;
}

void HplsqlParser::Begin_end_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBegin_end_block(this);
}

void HplsqlParser::Begin_end_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBegin_end_block(this);
}


antlrcpp::Any HplsqlParser::Begin_end_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitBegin_end_block(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Begin_end_blockContext* HplsqlParser::begin_end_block() {
  Begin_end_blockContext *_localctx = _tracker.createInstance<Begin_end_blockContext>(_ctx, getState());
  enterRule(_localctx, 4, HplsqlParser::RuleBegin_end_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(464);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_DECLARE) {
      setState(463);
      declare_block();
    }
    setState(466);
    match(HplsqlParser::T_BEGIN);
    setState(467);
    block();
    setState(469);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx)) {
    case 1: {
      setState(468);
      exception_block();
      break;
    }

    default:
      break;
    }
    setState(471);
    block_end();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Single_block_stmtContext ------------------------------------------------------------------

HplsqlParser::Single_block_stmtContext::Single_block_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Single_block_stmtContext::T_BEGIN() {
  return getToken(HplsqlParser::T_BEGIN, 0);
}

HplsqlParser::BlockContext* HplsqlParser::Single_block_stmtContext::block() {
  return getRuleContext<HplsqlParser::BlockContext>(0);
}

HplsqlParser::Block_endContext* HplsqlParser::Single_block_stmtContext::block_end() {
  return getRuleContext<HplsqlParser::Block_endContext>(0);
}

HplsqlParser::Exception_blockContext* HplsqlParser::Single_block_stmtContext::exception_block() {
  return getRuleContext<HplsqlParser::Exception_blockContext>(0);
}

HplsqlParser::StmtContext* HplsqlParser::Single_block_stmtContext::stmt() {
  return getRuleContext<HplsqlParser::StmtContext>(0);
}

tree::TerminalNode* HplsqlParser::Single_block_stmtContext::T_SEMICOLON() {
  return getToken(HplsqlParser::T_SEMICOLON, 0);
}


size_t HplsqlParser::Single_block_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleSingle_block_stmt;
}

void HplsqlParser::Single_block_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingle_block_stmt(this);
}

void HplsqlParser::Single_block_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingle_block_stmt(this);
}


antlrcpp::Any HplsqlParser::Single_block_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitSingle_block_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Single_block_stmtContext* HplsqlParser::single_block_stmt() {
  Single_block_stmtContext *_localctx = _tracker.createInstance<Single_block_stmtContext>(_ctx, getState());
  enterRule(_localctx, 6, HplsqlParser::RuleSingle_block_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(484);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(473);
      match(HplsqlParser::T_BEGIN);
      setState(474);
      block();
      setState(476);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx)) {
      case 1: {
        setState(475);
        exception_block();
        break;
      }

      default:
        break;
      }
      setState(478);
      block_end();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(480);
      stmt();
      setState(482);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx)) {
      case 1: {
        setState(481);
        match(HplsqlParser::T_SEMICOLON);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_endContext ------------------------------------------------------------------

HplsqlParser::Block_endContext::Block_endContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Block_endContext::T_END() {
  return getToken(HplsqlParser::T_END, 0);
}


size_t HplsqlParser::Block_endContext::getRuleIndex() const {
  return HplsqlParser::RuleBlock_end;
}

void HplsqlParser::Block_endContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlock_end(this);
}

void HplsqlParser::Block_endContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlock_end(this);
}


antlrcpp::Any HplsqlParser::Block_endContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitBlock_end(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Block_endContext* HplsqlParser::block_end() {
  Block_endContext *_localctx = _tracker.createInstance<Block_endContext>(_ctx, getState());
  enterRule(_localctx, 8, HplsqlParser::RuleBlock_end);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(486);

    if (!(strcasecmp(_input->LT(2)->getText().data(), "TRANSACTION"))) throw FailedPredicateException(this, "strcasecmp(_input->LT(2)->getText().data(), \"TRANSACTION\")");
    setState(487);
    match(HplsqlParser::T_END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Proc_blockContext ------------------------------------------------------------------

HplsqlParser::Proc_blockContext::Proc_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Begin_end_blockContext* HplsqlParser::Proc_blockContext::begin_end_block() {
  return getRuleContext<HplsqlParser::Begin_end_blockContext>(0);
}

std::vector<HplsqlParser::StmtContext *> HplsqlParser::Proc_blockContext::stmt() {
  return getRuleContexts<HplsqlParser::StmtContext>();
}

HplsqlParser::StmtContext* HplsqlParser::Proc_blockContext::stmt(size_t i) {
  return getRuleContext<HplsqlParser::StmtContext>(i);
}

tree::TerminalNode* HplsqlParser::Proc_blockContext::T_GO() {
  return getToken(HplsqlParser::T_GO, 0);
}


size_t HplsqlParser::Proc_blockContext::getRuleIndex() const {
  return HplsqlParser::RuleProc_block;
}

void HplsqlParser::Proc_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProc_block(this);
}

void HplsqlParser::Proc_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProc_block(this);
}


antlrcpp::Any HplsqlParser::Proc_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitProc_block(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Proc_blockContext* HplsqlParser::proc_block() {
  Proc_blockContext *_localctx = _tracker.createInstance<Proc_blockContext>(_ctx, getState());
  enterRule(_localctx, 10, HplsqlParser::RuleProc_block);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(498);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(489);
      begin_end_block();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(491); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(490);
                stmt();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(493); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(496);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
      case 1: {
        setState(495);
        match(HplsqlParser::T_GO);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StmtContext ------------------------------------------------------------------

HplsqlParser::StmtContext::StmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Assignment_stmtContext* HplsqlParser::StmtContext::assignment_stmt() {
  return getRuleContext<HplsqlParser::Assignment_stmtContext>(0);
}

HplsqlParser::Allocate_cursor_stmtContext* HplsqlParser::StmtContext::allocate_cursor_stmt() {
  return getRuleContext<HplsqlParser::Allocate_cursor_stmtContext>(0);
}

HplsqlParser::Alter_table_stmtContext* HplsqlParser::StmtContext::alter_table_stmt() {
  return getRuleContext<HplsqlParser::Alter_table_stmtContext>(0);
}

HplsqlParser::Associate_locator_stmtContext* HplsqlParser::StmtContext::associate_locator_stmt() {
  return getRuleContext<HplsqlParser::Associate_locator_stmtContext>(0);
}

HplsqlParser::Begin_transaction_stmtContext* HplsqlParser::StmtContext::begin_transaction_stmt() {
  return getRuleContext<HplsqlParser::Begin_transaction_stmtContext>(0);
}

HplsqlParser::Break_stmtContext* HplsqlParser::StmtContext::break_stmt() {
  return getRuleContext<HplsqlParser::Break_stmtContext>(0);
}

HplsqlParser::Call_stmtContext* HplsqlParser::StmtContext::call_stmt() {
  return getRuleContext<HplsqlParser::Call_stmtContext>(0);
}

HplsqlParser::Collect_stats_stmtContext* HplsqlParser::StmtContext::collect_stats_stmt() {
  return getRuleContext<HplsqlParser::Collect_stats_stmtContext>(0);
}

HplsqlParser::Close_stmtContext* HplsqlParser::StmtContext::close_stmt() {
  return getRuleContext<HplsqlParser::Close_stmtContext>(0);
}

HplsqlParser::Cmp_stmtContext* HplsqlParser::StmtContext::cmp_stmt() {
  return getRuleContext<HplsqlParser::Cmp_stmtContext>(0);
}

HplsqlParser::Copy_from_local_stmtContext* HplsqlParser::StmtContext::copy_from_local_stmt() {
  return getRuleContext<HplsqlParser::Copy_from_local_stmtContext>(0);
}

HplsqlParser::Copy_stmtContext* HplsqlParser::StmtContext::copy_stmt() {
  return getRuleContext<HplsqlParser::Copy_stmtContext>(0);
}

HplsqlParser::Commit_stmtContext* HplsqlParser::StmtContext::commit_stmt() {
  return getRuleContext<HplsqlParser::Commit_stmtContext>(0);
}

HplsqlParser::Create_database_stmtContext* HplsqlParser::StmtContext::create_database_stmt() {
  return getRuleContext<HplsqlParser::Create_database_stmtContext>(0);
}

HplsqlParser::Create_function_stmtContext* HplsqlParser::StmtContext::create_function_stmt() {
  return getRuleContext<HplsqlParser::Create_function_stmtContext>(0);
}

HplsqlParser::Create_index_stmtContext* HplsqlParser::StmtContext::create_index_stmt() {
  return getRuleContext<HplsqlParser::Create_index_stmtContext>(0);
}

HplsqlParser::Create_local_temp_table_stmtContext* HplsqlParser::StmtContext::create_local_temp_table_stmt() {
  return getRuleContext<HplsqlParser::Create_local_temp_table_stmtContext>(0);
}

HplsqlParser::Create_package_stmtContext* HplsqlParser::StmtContext::create_package_stmt() {
  return getRuleContext<HplsqlParser::Create_package_stmtContext>(0);
}

HplsqlParser::Create_package_body_stmtContext* HplsqlParser::StmtContext::create_package_body_stmt() {
  return getRuleContext<HplsqlParser::Create_package_body_stmtContext>(0);
}

HplsqlParser::Create_procedure_stmtContext* HplsqlParser::StmtContext::create_procedure_stmt() {
  return getRuleContext<HplsqlParser::Create_procedure_stmtContext>(0);
}

HplsqlParser::Create_table_stmtContext* HplsqlParser::StmtContext::create_table_stmt() {
  return getRuleContext<HplsqlParser::Create_table_stmtContext>(0);
}

HplsqlParser::Declare_stmtContext* HplsqlParser::StmtContext::declare_stmt() {
  return getRuleContext<HplsqlParser::Declare_stmtContext>(0);
}

HplsqlParser::Delete_stmtContext* HplsqlParser::StmtContext::delete_stmt() {
  return getRuleContext<HplsqlParser::Delete_stmtContext>(0);
}

HplsqlParser::Describe_stmtContext* HplsqlParser::StmtContext::describe_stmt() {
  return getRuleContext<HplsqlParser::Describe_stmtContext>(0);
}

HplsqlParser::Drop_stmtContext* HplsqlParser::StmtContext::drop_stmt() {
  return getRuleContext<HplsqlParser::Drop_stmtContext>(0);
}

HplsqlParser::End_transaction_stmtContext* HplsqlParser::StmtContext::end_transaction_stmt() {
  return getRuleContext<HplsqlParser::End_transaction_stmtContext>(0);
}

HplsqlParser::Exec_stmtContext* HplsqlParser::StmtContext::exec_stmt() {
  return getRuleContext<HplsqlParser::Exec_stmtContext>(0);
}

HplsqlParser::Exit_stmtContext* HplsqlParser::StmtContext::exit_stmt() {
  return getRuleContext<HplsqlParser::Exit_stmtContext>(0);
}

HplsqlParser::Fetch_stmtContext* HplsqlParser::StmtContext::fetch_stmt() {
  return getRuleContext<HplsqlParser::Fetch_stmtContext>(0);
}

HplsqlParser::For_cursor_stmtContext* HplsqlParser::StmtContext::for_cursor_stmt() {
  return getRuleContext<HplsqlParser::For_cursor_stmtContext>(0);
}

HplsqlParser::For_range_stmtContext* HplsqlParser::StmtContext::for_range_stmt() {
  return getRuleContext<HplsqlParser::For_range_stmtContext>(0);
}

HplsqlParser::If_stmtContext* HplsqlParser::StmtContext::if_stmt() {
  return getRuleContext<HplsqlParser::If_stmtContext>(0);
}

HplsqlParser::Include_stmtContext* HplsqlParser::StmtContext::include_stmt() {
  return getRuleContext<HplsqlParser::Include_stmtContext>(0);
}

HplsqlParser::Insert_stmtContext* HplsqlParser::StmtContext::insert_stmt() {
  return getRuleContext<HplsqlParser::Insert_stmtContext>(0);
}

HplsqlParser::Insert_directory_stmtContext* HplsqlParser::StmtContext::insert_directory_stmt() {
  return getRuleContext<HplsqlParser::Insert_directory_stmtContext>(0);
}

HplsqlParser::Get_diag_stmtContext* HplsqlParser::StmtContext::get_diag_stmt() {
  return getRuleContext<HplsqlParser::Get_diag_stmtContext>(0);
}

HplsqlParser::Grant_stmtContext* HplsqlParser::StmtContext::grant_stmt() {
  return getRuleContext<HplsqlParser::Grant_stmtContext>(0);
}

HplsqlParser::Leave_stmtContext* HplsqlParser::StmtContext::leave_stmt() {
  return getRuleContext<HplsqlParser::Leave_stmtContext>(0);
}

HplsqlParser::Map_object_stmtContext* HplsqlParser::StmtContext::map_object_stmt() {
  return getRuleContext<HplsqlParser::Map_object_stmtContext>(0);
}

HplsqlParser::Merge_stmtContext* HplsqlParser::StmtContext::merge_stmt() {
  return getRuleContext<HplsqlParser::Merge_stmtContext>(0);
}

HplsqlParser::Open_stmtContext* HplsqlParser::StmtContext::open_stmt() {
  return getRuleContext<HplsqlParser::Open_stmtContext>(0);
}

HplsqlParser::Print_stmtContext* HplsqlParser::StmtContext::print_stmt() {
  return getRuleContext<HplsqlParser::Print_stmtContext>(0);
}

HplsqlParser::Quit_stmtContext* HplsqlParser::StmtContext::quit_stmt() {
  return getRuleContext<HplsqlParser::Quit_stmtContext>(0);
}

HplsqlParser::Raise_stmtContext* HplsqlParser::StmtContext::raise_stmt() {
  return getRuleContext<HplsqlParser::Raise_stmtContext>(0);
}

HplsqlParser::Resignal_stmtContext* HplsqlParser::StmtContext::resignal_stmt() {
  return getRuleContext<HplsqlParser::Resignal_stmtContext>(0);
}

HplsqlParser::Return_stmtContext* HplsqlParser::StmtContext::return_stmt() {
  return getRuleContext<HplsqlParser::Return_stmtContext>(0);
}

HplsqlParser::Rollback_stmtContext* HplsqlParser::StmtContext::rollback_stmt() {
  return getRuleContext<HplsqlParser::Rollback_stmtContext>(0);
}

HplsqlParser::Select_stmtContext* HplsqlParser::StmtContext::select_stmt() {
  return getRuleContext<HplsqlParser::Select_stmtContext>(0);
}

HplsqlParser::Signal_stmtContext* HplsqlParser::StmtContext::signal_stmt() {
  return getRuleContext<HplsqlParser::Signal_stmtContext>(0);
}

HplsqlParser::Update_stmtContext* HplsqlParser::StmtContext::update_stmt() {
  return getRuleContext<HplsqlParser::Update_stmtContext>(0);
}

HplsqlParser::Use_stmtContext* HplsqlParser::StmtContext::use_stmt() {
  return getRuleContext<HplsqlParser::Use_stmtContext>(0);
}

HplsqlParser::Truncate_stmtContext* HplsqlParser::StmtContext::truncate_stmt() {
  return getRuleContext<HplsqlParser::Truncate_stmtContext>(0);
}

HplsqlParser::Values_into_stmtContext* HplsqlParser::StmtContext::values_into_stmt() {
  return getRuleContext<HplsqlParser::Values_into_stmtContext>(0);
}

HplsqlParser::While_stmtContext* HplsqlParser::StmtContext::while_stmt() {
  return getRuleContext<HplsqlParser::While_stmtContext>(0);
}

HplsqlParser::LabelContext* HplsqlParser::StmtContext::label() {
  return getRuleContext<HplsqlParser::LabelContext>(0);
}

HplsqlParser::HiveContext* HplsqlParser::StmtContext::hive() {
  return getRuleContext<HplsqlParser::HiveContext>(0);
}

HplsqlParser::HostContext* HplsqlParser::StmtContext::host() {
  return getRuleContext<HplsqlParser::HostContext>(0);
}

HplsqlParser::Null_stmtContext* HplsqlParser::StmtContext::null_stmt() {
  return getRuleContext<HplsqlParser::Null_stmtContext>(0);
}

HplsqlParser::Expr_stmtContext* HplsqlParser::StmtContext::expr_stmt() {
  return getRuleContext<HplsqlParser::Expr_stmtContext>(0);
}

HplsqlParser::Semicolon_stmtContext* HplsqlParser::StmtContext::semicolon_stmt() {
  return getRuleContext<HplsqlParser::Semicolon_stmtContext>(0);
}


size_t HplsqlParser::StmtContext::getRuleIndex() const {
  return HplsqlParser::RuleStmt;
}

void HplsqlParser::StmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStmt(this);
}

void HplsqlParser::StmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStmt(this);
}


antlrcpp::Any HplsqlParser::StmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitStmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::StmtContext* HplsqlParser::stmt() {
  StmtContext *_localctx = _tracker.createInstance<StmtContext>(_ctx, getState());
  enterRule(_localctx, 12, HplsqlParser::RuleStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(560);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(500);
      assignment_stmt();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(501);
      allocate_cursor_stmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(502);
      alter_table_stmt();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(503);
      associate_locator_stmt();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(504);
      begin_transaction_stmt();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(505);
      break_stmt();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(506);
      call_stmt();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(507);
      collect_stats_stmt();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(508);
      close_stmt();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(509);
      cmp_stmt();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(510);
      copy_from_local_stmt();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(511);
      copy_stmt();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(512);
      commit_stmt();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(513);
      create_database_stmt();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(514);
      create_function_stmt();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(515);
      create_index_stmt();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(516);
      create_local_temp_table_stmt();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(517);
      create_package_stmt();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(518);
      create_package_body_stmt();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(519);
      create_procedure_stmt();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(520);
      create_table_stmt();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(521);
      declare_stmt();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(522);
      delete_stmt();
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(523);
      describe_stmt();
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(524);
      drop_stmt();
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(525);
      end_transaction_stmt();
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(526);
      exec_stmt();
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(527);
      exit_stmt();
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(528);
      fetch_stmt();
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(529);
      for_cursor_stmt();
      break;
    }

    case 31: {
      enterOuterAlt(_localctx, 31);
      setState(530);
      for_range_stmt();
      break;
    }

    case 32: {
      enterOuterAlt(_localctx, 32);
      setState(531);
      if_stmt();
      break;
    }

    case 33: {
      enterOuterAlt(_localctx, 33);
      setState(532);
      include_stmt();
      break;
    }

    case 34: {
      enterOuterAlt(_localctx, 34);
      setState(533);
      insert_stmt();
      break;
    }

    case 35: {
      enterOuterAlt(_localctx, 35);
      setState(534);
      insert_directory_stmt();
      break;
    }

    case 36: {
      enterOuterAlt(_localctx, 36);
      setState(535);
      get_diag_stmt();
      break;
    }

    case 37: {
      enterOuterAlt(_localctx, 37);
      setState(536);
      grant_stmt();
      break;
    }

    case 38: {
      enterOuterAlt(_localctx, 38);
      setState(537);
      leave_stmt();
      break;
    }

    case 39: {
      enterOuterAlt(_localctx, 39);
      setState(538);
      map_object_stmt();
      break;
    }

    case 40: {
      enterOuterAlt(_localctx, 40);
      setState(539);
      merge_stmt();
      break;
    }

    case 41: {
      enterOuterAlt(_localctx, 41);
      setState(540);
      open_stmt();
      break;
    }

    case 42: {
      enterOuterAlt(_localctx, 42);
      setState(541);
      print_stmt();
      break;
    }

    case 43: {
      enterOuterAlt(_localctx, 43);
      setState(542);
      quit_stmt();
      break;
    }

    case 44: {
      enterOuterAlt(_localctx, 44);
      setState(543);
      raise_stmt();
      break;
    }

    case 45: {
      enterOuterAlt(_localctx, 45);
      setState(544);
      resignal_stmt();
      break;
    }

    case 46: {
      enterOuterAlt(_localctx, 46);
      setState(545);
      return_stmt();
      break;
    }

    case 47: {
      enterOuterAlt(_localctx, 47);
      setState(546);
      rollback_stmt();
      break;
    }

    case 48: {
      enterOuterAlt(_localctx, 48);
      setState(547);
      select_stmt();
      break;
    }

    case 49: {
      enterOuterAlt(_localctx, 49);
      setState(548);
      signal_stmt();
      break;
    }

    case 50: {
      enterOuterAlt(_localctx, 50);
      setState(549);
      update_stmt();
      break;
    }

    case 51: {
      enterOuterAlt(_localctx, 51);
      setState(550);
      use_stmt();
      break;
    }

    case 52: {
      enterOuterAlt(_localctx, 52);
      setState(551);
      truncate_stmt();
      break;
    }

    case 53: {
      enterOuterAlt(_localctx, 53);
      setState(552);
      values_into_stmt();
      break;
    }

    case 54: {
      enterOuterAlt(_localctx, 54);
      setState(553);
      while_stmt();
      break;
    }

    case 55: {
      enterOuterAlt(_localctx, 55);
      setState(554);
      label();
      break;
    }

    case 56: {
      enterOuterAlt(_localctx, 56);
      setState(555);
      hive();
      break;
    }

    case 57: {
      enterOuterAlt(_localctx, 57);
      setState(556);
      host();
      break;
    }

    case 58: {
      enterOuterAlt(_localctx, 58);
      setState(557);
      null_stmt();
      break;
    }

    case 59: {
      enterOuterAlt(_localctx, 59);
      setState(558);
      expr_stmt();
      break;
    }

    case 60: {
      enterOuterAlt(_localctx, 60);
      setState(559);
      semicolon_stmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Semicolon_stmtContext ------------------------------------------------------------------

HplsqlParser::Semicolon_stmtContext::Semicolon_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Semicolon_stmtContext::T_SEMICOLON() {
  return getToken(HplsqlParser::T_SEMICOLON, 0);
}

tree::TerminalNode* HplsqlParser::Semicolon_stmtContext::T_DIV() {
  return getToken(HplsqlParser::T_DIV, 0);
}


size_t HplsqlParser::Semicolon_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleSemicolon_stmt;
}

void HplsqlParser::Semicolon_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSemicolon_stmt(this);
}

void HplsqlParser::Semicolon_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSemicolon_stmt(this);
}


antlrcpp::Any HplsqlParser::Semicolon_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitSemicolon_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Semicolon_stmtContext* HplsqlParser::semicolon_stmt() {
  Semicolon_stmtContext *_localctx = _tracker.createInstance<Semicolon_stmtContext>(_ctx, getState());
  enterRule(_localctx, 14, HplsqlParser::RuleSemicolon_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(562);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T__0

    || _la == HplsqlParser::T__1 || _la == HplsqlParser::T_DIV

    || _la == HplsqlParser::T_SEMICOLON)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Exception_blockContext ------------------------------------------------------------------

HplsqlParser::Exception_blockContext::Exception_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Exception_blockContext::T_EXCEPTION() {
  return getToken(HplsqlParser::T_EXCEPTION, 0);
}

std::vector<HplsqlParser::Exception_block_itemContext *> HplsqlParser::Exception_blockContext::exception_block_item() {
  return getRuleContexts<HplsqlParser::Exception_block_itemContext>();
}

HplsqlParser::Exception_block_itemContext* HplsqlParser::Exception_blockContext::exception_block_item(size_t i) {
  return getRuleContext<HplsqlParser::Exception_block_itemContext>(i);
}


size_t HplsqlParser::Exception_blockContext::getRuleIndex() const {
  return HplsqlParser::RuleException_block;
}

void HplsqlParser::Exception_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterException_block(this);
}

void HplsqlParser::Exception_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitException_block(this);
}


antlrcpp::Any HplsqlParser::Exception_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitException_block(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Exception_blockContext* HplsqlParser::exception_block() {
  Exception_blockContext *_localctx = _tracker.createInstance<Exception_blockContext>(_ctx, getState());
  enterRule(_localctx, 16, HplsqlParser::RuleException_block);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(564);
    match(HplsqlParser::T_EXCEPTION);
    setState(566); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(565);
              exception_block_item();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(568); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Exception_block_itemContext ------------------------------------------------------------------

HplsqlParser::Exception_block_itemContext::Exception_block_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> HplsqlParser::Exception_block_itemContext::T_WHEN() {
  return getTokens(HplsqlParser::T_WHEN);
}

tree::TerminalNode* HplsqlParser::Exception_block_itemContext::T_WHEN(size_t i) {
  return getToken(HplsqlParser::T_WHEN, i);
}

tree::TerminalNode* HplsqlParser::Exception_block_itemContext::L_ID() {
  return getToken(HplsqlParser::L_ID, 0);
}

tree::TerminalNode* HplsqlParser::Exception_block_itemContext::T_THEN() {
  return getToken(HplsqlParser::T_THEN, 0);
}

HplsqlParser::BlockContext* HplsqlParser::Exception_block_itemContext::block() {
  return getRuleContext<HplsqlParser::BlockContext>(0);
}

tree::TerminalNode* HplsqlParser::Exception_block_itemContext::T_END() {
  return getToken(HplsqlParser::T_END, 0);
}


size_t HplsqlParser::Exception_block_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleException_block_item;
}

void HplsqlParser::Exception_block_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterException_block_item(this);
}

void HplsqlParser::Exception_block_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitException_block_item(this);
}


antlrcpp::Any HplsqlParser::Exception_block_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitException_block_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Exception_block_itemContext* HplsqlParser::exception_block_item() {
  Exception_block_itemContext *_localctx = _tracker.createInstance<Exception_block_itemContext>(_ctx, getState());
  enterRule(_localctx, 18, HplsqlParser::RuleException_block_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(570);
    match(HplsqlParser::T_WHEN);
    setState(571);
    match(HplsqlParser::L_ID);
    setState(572);
    match(HplsqlParser::T_THEN);
    setState(573);
    block();
    setState(574);
    _la = _input->LA(1);
    if (_la == 0 || _la == Token::EOF || (_la == HplsqlParser::T_END || _la == HplsqlParser::T_WHEN)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Null_stmtContext ------------------------------------------------------------------

HplsqlParser::Null_stmtContext::Null_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Null_stmtContext::T_NULL() {
  return getToken(HplsqlParser::T_NULL, 0);
}


size_t HplsqlParser::Null_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleNull_stmt;
}

void HplsqlParser::Null_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNull_stmt(this);
}

void HplsqlParser::Null_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNull_stmt(this);
}


antlrcpp::Any HplsqlParser::Null_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitNull_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Null_stmtContext* HplsqlParser::null_stmt() {
  Null_stmtContext *_localctx = _tracker.createInstance<Null_stmtContext>(_ctx, getState());
  enterRule(_localctx, 20, HplsqlParser::RuleNull_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(576);
    match(HplsqlParser::T_NULL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_stmtContext ------------------------------------------------------------------

HplsqlParser::Expr_stmtContext::Expr_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::ExprContext* HplsqlParser::Expr_stmtContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}


size_t HplsqlParser::Expr_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleExpr_stmt;
}

void HplsqlParser::Expr_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_stmt(this);
}

void HplsqlParser::Expr_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_stmt(this);
}


antlrcpp::Any HplsqlParser::Expr_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitExpr_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Expr_stmtContext* HplsqlParser::expr_stmt() {
  Expr_stmtContext *_localctx = _tracker.createInstance<Expr_stmtContext>(_ctx, getState());
  enterRule(_localctx, 22, HplsqlParser::RuleExpr_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(578);

    if (!(strcasecmp(_input->LT(1)->getText().data(), "GO"))) throw FailedPredicateException(this, "strcasecmp(_input->LT(1)->getText().data(), \"GO\")");
    setState(579);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assignment_stmtContext ------------------------------------------------------------------

HplsqlParser::Assignment_stmtContext::Assignment_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Assignment_stmtContext::T_SET() {
  return getToken(HplsqlParser::T_SET, 0);
}

HplsqlParser::Set_session_optionContext* HplsqlParser::Assignment_stmtContext::set_session_option() {
  return getRuleContext<HplsqlParser::Set_session_optionContext>(0);
}

std::vector<HplsqlParser::Assignment_stmt_itemContext *> HplsqlParser::Assignment_stmtContext::assignment_stmt_item() {
  return getRuleContexts<HplsqlParser::Assignment_stmt_itemContext>();
}

HplsqlParser::Assignment_stmt_itemContext* HplsqlParser::Assignment_stmtContext::assignment_stmt_item(size_t i) {
  return getRuleContext<HplsqlParser::Assignment_stmt_itemContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Assignment_stmtContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Assignment_stmtContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Assignment_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleAssignment_stmt;
}

void HplsqlParser::Assignment_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment_stmt(this);
}

void HplsqlParser::Assignment_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment_stmt(this);
}


antlrcpp::Any HplsqlParser::Assignment_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitAssignment_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Assignment_stmtContext* HplsqlParser::assignment_stmt() {
  Assignment_stmtContext *_localctx = _tracker.createInstance<Assignment_stmtContext>(_ctx, getState());
  enterRule(_localctx, 24, HplsqlParser::RuleAssignment_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(594);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(581);
      match(HplsqlParser::T_SET);
      setState(582);
      set_session_option();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(584);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx)) {
      case 1: {
        setState(583);
        match(HplsqlParser::T_SET);
        break;
      }

      default:
        break;
      }
      setState(586);
      assignment_stmt_item();
      setState(591);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(587);
          match(HplsqlParser::T_COMMA);
          setState(588);
          assignment_stmt_item(); 
        }
        setState(593);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assignment_stmt_itemContext ------------------------------------------------------------------

HplsqlParser::Assignment_stmt_itemContext::Assignment_stmt_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Assignment_stmt_single_itemContext* HplsqlParser::Assignment_stmt_itemContext::assignment_stmt_single_item() {
  return getRuleContext<HplsqlParser::Assignment_stmt_single_itemContext>(0);
}

HplsqlParser::Assignment_stmt_multiple_itemContext* HplsqlParser::Assignment_stmt_itemContext::assignment_stmt_multiple_item() {
  return getRuleContext<HplsqlParser::Assignment_stmt_multiple_itemContext>(0);
}

HplsqlParser::Assignment_stmt_select_itemContext* HplsqlParser::Assignment_stmt_itemContext::assignment_stmt_select_item() {
  return getRuleContext<HplsqlParser::Assignment_stmt_select_itemContext>(0);
}


size_t HplsqlParser::Assignment_stmt_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleAssignment_stmt_item;
}

void HplsqlParser::Assignment_stmt_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment_stmt_item(this);
}

void HplsqlParser::Assignment_stmt_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment_stmt_item(this);
}


antlrcpp::Any HplsqlParser::Assignment_stmt_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitAssignment_stmt_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Assignment_stmt_itemContext* HplsqlParser::assignment_stmt_item() {
  Assignment_stmt_itemContext *_localctx = _tracker.createInstance<Assignment_stmt_itemContext>(_ctx, getState());
  enterRule(_localctx, 26, HplsqlParser::RuleAssignment_stmt_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(599);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(596);
      assignment_stmt_single_item();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(597);
      assignment_stmt_multiple_item();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(598);
      assignment_stmt_select_item();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assignment_stmt_single_itemContext ------------------------------------------------------------------

HplsqlParser::Assignment_stmt_single_itemContext::Assignment_stmt_single_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::IdentContext* HplsqlParser::Assignment_stmt_single_itemContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

tree::TerminalNode* HplsqlParser::Assignment_stmt_single_itemContext::T_EQUAL() {
  return getToken(HplsqlParser::T_EQUAL, 0);
}

HplsqlParser::ExprContext* HplsqlParser::Assignment_stmt_single_itemContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}

tree::TerminalNode* HplsqlParser::Assignment_stmt_single_itemContext::T_COLON() {
  return getToken(HplsqlParser::T_COLON, 0);
}

tree::TerminalNode* HplsqlParser::Assignment_stmt_single_itemContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

tree::TerminalNode* HplsqlParser::Assignment_stmt_single_itemContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}


size_t HplsqlParser::Assignment_stmt_single_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleAssignment_stmt_single_item;
}

void HplsqlParser::Assignment_stmt_single_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment_stmt_single_item(this);
}

void HplsqlParser::Assignment_stmt_single_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment_stmt_single_item(this);
}


antlrcpp::Any HplsqlParser::Assignment_stmt_single_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitAssignment_stmt_single_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Assignment_stmt_single_itemContext* HplsqlParser::assignment_stmt_single_item() {
  Assignment_stmt_single_itemContext *_localctx = _tracker.createInstance<Assignment_stmt_single_itemContext>(_ctx, getState());
  enterRule(_localctx, 28, HplsqlParser::RuleAssignment_stmt_single_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(617);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_ACTION:
      case HplsqlParser::T_ADD2:
      case HplsqlParser::T_ALL:
      case HplsqlParser::T_ALLOCATE:
      case HplsqlParser::T_ALTER:
      case HplsqlParser::T_AND:
      case HplsqlParser::T_ANSI_NULLS:
      case HplsqlParser::T_ANSI_PADDING:
      case HplsqlParser::T_AS:
      case HplsqlParser::T_ASC:
      case HplsqlParser::T_ASSOCIATE:
      case HplsqlParser::T_AT:
      case HplsqlParser::T_AUTO_INCREMENT:
      case HplsqlParser::T_AVG:
      case HplsqlParser::T_BATCHSIZE:
      case HplsqlParser::T_BEGIN:
      case HplsqlParser::T_BETWEEN:
      case HplsqlParser::T_BIGINT:
      case HplsqlParser::T_BINARY_DOUBLE:
      case HplsqlParser::T_BINARY_FLOAT:
      case HplsqlParser::T_BIT:
      case HplsqlParser::T_BODY:
      case HplsqlParser::T_BREAK:
      case HplsqlParser::T_BY:
      case HplsqlParser::T_BYTE:
      case HplsqlParser::T_CALL:
      case HplsqlParser::T_CALLER:
      case HplsqlParser::T_CASCADE:
      case HplsqlParser::T_CASE:
      case HplsqlParser::T_CASESPECIFIC:
      case HplsqlParser::T_CAST:
      case HplsqlParser::T_CHAR:
      case HplsqlParser::T_CHARACTER:
      case HplsqlParser::T_CHARSET:
      case HplsqlParser::T_CLIENT:
      case HplsqlParser::T_CLOSE:
      case HplsqlParser::T_CLUSTERED:
      case HplsqlParser::T_CMP:
      case HplsqlParser::T_COLLECT:
      case HplsqlParser::T_COLLECTION:
      case HplsqlParser::T_COLUMN:
      case HplsqlParser::T_COMMENT:
      case HplsqlParser::T_CONSTANT:
      case HplsqlParser::T_COMMIT:
      case HplsqlParser::T_COMPRESS:
      case HplsqlParser::T_CONCAT:
      case HplsqlParser::T_CONDITION:
      case HplsqlParser::T_CONSTRAINT:
      case HplsqlParser::T_CONTINUE:
      case HplsqlParser::T_COPY:
      case HplsqlParser::T_COUNT:
      case HplsqlParser::T_COUNT_BIG:
      case HplsqlParser::T_CREATE:
      case HplsqlParser::T_CREATION:
      case HplsqlParser::T_CREATOR:
      case HplsqlParser::T_CS:
      case HplsqlParser::T_CURRENT:
      case HplsqlParser::T_CURRENT_SCHEMA:
      case HplsqlParser::T_CURSOR:
      case HplsqlParser::T_DATABASE:
      case HplsqlParser::T_DATA:
      case HplsqlParser::T_DATE:
      case HplsqlParser::T_DATETIME:
      case HplsqlParser::T_DAY:
      case HplsqlParser::T_DAYS:
      case HplsqlParser::T_DEC:
      case HplsqlParser::T_DECIMAL:
      case HplsqlParser::T_DECLARE:
      case HplsqlParser::T_DEFAULT:
      case HplsqlParser::T_DEFERRED:
      case HplsqlParser::T_DEFINED:
      case HplsqlParser::T_DEFINER:
      case HplsqlParser::T_DEFINITION:
      case HplsqlParser::T_DELETE:
      case HplsqlParser::T_DELIMITED:
      case HplsqlParser::T_DELIMITER:
      case HplsqlParser::T_DESC:
      case HplsqlParser::T_DESCRIBE:
      case HplsqlParser::T_DIAGNOSTICS:
      case HplsqlParser::T_DIR:
      case HplsqlParser::T_DIRECTORY:
      case HplsqlParser::T_DISTINCT:
      case HplsqlParser::T_DISTRIBUTE:
      case HplsqlParser::T_DO:
      case HplsqlParser::T_DOUBLE:
      case HplsqlParser::T_DROP:
      case HplsqlParser::T_DYNAMIC:
      case HplsqlParser::T_ENABLE:
      case HplsqlParser::T_ENGINE:
      case HplsqlParser::T_ESCAPED:
      case HplsqlParser::T_EXCEPT:
      case HplsqlParser::T_EXEC:
      case HplsqlParser::T_EXECUTE:
      case HplsqlParser::T_EXCEPTION:
      case HplsqlParser::T_EXCLUSIVE:
      case HplsqlParser::T_EXISTS:
      case HplsqlParser::T_EXIT:
      case HplsqlParser::T_FALLBACK:
      case HplsqlParser::T_FALSE:
      case HplsqlParser::T_FETCH:
      case HplsqlParser::T_FIELDS:
      case HplsqlParser::T_FILE:
      case HplsqlParser::T_FILES:
      case HplsqlParser::T_FLOAT:
      case HplsqlParser::T_FOR:
      case HplsqlParser::T_FOREIGN:
      case HplsqlParser::T_FORMAT:
      case HplsqlParser::T_FOUND:
      case HplsqlParser::T_FROM:
      case HplsqlParser::T_FULL:
      case HplsqlParser::T_FUNCTION:
      case HplsqlParser::T_GET:
      case HplsqlParser::T_GLOBAL:
      case HplsqlParser::T_GO:
      case HplsqlParser::T_GRANT:
      case HplsqlParser::T_GROUP:
      case HplsqlParser::T_HANDLER:
      case HplsqlParser::T_HASH:
      case HplsqlParser::T_HAVING:
      case HplsqlParser::T_HDFS:
      case HplsqlParser::T_HIVE:
      case HplsqlParser::T_HOST:
      case HplsqlParser::T_IDENTITY:
      case HplsqlParser::T_IF:
      case HplsqlParser::T_IGNORE:
      case HplsqlParser::T_IMMEDIATE:
      case HplsqlParser::T_IN:
      case HplsqlParser::T_INCLUDE:
      case HplsqlParser::T_INDEX:
      case HplsqlParser::T_INITRANS:
      case HplsqlParser::T_INNER:
      case HplsqlParser::T_INOUT:
      case HplsqlParser::T_INSERT:
      case HplsqlParser::T_INT:
      case HplsqlParser::T_INT2:
      case HplsqlParser::T_INT4:
      case HplsqlParser::T_INT8:
      case HplsqlParser::T_INTEGER:
      case HplsqlParser::T_INTERSECT:
      case HplsqlParser::T_INTERVAL:
      case HplsqlParser::T_INTO:
      case HplsqlParser::T_INVOKER:
      case HplsqlParser::T_IS:
      case HplsqlParser::T_ISOPEN:
      case HplsqlParser::T_ITEMS:
      case HplsqlParser::T_JOIN:
      case HplsqlParser::T_KEEP:
      case HplsqlParser::T_KEY:
      case HplsqlParser::T_KEYS:
      case HplsqlParser::T_LANGUAGE:
      case HplsqlParser::T_LEAVE:
      case HplsqlParser::T_LEFT:
      case HplsqlParser::T_LIKE:
      case HplsqlParser::T_LIMIT:
      case HplsqlParser::T_LINES:
      case HplsqlParser::T_LOCAL:
      case HplsqlParser::T_LOCATION:
      case HplsqlParser::T_LOCATOR:
      case HplsqlParser::T_LOCATORS:
      case HplsqlParser::T_LOCKS:
      case HplsqlParser::T_LOG:
      case HplsqlParser::T_LOGGED:
      case HplsqlParser::T_LOGGING:
      case HplsqlParser::T_LOOP:
      case HplsqlParser::T_MAP:
      case HplsqlParser::T_MATCHED:
      case HplsqlParser::T_MAX:
      case HplsqlParser::T_MAXTRANS:
      case HplsqlParser::T_MERGE:
      case HplsqlParser::T_MESSAGE_TEXT:
      case HplsqlParser::T_MICROSECOND:
      case HplsqlParser::T_MICROSECONDS:
      case HplsqlParser::T_MIN:
      case HplsqlParser::T_MULTISET:
      case HplsqlParser::T_NCHAR:
      case HplsqlParser::T_NEW:
      case HplsqlParser::T_NVARCHAR:
      case HplsqlParser::T_NO:
      case HplsqlParser::T_NOCOUNT:
      case HplsqlParser::T_NOCOMPRESS:
      case HplsqlParser::T_NOLOGGING:
      case HplsqlParser::T_NONE:
      case HplsqlParser::T_NOT:
      case HplsqlParser::T_NOTFOUND:
      case HplsqlParser::T_NUMERIC:
      case HplsqlParser::T_NUMBER:
      case HplsqlParser::T_OBJECT:
      case HplsqlParser::T_OFF:
      case HplsqlParser::T_ON:
      case HplsqlParser::T_ONLY:
      case HplsqlParser::T_OPEN:
      case HplsqlParser::T_OR:
      case HplsqlParser::T_ORDER:
      case HplsqlParser::T_OUT:
      case HplsqlParser::T_OUTER:
      case HplsqlParser::T_OVER:
      case HplsqlParser::T_OVERWRITE:
      case HplsqlParser::T_OWNER:
      case HplsqlParser::T_PACKAGE:
      case HplsqlParser::T_PARTITION:
      case HplsqlParser::T_PCTFREE:
      case HplsqlParser::T_PCTUSED:
      case HplsqlParser::T_PRECISION:
      case HplsqlParser::T_PRESERVE:
      case HplsqlParser::T_PRIMARY:
      case HplsqlParser::T_PRINT:
      case HplsqlParser::T_PROC:
      case HplsqlParser::T_PROCEDURE:
      case HplsqlParser::T_QUALIFY:
      case HplsqlParser::T_QUERY_BAND:
      case HplsqlParser::T_QUIT:
      case HplsqlParser::T_QUOTED_IDENTIFIER:
      case HplsqlParser::T_RAISE:
      case HplsqlParser::T_REAL:
      case HplsqlParser::T_REFERENCES:
      case HplsqlParser::T_REGEXP:
      case HplsqlParser::T_REPLACE:
      case HplsqlParser::T_RESIGNAL:
      case HplsqlParser::T_RESTRICT:
      case HplsqlParser::T_RESULT:
      case HplsqlParser::T_RESULT_SET_LOCATOR:
      case HplsqlParser::T_RETURN:
      case HplsqlParser::T_RETURNS:
      case HplsqlParser::T_REVERSE:
      case HplsqlParser::T_RIGHT:
      case HplsqlParser::T_RLIKE:
      case HplsqlParser::T_ROLE:
      case HplsqlParser::T_ROLLBACK:
      case HplsqlParser::T_ROW:
      case HplsqlParser::T_ROWS:
      case HplsqlParser::T_ROW_COUNT:
      case HplsqlParser::T_RR:
      case HplsqlParser::T_RS:
      case HplsqlParser::T_PWD:
      case HplsqlParser::T_TRIM:
      case HplsqlParser::T_SCHEMA:
      case HplsqlParser::T_SECOND:
      case HplsqlParser::T_SECONDS:
      case HplsqlParser::T_SECURITY:
      case HplsqlParser::T_SEGMENT:
      case HplsqlParser::T_SEL:
      case HplsqlParser::T_SELECT:
      case HplsqlParser::T_SET:
      case HplsqlParser::T_SESSION:
      case HplsqlParser::T_SESSIONS:
      case HplsqlParser::T_SETS:
      case HplsqlParser::T_SHARE:
      case HplsqlParser::T_SIGNAL:
      case HplsqlParser::T_SIMPLE_DOUBLE:
      case HplsqlParser::T_SIMPLE_FLOAT:
      case HplsqlParser::T_SMALLDATETIME:
      case HplsqlParser::T_SMALLINT:
      case HplsqlParser::T_SQL:
      case HplsqlParser::T_SQLEXCEPTION:
      case HplsqlParser::T_SQLINSERT:
      case HplsqlParser::T_SQLSTATE:
      case HplsqlParser::T_SQLWARNING:
      case HplsqlParser::T_STATS:
      case HplsqlParser::T_STATISTICS:
      case HplsqlParser::T_STEP:
      case HplsqlParser::T_STORAGE:
      case HplsqlParser::T_STORED:
      case HplsqlParser::T_STRING:
      case HplsqlParser::T_SUBDIR:
      case HplsqlParser::T_SUBSTRING:
      case HplsqlParser::T_SUM:
      case HplsqlParser::T_SYS_REFCURSOR:
      case HplsqlParser::T_TABLE:
      case HplsqlParser::T_TABLESPACE:
      case HplsqlParser::T_TEMPORARY:
      case HplsqlParser::T_TERMINATED:
      case HplsqlParser::T_TEXTIMAGE_ON:
      case HplsqlParser::T_THEN:
      case HplsqlParser::T_TIMESTAMP:
      case HplsqlParser::T_TITLE:
      case HplsqlParser::T_TO:
      case HplsqlParser::T_TOP:
      case HplsqlParser::T_TRANSACTION:
      case HplsqlParser::T_TRUE:
      case HplsqlParser::T_TRUNCATE:
      case HplsqlParser::T_UNIQUE:
      case HplsqlParser::T_UPDATE:
      case HplsqlParser::T_UR:
      case HplsqlParser::T_USE:
      case HplsqlParser::T_USING:
      case HplsqlParser::T_VALUE:
      case HplsqlParser::T_VALUES:
      case HplsqlParser::T_VAR:
      case HplsqlParser::T_VARCHAR:
      case HplsqlParser::T_VARCHAR2:
      case HplsqlParser::T_VARYING:
      case HplsqlParser::T_VOLATILE:
      case HplsqlParser::T_WHILE:
      case HplsqlParser::T_WITH:
      case HplsqlParser::T_WITHOUT:
      case HplsqlParser::T_WORK:
      case HplsqlParser::T_XACT_ABORT:
      case HplsqlParser::T_XML:
      case HplsqlParser::T_YES:
      case HplsqlParser::T_ACTIVITY_COUNT:
      case HplsqlParser::T_CUME_DIST:
      case HplsqlParser::T_CURRENT_DATE:
      case HplsqlParser::T_CURRENT_TIMESTAMP:
      case HplsqlParser::T_CURRENT_USER:
      case HplsqlParser::T_DENSE_RANK:
      case HplsqlParser::T_FIRST_VALUE:
      case HplsqlParser::T_LAG:
      case HplsqlParser::T_LAST_VALUE:
      case HplsqlParser::T_LEAD:
      case HplsqlParser::T_PART_COUNT:
      case HplsqlParser::T_PART_LOC:
      case HplsqlParser::T_RANK:
      case HplsqlParser::T_ROW_NUMBER:
      case HplsqlParser::T_STDEV:
      case HplsqlParser::T_SYSDATE:
      case HplsqlParser::T_VARIANCE:
      case HplsqlParser::T_USER:
      case HplsqlParser::L_ID: {
        enterOuterAlt(_localctx, 1);
        setState(601);
        ident();
        setState(603);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_COLON) {
          setState(602);
          match(HplsqlParser::T_COLON);
        }
        setState(605);
        match(HplsqlParser::T_EQUAL);
        setState(606);
        expr(0);
        break;
      }

      case HplsqlParser::T_OPEN_P: {
        enterOuterAlt(_localctx, 2);
        setState(608);
        match(HplsqlParser::T_OPEN_P);
        setState(609);
        ident();
        setState(610);
        match(HplsqlParser::T_CLOSE_P);
        setState(612);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_COLON) {
          setState(611);
          match(HplsqlParser::T_COLON);
        }
        setState(614);
        match(HplsqlParser::T_EQUAL);
        setState(615);
        expr(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assignment_stmt_multiple_itemContext ------------------------------------------------------------------

HplsqlParser::Assignment_stmt_multiple_itemContext::Assignment_stmt_multiple_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> HplsqlParser::Assignment_stmt_multiple_itemContext::T_OPEN_P() {
  return getTokens(HplsqlParser::T_OPEN_P);
}

tree::TerminalNode* HplsqlParser::Assignment_stmt_multiple_itemContext::T_OPEN_P(size_t i) {
  return getToken(HplsqlParser::T_OPEN_P, i);
}

std::vector<HplsqlParser::IdentContext *> HplsqlParser::Assignment_stmt_multiple_itemContext::ident() {
  return getRuleContexts<HplsqlParser::IdentContext>();
}

HplsqlParser::IdentContext* HplsqlParser::Assignment_stmt_multiple_itemContext::ident(size_t i) {
  return getRuleContext<HplsqlParser::IdentContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Assignment_stmt_multiple_itemContext::T_CLOSE_P() {
  return getTokens(HplsqlParser::T_CLOSE_P);
}

tree::TerminalNode* HplsqlParser::Assignment_stmt_multiple_itemContext::T_CLOSE_P(size_t i) {
  return getToken(HplsqlParser::T_CLOSE_P, i);
}

tree::TerminalNode* HplsqlParser::Assignment_stmt_multiple_itemContext::T_EQUAL() {
  return getToken(HplsqlParser::T_EQUAL, 0);
}

std::vector<HplsqlParser::ExprContext *> HplsqlParser::Assignment_stmt_multiple_itemContext::expr() {
  return getRuleContexts<HplsqlParser::ExprContext>();
}

HplsqlParser::ExprContext* HplsqlParser::Assignment_stmt_multiple_itemContext::expr(size_t i) {
  return getRuleContext<HplsqlParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Assignment_stmt_multiple_itemContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Assignment_stmt_multiple_itemContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}

tree::TerminalNode* HplsqlParser::Assignment_stmt_multiple_itemContext::T_COLON() {
  return getToken(HplsqlParser::T_COLON, 0);
}


size_t HplsqlParser::Assignment_stmt_multiple_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleAssignment_stmt_multiple_item;
}

void HplsqlParser::Assignment_stmt_multiple_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment_stmt_multiple_item(this);
}

void HplsqlParser::Assignment_stmt_multiple_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment_stmt_multiple_item(this);
}


antlrcpp::Any HplsqlParser::Assignment_stmt_multiple_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitAssignment_stmt_multiple_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Assignment_stmt_multiple_itemContext* HplsqlParser::assignment_stmt_multiple_item() {
  Assignment_stmt_multiple_itemContext *_localctx = _tracker.createInstance<Assignment_stmt_multiple_itemContext>(_ctx, getState());
  enterRule(_localctx, 30, HplsqlParser::RuleAssignment_stmt_multiple_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(619);
    match(HplsqlParser::T_OPEN_P);
    setState(620);
    ident();
    setState(625);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HplsqlParser::T_COMMA) {
      setState(621);
      match(HplsqlParser::T_COMMA);
      setState(622);
      ident();
      setState(627);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(628);
    match(HplsqlParser::T_CLOSE_P);
    setState(630);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_COLON) {
      setState(629);
      match(HplsqlParser::T_COLON);
    }
    setState(632);
    match(HplsqlParser::T_EQUAL);
    setState(633);
    match(HplsqlParser::T_OPEN_P);
    setState(634);
    expr(0);
    setState(639);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HplsqlParser::T_COMMA) {
      setState(635);
      match(HplsqlParser::T_COMMA);
      setState(636);
      expr(0);
      setState(641);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(642);
    match(HplsqlParser::T_CLOSE_P);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assignment_stmt_select_itemContext ------------------------------------------------------------------

HplsqlParser::Assignment_stmt_select_itemContext::Assignment_stmt_select_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Assignment_stmt_select_itemContext::T_EQUAL() {
  return getToken(HplsqlParser::T_EQUAL, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Assignment_stmt_select_itemContext::T_OPEN_P() {
  return getTokens(HplsqlParser::T_OPEN_P);
}

tree::TerminalNode* HplsqlParser::Assignment_stmt_select_itemContext::T_OPEN_P(size_t i) {
  return getToken(HplsqlParser::T_OPEN_P, i);
}

HplsqlParser::Select_stmtContext* HplsqlParser::Assignment_stmt_select_itemContext::select_stmt() {
  return getRuleContext<HplsqlParser::Select_stmtContext>(0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Assignment_stmt_select_itemContext::T_CLOSE_P() {
  return getTokens(HplsqlParser::T_CLOSE_P);
}

tree::TerminalNode* HplsqlParser::Assignment_stmt_select_itemContext::T_CLOSE_P(size_t i) {
  return getToken(HplsqlParser::T_CLOSE_P, i);
}

std::vector<HplsqlParser::IdentContext *> HplsqlParser::Assignment_stmt_select_itemContext::ident() {
  return getRuleContexts<HplsqlParser::IdentContext>();
}

HplsqlParser::IdentContext* HplsqlParser::Assignment_stmt_select_itemContext::ident(size_t i) {
  return getRuleContext<HplsqlParser::IdentContext>(i);
}

tree::TerminalNode* HplsqlParser::Assignment_stmt_select_itemContext::T_COLON() {
  return getToken(HplsqlParser::T_COLON, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Assignment_stmt_select_itemContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Assignment_stmt_select_itemContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Assignment_stmt_select_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleAssignment_stmt_select_item;
}

void HplsqlParser::Assignment_stmt_select_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment_stmt_select_item(this);
}

void HplsqlParser::Assignment_stmt_select_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment_stmt_select_item(this);
}


antlrcpp::Any HplsqlParser::Assignment_stmt_select_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitAssignment_stmt_select_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Assignment_stmt_select_itemContext* HplsqlParser::assignment_stmt_select_item() {
  Assignment_stmt_select_itemContext *_localctx = _tracker.createInstance<Assignment_stmt_select_itemContext>(_ctx, getState());
  enterRule(_localctx, 32, HplsqlParser::RuleAssignment_stmt_select_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(656);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_ACTION:
      case HplsqlParser::T_ADD2:
      case HplsqlParser::T_ALL:
      case HplsqlParser::T_ALLOCATE:
      case HplsqlParser::T_ALTER:
      case HplsqlParser::T_AND:
      case HplsqlParser::T_ANSI_NULLS:
      case HplsqlParser::T_ANSI_PADDING:
      case HplsqlParser::T_AS:
      case HplsqlParser::T_ASC:
      case HplsqlParser::T_ASSOCIATE:
      case HplsqlParser::T_AT:
      case HplsqlParser::T_AUTO_INCREMENT:
      case HplsqlParser::T_AVG:
      case HplsqlParser::T_BATCHSIZE:
      case HplsqlParser::T_BEGIN:
      case HplsqlParser::T_BETWEEN:
      case HplsqlParser::T_BIGINT:
      case HplsqlParser::T_BINARY_DOUBLE:
      case HplsqlParser::T_BINARY_FLOAT:
      case HplsqlParser::T_BIT:
      case HplsqlParser::T_BODY:
      case HplsqlParser::T_BREAK:
      case HplsqlParser::T_BY:
      case HplsqlParser::T_BYTE:
      case HplsqlParser::T_CALL:
      case HplsqlParser::T_CALLER:
      case HplsqlParser::T_CASCADE:
      case HplsqlParser::T_CASE:
      case HplsqlParser::T_CASESPECIFIC:
      case HplsqlParser::T_CAST:
      case HplsqlParser::T_CHAR:
      case HplsqlParser::T_CHARACTER:
      case HplsqlParser::T_CHARSET:
      case HplsqlParser::T_CLIENT:
      case HplsqlParser::T_CLOSE:
      case HplsqlParser::T_CLUSTERED:
      case HplsqlParser::T_CMP:
      case HplsqlParser::T_COLLECT:
      case HplsqlParser::T_COLLECTION:
      case HplsqlParser::T_COLUMN:
      case HplsqlParser::T_COMMENT:
      case HplsqlParser::T_CONSTANT:
      case HplsqlParser::T_COMMIT:
      case HplsqlParser::T_COMPRESS:
      case HplsqlParser::T_CONCAT:
      case HplsqlParser::T_CONDITION:
      case HplsqlParser::T_CONSTRAINT:
      case HplsqlParser::T_CONTINUE:
      case HplsqlParser::T_COPY:
      case HplsqlParser::T_COUNT:
      case HplsqlParser::T_COUNT_BIG:
      case HplsqlParser::T_CREATE:
      case HplsqlParser::T_CREATION:
      case HplsqlParser::T_CREATOR:
      case HplsqlParser::T_CS:
      case HplsqlParser::T_CURRENT:
      case HplsqlParser::T_CURRENT_SCHEMA:
      case HplsqlParser::T_CURSOR:
      case HplsqlParser::T_DATABASE:
      case HplsqlParser::T_DATA:
      case HplsqlParser::T_DATE:
      case HplsqlParser::T_DATETIME:
      case HplsqlParser::T_DAY:
      case HplsqlParser::T_DAYS:
      case HplsqlParser::T_DEC:
      case HplsqlParser::T_DECIMAL:
      case HplsqlParser::T_DECLARE:
      case HplsqlParser::T_DEFAULT:
      case HplsqlParser::T_DEFERRED:
      case HplsqlParser::T_DEFINED:
      case HplsqlParser::T_DEFINER:
      case HplsqlParser::T_DEFINITION:
      case HplsqlParser::T_DELETE:
      case HplsqlParser::T_DELIMITED:
      case HplsqlParser::T_DELIMITER:
      case HplsqlParser::T_DESC:
      case HplsqlParser::T_DESCRIBE:
      case HplsqlParser::T_DIAGNOSTICS:
      case HplsqlParser::T_DIR:
      case HplsqlParser::T_DIRECTORY:
      case HplsqlParser::T_DISTINCT:
      case HplsqlParser::T_DISTRIBUTE:
      case HplsqlParser::T_DO:
      case HplsqlParser::T_DOUBLE:
      case HplsqlParser::T_DROP:
      case HplsqlParser::T_DYNAMIC:
      case HplsqlParser::T_ENABLE:
      case HplsqlParser::T_ENGINE:
      case HplsqlParser::T_ESCAPED:
      case HplsqlParser::T_EXCEPT:
      case HplsqlParser::T_EXEC:
      case HplsqlParser::T_EXECUTE:
      case HplsqlParser::T_EXCEPTION:
      case HplsqlParser::T_EXCLUSIVE:
      case HplsqlParser::T_EXISTS:
      case HplsqlParser::T_EXIT:
      case HplsqlParser::T_FALLBACK:
      case HplsqlParser::T_FALSE:
      case HplsqlParser::T_FETCH:
      case HplsqlParser::T_FIELDS:
      case HplsqlParser::T_FILE:
      case HplsqlParser::T_FILES:
      case HplsqlParser::T_FLOAT:
      case HplsqlParser::T_FOR:
      case HplsqlParser::T_FOREIGN:
      case HplsqlParser::T_FORMAT:
      case HplsqlParser::T_FOUND:
      case HplsqlParser::T_FROM:
      case HplsqlParser::T_FULL:
      case HplsqlParser::T_FUNCTION:
      case HplsqlParser::T_GET:
      case HplsqlParser::T_GLOBAL:
      case HplsqlParser::T_GO:
      case HplsqlParser::T_GRANT:
      case HplsqlParser::T_GROUP:
      case HplsqlParser::T_HANDLER:
      case HplsqlParser::T_HASH:
      case HplsqlParser::T_HAVING:
      case HplsqlParser::T_HDFS:
      case HplsqlParser::T_HIVE:
      case HplsqlParser::T_HOST:
      case HplsqlParser::T_IDENTITY:
      case HplsqlParser::T_IF:
      case HplsqlParser::T_IGNORE:
      case HplsqlParser::T_IMMEDIATE:
      case HplsqlParser::T_IN:
      case HplsqlParser::T_INCLUDE:
      case HplsqlParser::T_INDEX:
      case HplsqlParser::T_INITRANS:
      case HplsqlParser::T_INNER:
      case HplsqlParser::T_INOUT:
      case HplsqlParser::T_INSERT:
      case HplsqlParser::T_INT:
      case HplsqlParser::T_INT2:
      case HplsqlParser::T_INT4:
      case HplsqlParser::T_INT8:
      case HplsqlParser::T_INTEGER:
      case HplsqlParser::T_INTERSECT:
      case HplsqlParser::T_INTERVAL:
      case HplsqlParser::T_INTO:
      case HplsqlParser::T_INVOKER:
      case HplsqlParser::T_IS:
      case HplsqlParser::T_ISOPEN:
      case HplsqlParser::T_ITEMS:
      case HplsqlParser::T_JOIN:
      case HplsqlParser::T_KEEP:
      case HplsqlParser::T_KEY:
      case HplsqlParser::T_KEYS:
      case HplsqlParser::T_LANGUAGE:
      case HplsqlParser::T_LEAVE:
      case HplsqlParser::T_LEFT:
      case HplsqlParser::T_LIKE:
      case HplsqlParser::T_LIMIT:
      case HplsqlParser::T_LINES:
      case HplsqlParser::T_LOCAL:
      case HplsqlParser::T_LOCATION:
      case HplsqlParser::T_LOCATOR:
      case HplsqlParser::T_LOCATORS:
      case HplsqlParser::T_LOCKS:
      case HplsqlParser::T_LOG:
      case HplsqlParser::T_LOGGED:
      case HplsqlParser::T_LOGGING:
      case HplsqlParser::T_LOOP:
      case HplsqlParser::T_MAP:
      case HplsqlParser::T_MATCHED:
      case HplsqlParser::T_MAX:
      case HplsqlParser::T_MAXTRANS:
      case HplsqlParser::T_MERGE:
      case HplsqlParser::T_MESSAGE_TEXT:
      case HplsqlParser::T_MICROSECOND:
      case HplsqlParser::T_MICROSECONDS:
      case HplsqlParser::T_MIN:
      case HplsqlParser::T_MULTISET:
      case HplsqlParser::T_NCHAR:
      case HplsqlParser::T_NEW:
      case HplsqlParser::T_NVARCHAR:
      case HplsqlParser::T_NO:
      case HplsqlParser::T_NOCOUNT:
      case HplsqlParser::T_NOCOMPRESS:
      case HplsqlParser::T_NOLOGGING:
      case HplsqlParser::T_NONE:
      case HplsqlParser::T_NOT:
      case HplsqlParser::T_NOTFOUND:
      case HplsqlParser::T_NUMERIC:
      case HplsqlParser::T_NUMBER:
      case HplsqlParser::T_OBJECT:
      case HplsqlParser::T_OFF:
      case HplsqlParser::T_ON:
      case HplsqlParser::T_ONLY:
      case HplsqlParser::T_OPEN:
      case HplsqlParser::T_OR:
      case HplsqlParser::T_ORDER:
      case HplsqlParser::T_OUT:
      case HplsqlParser::T_OUTER:
      case HplsqlParser::T_OVER:
      case HplsqlParser::T_OVERWRITE:
      case HplsqlParser::T_OWNER:
      case HplsqlParser::T_PACKAGE:
      case HplsqlParser::T_PARTITION:
      case HplsqlParser::T_PCTFREE:
      case HplsqlParser::T_PCTUSED:
      case HplsqlParser::T_PRECISION:
      case HplsqlParser::T_PRESERVE:
      case HplsqlParser::T_PRIMARY:
      case HplsqlParser::T_PRINT:
      case HplsqlParser::T_PROC:
      case HplsqlParser::T_PROCEDURE:
      case HplsqlParser::T_QUALIFY:
      case HplsqlParser::T_QUERY_BAND:
      case HplsqlParser::T_QUIT:
      case HplsqlParser::T_QUOTED_IDENTIFIER:
      case HplsqlParser::T_RAISE:
      case HplsqlParser::T_REAL:
      case HplsqlParser::T_REFERENCES:
      case HplsqlParser::T_REGEXP:
      case HplsqlParser::T_REPLACE:
      case HplsqlParser::T_RESIGNAL:
      case HplsqlParser::T_RESTRICT:
      case HplsqlParser::T_RESULT:
      case HplsqlParser::T_RESULT_SET_LOCATOR:
      case HplsqlParser::T_RETURN:
      case HplsqlParser::T_RETURNS:
      case HplsqlParser::T_REVERSE:
      case HplsqlParser::T_RIGHT:
      case HplsqlParser::T_RLIKE:
      case HplsqlParser::T_ROLE:
      case HplsqlParser::T_ROLLBACK:
      case HplsqlParser::T_ROW:
      case HplsqlParser::T_ROWS:
      case HplsqlParser::T_ROW_COUNT:
      case HplsqlParser::T_RR:
      case HplsqlParser::T_RS:
      case HplsqlParser::T_PWD:
      case HplsqlParser::T_TRIM:
      case HplsqlParser::T_SCHEMA:
      case HplsqlParser::T_SECOND:
      case HplsqlParser::T_SECONDS:
      case HplsqlParser::T_SECURITY:
      case HplsqlParser::T_SEGMENT:
      case HplsqlParser::T_SEL:
      case HplsqlParser::T_SELECT:
      case HplsqlParser::T_SET:
      case HplsqlParser::T_SESSION:
      case HplsqlParser::T_SESSIONS:
      case HplsqlParser::T_SETS:
      case HplsqlParser::T_SHARE:
      case HplsqlParser::T_SIGNAL:
      case HplsqlParser::T_SIMPLE_DOUBLE:
      case HplsqlParser::T_SIMPLE_FLOAT:
      case HplsqlParser::T_SMALLDATETIME:
      case HplsqlParser::T_SMALLINT:
      case HplsqlParser::T_SQL:
      case HplsqlParser::T_SQLEXCEPTION:
      case HplsqlParser::T_SQLINSERT:
      case HplsqlParser::T_SQLSTATE:
      case HplsqlParser::T_SQLWARNING:
      case HplsqlParser::T_STATS:
      case HplsqlParser::T_STATISTICS:
      case HplsqlParser::T_STEP:
      case HplsqlParser::T_STORAGE:
      case HplsqlParser::T_STORED:
      case HplsqlParser::T_STRING:
      case HplsqlParser::T_SUBDIR:
      case HplsqlParser::T_SUBSTRING:
      case HplsqlParser::T_SUM:
      case HplsqlParser::T_SYS_REFCURSOR:
      case HplsqlParser::T_TABLE:
      case HplsqlParser::T_TABLESPACE:
      case HplsqlParser::T_TEMPORARY:
      case HplsqlParser::T_TERMINATED:
      case HplsqlParser::T_TEXTIMAGE_ON:
      case HplsqlParser::T_THEN:
      case HplsqlParser::T_TIMESTAMP:
      case HplsqlParser::T_TITLE:
      case HplsqlParser::T_TO:
      case HplsqlParser::T_TOP:
      case HplsqlParser::T_TRANSACTION:
      case HplsqlParser::T_TRUE:
      case HplsqlParser::T_TRUNCATE:
      case HplsqlParser::T_UNIQUE:
      case HplsqlParser::T_UPDATE:
      case HplsqlParser::T_UR:
      case HplsqlParser::T_USE:
      case HplsqlParser::T_USING:
      case HplsqlParser::T_VALUE:
      case HplsqlParser::T_VALUES:
      case HplsqlParser::T_VAR:
      case HplsqlParser::T_VARCHAR:
      case HplsqlParser::T_VARCHAR2:
      case HplsqlParser::T_VARYING:
      case HplsqlParser::T_VOLATILE:
      case HplsqlParser::T_WHILE:
      case HplsqlParser::T_WITH:
      case HplsqlParser::T_WITHOUT:
      case HplsqlParser::T_WORK:
      case HplsqlParser::T_XACT_ABORT:
      case HplsqlParser::T_XML:
      case HplsqlParser::T_YES:
      case HplsqlParser::T_ACTIVITY_COUNT:
      case HplsqlParser::T_CUME_DIST:
      case HplsqlParser::T_CURRENT_DATE:
      case HplsqlParser::T_CURRENT_TIMESTAMP:
      case HplsqlParser::T_CURRENT_USER:
      case HplsqlParser::T_DENSE_RANK:
      case HplsqlParser::T_FIRST_VALUE:
      case HplsqlParser::T_LAG:
      case HplsqlParser::T_LAST_VALUE:
      case HplsqlParser::T_LEAD:
      case HplsqlParser::T_PART_COUNT:
      case HplsqlParser::T_PART_LOC:
      case HplsqlParser::T_RANK:
      case HplsqlParser::T_ROW_NUMBER:
      case HplsqlParser::T_STDEV:
      case HplsqlParser::T_SYSDATE:
      case HplsqlParser::T_VARIANCE:
      case HplsqlParser::T_USER:
      case HplsqlParser::L_ID: {
        setState(644);
        ident();
        break;
      }

      case HplsqlParser::T_OPEN_P: {
        setState(645);
        match(HplsqlParser::T_OPEN_P);
        setState(646);
        ident();
        setState(651);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == HplsqlParser::T_COMMA) {
          setState(647);
          match(HplsqlParser::T_COMMA);
          setState(648);
          ident();
          setState(653);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(654);
        match(HplsqlParser::T_CLOSE_P);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(659);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_COLON) {
      setState(658);
      match(HplsqlParser::T_COLON);
    }
    setState(661);
    match(HplsqlParser::T_EQUAL);
    setState(662);
    match(HplsqlParser::T_OPEN_P);
    setState(663);
    select_stmt();
    setState(664);
    match(HplsqlParser::T_CLOSE_P);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Allocate_cursor_stmtContext ------------------------------------------------------------------

HplsqlParser::Allocate_cursor_stmtContext::Allocate_cursor_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Allocate_cursor_stmtContext::T_ALLOCATE() {
  return getToken(HplsqlParser::T_ALLOCATE, 0);
}

std::vector<HplsqlParser::IdentContext *> HplsqlParser::Allocate_cursor_stmtContext::ident() {
  return getRuleContexts<HplsqlParser::IdentContext>();
}

HplsqlParser::IdentContext* HplsqlParser::Allocate_cursor_stmtContext::ident(size_t i) {
  return getRuleContext<HplsqlParser::IdentContext>(i);
}

tree::TerminalNode* HplsqlParser::Allocate_cursor_stmtContext::T_CURSOR() {
  return getToken(HplsqlParser::T_CURSOR, 0);
}

tree::TerminalNode* HplsqlParser::Allocate_cursor_stmtContext::T_FOR() {
  return getToken(HplsqlParser::T_FOR, 0);
}

tree::TerminalNode* HplsqlParser::Allocate_cursor_stmtContext::T_PROCEDURE() {
  return getToken(HplsqlParser::T_PROCEDURE, 0);
}

tree::TerminalNode* HplsqlParser::Allocate_cursor_stmtContext::T_RESULT() {
  return getToken(HplsqlParser::T_RESULT, 0);
}

tree::TerminalNode* HplsqlParser::Allocate_cursor_stmtContext::T_SET() {
  return getToken(HplsqlParser::T_SET, 0);
}


size_t HplsqlParser::Allocate_cursor_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleAllocate_cursor_stmt;
}

void HplsqlParser::Allocate_cursor_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAllocate_cursor_stmt(this);
}

void HplsqlParser::Allocate_cursor_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAllocate_cursor_stmt(this);
}


antlrcpp::Any HplsqlParser::Allocate_cursor_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitAllocate_cursor_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Allocate_cursor_stmtContext* HplsqlParser::allocate_cursor_stmt() {
  Allocate_cursor_stmtContext *_localctx = _tracker.createInstance<Allocate_cursor_stmtContext>(_ctx, getState());
  enterRule(_localctx, 34, HplsqlParser::RuleAllocate_cursor_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(666);
    match(HplsqlParser::T_ALLOCATE);
    setState(667);
    ident();
    setState(668);
    match(HplsqlParser::T_CURSOR);
    setState(669);
    match(HplsqlParser::T_FOR);
    setState(673);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_RESULT: {
        setState(670);
        match(HplsqlParser::T_RESULT);
        setState(671);
        match(HplsqlParser::T_SET);
        break;
      }

      case HplsqlParser::T_PROCEDURE: {
        setState(672);
        match(HplsqlParser::T_PROCEDURE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(675);
    ident();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Associate_locator_stmtContext ------------------------------------------------------------------

HplsqlParser::Associate_locator_stmtContext::Associate_locator_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Associate_locator_stmtContext::T_ASSOCIATE() {
  return getToken(HplsqlParser::T_ASSOCIATE, 0);
}

tree::TerminalNode* HplsqlParser::Associate_locator_stmtContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

std::vector<HplsqlParser::IdentContext *> HplsqlParser::Associate_locator_stmtContext::ident() {
  return getRuleContexts<HplsqlParser::IdentContext>();
}

HplsqlParser::IdentContext* HplsqlParser::Associate_locator_stmtContext::ident(size_t i) {
  return getRuleContext<HplsqlParser::IdentContext>(i);
}

tree::TerminalNode* HplsqlParser::Associate_locator_stmtContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

tree::TerminalNode* HplsqlParser::Associate_locator_stmtContext::T_WITH() {
  return getToken(HplsqlParser::T_WITH, 0);
}

tree::TerminalNode* HplsqlParser::Associate_locator_stmtContext::T_PROCEDURE() {
  return getToken(HplsqlParser::T_PROCEDURE, 0);
}

tree::TerminalNode* HplsqlParser::Associate_locator_stmtContext::T_LOCATOR() {
  return getToken(HplsqlParser::T_LOCATOR, 0);
}

tree::TerminalNode* HplsqlParser::Associate_locator_stmtContext::T_LOCATORS() {
  return getToken(HplsqlParser::T_LOCATORS, 0);
}

tree::TerminalNode* HplsqlParser::Associate_locator_stmtContext::T_RESULT() {
  return getToken(HplsqlParser::T_RESULT, 0);
}

tree::TerminalNode* HplsqlParser::Associate_locator_stmtContext::T_SET() {
  return getToken(HplsqlParser::T_SET, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Associate_locator_stmtContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Associate_locator_stmtContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Associate_locator_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleAssociate_locator_stmt;
}

void HplsqlParser::Associate_locator_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssociate_locator_stmt(this);
}

void HplsqlParser::Associate_locator_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssociate_locator_stmt(this);
}


antlrcpp::Any HplsqlParser::Associate_locator_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitAssociate_locator_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Associate_locator_stmtContext* HplsqlParser::associate_locator_stmt() {
  Associate_locator_stmtContext *_localctx = _tracker.createInstance<Associate_locator_stmtContext>(_ctx, getState());
  enterRule(_localctx, 36, HplsqlParser::RuleAssociate_locator_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(677);
    match(HplsqlParser::T_ASSOCIATE);
    setState(680);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_RESULT) {
      setState(678);
      match(HplsqlParser::T_RESULT);
      setState(679);
      match(HplsqlParser::T_SET);
    }
    setState(682);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_LOCATOR

    || _la == HplsqlParser::T_LOCATORS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(683);
    match(HplsqlParser::T_OPEN_P);
    setState(684);
    ident();
    setState(689);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HplsqlParser::T_COMMA) {
      setState(685);
      match(HplsqlParser::T_COMMA);
      setState(686);
      ident();
      setState(691);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(692);
    match(HplsqlParser::T_CLOSE_P);
    setState(693);
    match(HplsqlParser::T_WITH);
    setState(694);
    match(HplsqlParser::T_PROCEDURE);
    setState(695);
    ident();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Begin_transaction_stmtContext ------------------------------------------------------------------

HplsqlParser::Begin_transaction_stmtContext::Begin_transaction_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Begin_transaction_stmtContext::T_BEGIN() {
  return getToken(HplsqlParser::T_BEGIN, 0);
}

tree::TerminalNode* HplsqlParser::Begin_transaction_stmtContext::T_TRANSACTION() {
  return getToken(HplsqlParser::T_TRANSACTION, 0);
}


size_t HplsqlParser::Begin_transaction_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleBegin_transaction_stmt;
}

void HplsqlParser::Begin_transaction_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBegin_transaction_stmt(this);
}

void HplsqlParser::Begin_transaction_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBegin_transaction_stmt(this);
}


antlrcpp::Any HplsqlParser::Begin_transaction_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitBegin_transaction_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Begin_transaction_stmtContext* HplsqlParser::begin_transaction_stmt() {
  Begin_transaction_stmtContext *_localctx = _tracker.createInstance<Begin_transaction_stmtContext>(_ctx, getState());
  enterRule(_localctx, 38, HplsqlParser::RuleBegin_transaction_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(697);
    match(HplsqlParser::T_BEGIN);
    setState(698);
    match(HplsqlParser::T_TRANSACTION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Break_stmtContext ------------------------------------------------------------------

HplsqlParser::Break_stmtContext::Break_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Break_stmtContext::T_BREAK() {
  return getToken(HplsqlParser::T_BREAK, 0);
}


size_t HplsqlParser::Break_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleBreak_stmt;
}

void HplsqlParser::Break_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBreak_stmt(this);
}

void HplsqlParser::Break_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBreak_stmt(this);
}


antlrcpp::Any HplsqlParser::Break_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitBreak_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Break_stmtContext* HplsqlParser::break_stmt() {
  Break_stmtContext *_localctx = _tracker.createInstance<Break_stmtContext>(_ctx, getState());
  enterRule(_localctx, 40, HplsqlParser::RuleBreak_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(700);
    match(HplsqlParser::T_BREAK);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Call_stmtContext ------------------------------------------------------------------

HplsqlParser::Call_stmtContext::Call_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Call_stmtContext::T_CALL() {
  return getToken(HplsqlParser::T_CALL, 0);
}

HplsqlParser::IdentContext* HplsqlParser::Call_stmtContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

tree::TerminalNode* HplsqlParser::Call_stmtContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

tree::TerminalNode* HplsqlParser::Call_stmtContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

HplsqlParser::Expr_func_paramsContext* HplsqlParser::Call_stmtContext::expr_func_params() {
  return getRuleContext<HplsqlParser::Expr_func_paramsContext>(0);
}


size_t HplsqlParser::Call_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleCall_stmt;
}

void HplsqlParser::Call_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCall_stmt(this);
}

void HplsqlParser::Call_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCall_stmt(this);
}


antlrcpp::Any HplsqlParser::Call_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCall_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Call_stmtContext* HplsqlParser::call_stmt() {
  Call_stmtContext *_localctx = _tracker.createInstance<Call_stmtContext>(_ctx, getState());
  enterRule(_localctx, 42, HplsqlParser::RuleCall_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(702);
    match(HplsqlParser::T_CALL);
    setState(703);
    ident();
    setState(710);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
    case 1: {
      setState(704);
      match(HplsqlParser::T_OPEN_P);
      setState(706);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
      case 1: {
        setState(705);
        expr_func_params();
        break;
      }

      default:
        break;
      }
      setState(708);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 2: {
      setState(709);
      expr_func_params();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_stmtContext ------------------------------------------------------------------

HplsqlParser::Declare_stmtContext::Declare_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Declare_stmtContext::T_DECLARE() {
  return getToken(HplsqlParser::T_DECLARE, 0);
}

std::vector<HplsqlParser::Declare_stmt_itemContext *> HplsqlParser::Declare_stmtContext::declare_stmt_item() {
  return getRuleContexts<HplsqlParser::Declare_stmt_itemContext>();
}

HplsqlParser::Declare_stmt_itemContext* HplsqlParser::Declare_stmtContext::declare_stmt_item(size_t i) {
  return getRuleContext<HplsqlParser::Declare_stmt_itemContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Declare_stmtContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Declare_stmtContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Declare_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleDeclare_stmt;
}

void HplsqlParser::Declare_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_stmt(this);
}

void HplsqlParser::Declare_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_stmt(this);
}


antlrcpp::Any HplsqlParser::Declare_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitDeclare_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Declare_stmtContext* HplsqlParser::declare_stmt() {
  Declare_stmtContext *_localctx = _tracker.createInstance<Declare_stmtContext>(_ctx, getState());
  enterRule(_localctx, 44, HplsqlParser::RuleDeclare_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(712);
    match(HplsqlParser::T_DECLARE);
    setState(713);
    declare_stmt_item();
    setState(718);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(714);
        match(HplsqlParser::T_COMMA);
        setState(715);
        declare_stmt_item(); 
      }
      setState(720);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_blockContext ------------------------------------------------------------------

HplsqlParser::Declare_blockContext::Declare_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Declare_blockContext::T_DECLARE() {
  return getToken(HplsqlParser::T_DECLARE, 0);
}

std::vector<HplsqlParser::Declare_stmt_itemContext *> HplsqlParser::Declare_blockContext::declare_stmt_item() {
  return getRuleContexts<HplsqlParser::Declare_stmt_itemContext>();
}

HplsqlParser::Declare_stmt_itemContext* HplsqlParser::Declare_blockContext::declare_stmt_item(size_t i) {
  return getRuleContext<HplsqlParser::Declare_stmt_itemContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Declare_blockContext::T_SEMICOLON() {
  return getTokens(HplsqlParser::T_SEMICOLON);
}

tree::TerminalNode* HplsqlParser::Declare_blockContext::T_SEMICOLON(size_t i) {
  return getToken(HplsqlParser::T_SEMICOLON, i);
}


size_t HplsqlParser::Declare_blockContext::getRuleIndex() const {
  return HplsqlParser::RuleDeclare_block;
}

void HplsqlParser::Declare_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_block(this);
}

void HplsqlParser::Declare_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_block(this);
}


antlrcpp::Any HplsqlParser::Declare_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitDeclare_block(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Declare_blockContext* HplsqlParser::declare_block() {
  Declare_blockContext *_localctx = _tracker.createInstance<Declare_blockContext>(_ctx, getState());
  enterRule(_localctx, 46, HplsqlParser::RuleDeclare_block);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(721);
    match(HplsqlParser::T_DECLARE);
    setState(722);
    declare_stmt_item();
    setState(723);
    match(HplsqlParser::T_SEMICOLON);
    setState(729);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(724);
        declare_stmt_item();
        setState(725);
        match(HplsqlParser::T_SEMICOLON); 
      }
      setState(731);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_block_inplaceContext ------------------------------------------------------------------

HplsqlParser::Declare_block_inplaceContext::Declare_block_inplaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HplsqlParser::Declare_stmt_itemContext *> HplsqlParser::Declare_block_inplaceContext::declare_stmt_item() {
  return getRuleContexts<HplsqlParser::Declare_stmt_itemContext>();
}

HplsqlParser::Declare_stmt_itemContext* HplsqlParser::Declare_block_inplaceContext::declare_stmt_item(size_t i) {
  return getRuleContext<HplsqlParser::Declare_stmt_itemContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Declare_block_inplaceContext::T_SEMICOLON() {
  return getTokens(HplsqlParser::T_SEMICOLON);
}

tree::TerminalNode* HplsqlParser::Declare_block_inplaceContext::T_SEMICOLON(size_t i) {
  return getToken(HplsqlParser::T_SEMICOLON, i);
}


size_t HplsqlParser::Declare_block_inplaceContext::getRuleIndex() const {
  return HplsqlParser::RuleDeclare_block_inplace;
}

void HplsqlParser::Declare_block_inplaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_block_inplace(this);
}

void HplsqlParser::Declare_block_inplaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_block_inplace(this);
}


antlrcpp::Any HplsqlParser::Declare_block_inplaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitDeclare_block_inplace(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Declare_block_inplaceContext* HplsqlParser::declare_block_inplace() {
  Declare_block_inplaceContext *_localctx = _tracker.createInstance<Declare_block_inplaceContext>(_ctx, getState());
  enterRule(_localctx, 48, HplsqlParser::RuleDeclare_block_inplace);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(732);
    declare_stmt_item();
    setState(733);
    match(HplsqlParser::T_SEMICOLON);
    setState(739);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(734);
        declare_stmt_item();
        setState(735);
        match(HplsqlParser::T_SEMICOLON); 
      }
      setState(741);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_stmt_itemContext ------------------------------------------------------------------

HplsqlParser::Declare_stmt_itemContext::Declare_stmt_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Declare_cursor_itemContext* HplsqlParser::Declare_stmt_itemContext::declare_cursor_item() {
  return getRuleContext<HplsqlParser::Declare_cursor_itemContext>(0);
}

HplsqlParser::Declare_condition_itemContext* HplsqlParser::Declare_stmt_itemContext::declare_condition_item() {
  return getRuleContext<HplsqlParser::Declare_condition_itemContext>(0);
}

HplsqlParser::Declare_handler_itemContext* HplsqlParser::Declare_stmt_itemContext::declare_handler_item() {
  return getRuleContext<HplsqlParser::Declare_handler_itemContext>(0);
}

HplsqlParser::Declare_var_itemContext* HplsqlParser::Declare_stmt_itemContext::declare_var_item() {
  return getRuleContext<HplsqlParser::Declare_var_itemContext>(0);
}

HplsqlParser::Declare_temporary_table_itemContext* HplsqlParser::Declare_stmt_itemContext::declare_temporary_table_item() {
  return getRuleContext<HplsqlParser::Declare_temporary_table_itemContext>(0);
}


size_t HplsqlParser::Declare_stmt_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleDeclare_stmt_item;
}

void HplsqlParser::Declare_stmt_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_stmt_item(this);
}

void HplsqlParser::Declare_stmt_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_stmt_item(this);
}


antlrcpp::Any HplsqlParser::Declare_stmt_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitDeclare_stmt_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Declare_stmt_itemContext* HplsqlParser::declare_stmt_item() {
  Declare_stmt_itemContext *_localctx = _tracker.createInstance<Declare_stmt_itemContext>(_ctx, getState());
  enterRule(_localctx, 50, HplsqlParser::RuleDeclare_stmt_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(747);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(742);
      declare_cursor_item();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(743);
      declare_condition_item();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(744);
      declare_handler_item();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(745);
      declare_var_item();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(746);
      declare_temporary_table_item();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_var_itemContext ------------------------------------------------------------------

HplsqlParser::Declare_var_itemContext::Declare_var_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HplsqlParser::IdentContext *> HplsqlParser::Declare_var_itemContext::ident() {
  return getRuleContexts<HplsqlParser::IdentContext>();
}

HplsqlParser::IdentContext* HplsqlParser::Declare_var_itemContext::ident(size_t i) {
  return getRuleContext<HplsqlParser::IdentContext>(i);
}

HplsqlParser::DtypeContext* HplsqlParser::Declare_var_itemContext::dtype() {
  return getRuleContext<HplsqlParser::DtypeContext>(0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Declare_var_itemContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Declare_var_itemContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}

tree::TerminalNode* HplsqlParser::Declare_var_itemContext::T_AS() {
  return getToken(HplsqlParser::T_AS, 0);
}

HplsqlParser::Dtype_lenContext* HplsqlParser::Declare_var_itemContext::dtype_len() {
  return getRuleContext<HplsqlParser::Dtype_lenContext>(0);
}

std::vector<HplsqlParser::Dtype_attrContext *> HplsqlParser::Declare_var_itemContext::dtype_attr() {
  return getRuleContexts<HplsqlParser::Dtype_attrContext>();
}

HplsqlParser::Dtype_attrContext* HplsqlParser::Declare_var_itemContext::dtype_attr(size_t i) {
  return getRuleContext<HplsqlParser::Dtype_attrContext>(i);
}

HplsqlParser::Dtype_defaultContext* HplsqlParser::Declare_var_itemContext::dtype_default() {
  return getRuleContext<HplsqlParser::Dtype_defaultContext>(0);
}

tree::TerminalNode* HplsqlParser::Declare_var_itemContext::T_CONSTANT() {
  return getToken(HplsqlParser::T_CONSTANT, 0);
}


size_t HplsqlParser::Declare_var_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleDeclare_var_item;
}

void HplsqlParser::Declare_var_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_var_item(this);
}

void HplsqlParser::Declare_var_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_var_item(this);
}


antlrcpp::Any HplsqlParser::Declare_var_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitDeclare_var_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Declare_var_itemContext* HplsqlParser::declare_var_item() {
  Declare_var_itemContext *_localctx = _tracker.createInstance<Declare_var_itemContext>(_ctx, getState());
  enterRule(_localctx, 52, HplsqlParser::RuleDeclare_var_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(784);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(749);
      ident();
      setState(754);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == HplsqlParser::T_COMMA) {
        setState(750);
        match(HplsqlParser::T_COMMA);
        setState(751);
        ident();
        setState(756);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(758);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx)) {
      case 1: {
        setState(757);
        match(HplsqlParser::T_AS);
        break;
      }

      default:
        break;
      }
      setState(760);
      dtype();
      setState(762);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx)) {
      case 1: {
        setState(761);
        dtype_len();
        break;
      }

      default:
        break;
      }
      setState(767);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(764);
          dtype_attr(); 
        }
        setState(769);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx);
      }
      setState(771);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx)) {
      case 1: {
        setState(770);
        dtype_default();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(773);
      ident();
      setState(774);
      match(HplsqlParser::T_CONSTANT);
      setState(776);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
      case 1: {
        setState(775);
        match(HplsqlParser::T_AS);
        break;
      }

      default:
        break;
      }
      setState(778);
      dtype();
      setState(780);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HplsqlParser::T_OPEN_P) {
        setState(779);
        dtype_len();
      }
      setState(782);
      dtype_default();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_condition_itemContext ------------------------------------------------------------------

HplsqlParser::Declare_condition_itemContext::Declare_condition_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::IdentContext* HplsqlParser::Declare_condition_itemContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

tree::TerminalNode* HplsqlParser::Declare_condition_itemContext::T_CONDITION() {
  return getToken(HplsqlParser::T_CONDITION, 0);
}


size_t HplsqlParser::Declare_condition_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleDeclare_condition_item;
}

void HplsqlParser::Declare_condition_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_condition_item(this);
}

void HplsqlParser::Declare_condition_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_condition_item(this);
}


antlrcpp::Any HplsqlParser::Declare_condition_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitDeclare_condition_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Declare_condition_itemContext* HplsqlParser::declare_condition_item() {
  Declare_condition_itemContext *_localctx = _tracker.createInstance<Declare_condition_itemContext>(_ctx, getState());
  enterRule(_localctx, 54, HplsqlParser::RuleDeclare_condition_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(786);
    ident();
    setState(787);
    match(HplsqlParser::T_CONDITION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_cursor_itemContext ------------------------------------------------------------------

HplsqlParser::Declare_cursor_itemContext::Declare_cursor_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Declare_cursor_itemContext::T_IS() {
  return getToken(HplsqlParser::T_IS, 0);
}

tree::TerminalNode* HplsqlParser::Declare_cursor_itemContext::T_AS() {
  return getToken(HplsqlParser::T_AS, 0);
}

tree::TerminalNode* HplsqlParser::Declare_cursor_itemContext::T_FOR() {
  return getToken(HplsqlParser::T_FOR, 0);
}

tree::TerminalNode* HplsqlParser::Declare_cursor_itemContext::T_CURSOR() {
  return getToken(HplsqlParser::T_CURSOR, 0);
}

HplsqlParser::IdentContext* HplsqlParser::Declare_cursor_itemContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

HplsqlParser::Select_stmtContext* HplsqlParser::Declare_cursor_itemContext::select_stmt() {
  return getRuleContext<HplsqlParser::Select_stmtContext>(0);
}

HplsqlParser::ExprContext* HplsqlParser::Declare_cursor_itemContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}

HplsqlParser::Cursor_with_returnContext* HplsqlParser::Declare_cursor_itemContext::cursor_with_return() {
  return getRuleContext<HplsqlParser::Cursor_with_returnContext>(0);
}

HplsqlParser::Cursor_without_returnContext* HplsqlParser::Declare_cursor_itemContext::cursor_without_return() {
  return getRuleContext<HplsqlParser::Cursor_without_returnContext>(0);
}


size_t HplsqlParser::Declare_cursor_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleDeclare_cursor_item;
}

void HplsqlParser::Declare_cursor_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_cursor_item(this);
}

void HplsqlParser::Declare_cursor_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_cursor_item(this);
}


antlrcpp::Any HplsqlParser::Declare_cursor_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitDeclare_cursor_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Declare_cursor_itemContext* HplsqlParser::declare_cursor_item() {
  Declare_cursor_itemContext *_localctx = _tracker.createInstance<Declare_cursor_itemContext>(_ctx, getState());
  enterRule(_localctx, 56, HplsqlParser::RuleDeclare_cursor_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(794);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
    case 1: {
      setState(789);
      match(HplsqlParser::T_CURSOR);
      setState(790);
      ident();
      break;
    }

    case 2: {
      setState(791);
      ident();
      setState(792);
      match(HplsqlParser::T_CURSOR);
      break;
    }

    default:
      break;
    }
    setState(798);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_WITH: {
        setState(796);
        cursor_with_return();
        break;
      }

      case HplsqlParser::T_WITHOUT: {
        setState(797);
        cursor_without_return();
        break;
      }

      case HplsqlParser::T_AS:
      case HplsqlParser::T_FOR:
      case HplsqlParser::T_IS: {
        break;
      }

    default:
      break;
    }
    setState(800);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_AS || _la == HplsqlParser::T_FOR

    || _la == HplsqlParser::T_IS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(803);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx)) {
    case 1: {
      setState(801);
      select_stmt();
      break;
    }

    case 2: {
      setState(802);
      expr(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cursor_with_returnContext ------------------------------------------------------------------

HplsqlParser::Cursor_with_returnContext::Cursor_with_returnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Cursor_with_returnContext::T_WITH() {
  return getToken(HplsqlParser::T_WITH, 0);
}

tree::TerminalNode* HplsqlParser::Cursor_with_returnContext::T_RETURN() {
  return getToken(HplsqlParser::T_RETURN, 0);
}

tree::TerminalNode* HplsqlParser::Cursor_with_returnContext::T_ONLY() {
  return getToken(HplsqlParser::T_ONLY, 0);
}

tree::TerminalNode* HplsqlParser::Cursor_with_returnContext::T_TO() {
  return getToken(HplsqlParser::T_TO, 0);
}

tree::TerminalNode* HplsqlParser::Cursor_with_returnContext::T_CALLER() {
  return getToken(HplsqlParser::T_CALLER, 0);
}

tree::TerminalNode* HplsqlParser::Cursor_with_returnContext::T_CLIENT() {
  return getToken(HplsqlParser::T_CLIENT, 0);
}


size_t HplsqlParser::Cursor_with_returnContext::getRuleIndex() const {
  return HplsqlParser::RuleCursor_with_return;
}

void HplsqlParser::Cursor_with_returnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursor_with_return(this);
}

void HplsqlParser::Cursor_with_returnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursor_with_return(this);
}


antlrcpp::Any HplsqlParser::Cursor_with_returnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCursor_with_return(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Cursor_with_returnContext* HplsqlParser::cursor_with_return() {
  Cursor_with_returnContext *_localctx = _tracker.createInstance<Cursor_with_returnContext>(_ctx, getState());
  enterRule(_localctx, 58, HplsqlParser::RuleCursor_with_return);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(805);
    match(HplsqlParser::T_WITH);
    setState(806);
    match(HplsqlParser::T_RETURN);
    setState(808);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_ONLY) {
      setState(807);
      match(HplsqlParser::T_ONLY);
    }
    setState(812);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_TO) {
      setState(810);
      match(HplsqlParser::T_TO);
      setState(811);
      _la = _input->LA(1);
      if (!(_la == HplsqlParser::T_CALLER

      || _la == HplsqlParser::T_CLIENT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cursor_without_returnContext ------------------------------------------------------------------

HplsqlParser::Cursor_without_returnContext::Cursor_without_returnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Cursor_without_returnContext::T_WITHOUT() {
  return getToken(HplsqlParser::T_WITHOUT, 0);
}

tree::TerminalNode* HplsqlParser::Cursor_without_returnContext::T_RETURN() {
  return getToken(HplsqlParser::T_RETURN, 0);
}


size_t HplsqlParser::Cursor_without_returnContext::getRuleIndex() const {
  return HplsqlParser::RuleCursor_without_return;
}

void HplsqlParser::Cursor_without_returnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursor_without_return(this);
}

void HplsqlParser::Cursor_without_returnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursor_without_return(this);
}


antlrcpp::Any HplsqlParser::Cursor_without_returnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCursor_without_return(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Cursor_without_returnContext* HplsqlParser::cursor_without_return() {
  Cursor_without_returnContext *_localctx = _tracker.createInstance<Cursor_without_returnContext>(_ctx, getState());
  enterRule(_localctx, 60, HplsqlParser::RuleCursor_without_return);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(814);
    match(HplsqlParser::T_WITHOUT);
    setState(815);
    match(HplsqlParser::T_RETURN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_handler_itemContext ------------------------------------------------------------------

HplsqlParser::Declare_handler_itemContext::Declare_handler_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Declare_handler_itemContext::T_HANDLER() {
  return getToken(HplsqlParser::T_HANDLER, 0);
}

tree::TerminalNode* HplsqlParser::Declare_handler_itemContext::T_FOR() {
  return getToken(HplsqlParser::T_FOR, 0);
}

HplsqlParser::Single_block_stmtContext* HplsqlParser::Declare_handler_itemContext::single_block_stmt() {
  return getRuleContext<HplsqlParser::Single_block_stmtContext>(0);
}

tree::TerminalNode* HplsqlParser::Declare_handler_itemContext::T_CONTINUE() {
  return getToken(HplsqlParser::T_CONTINUE, 0);
}

tree::TerminalNode* HplsqlParser::Declare_handler_itemContext::T_EXIT() {
  return getToken(HplsqlParser::T_EXIT, 0);
}

tree::TerminalNode* HplsqlParser::Declare_handler_itemContext::T_SQLEXCEPTION() {
  return getToken(HplsqlParser::T_SQLEXCEPTION, 0);
}

tree::TerminalNode* HplsqlParser::Declare_handler_itemContext::T_SQLWARNING() {
  return getToken(HplsqlParser::T_SQLWARNING, 0);
}

tree::TerminalNode* HplsqlParser::Declare_handler_itemContext::T_NOT() {
  return getToken(HplsqlParser::T_NOT, 0);
}

tree::TerminalNode* HplsqlParser::Declare_handler_itemContext::T_FOUND() {
  return getToken(HplsqlParser::T_FOUND, 0);
}

HplsqlParser::IdentContext* HplsqlParser::Declare_handler_itemContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}


size_t HplsqlParser::Declare_handler_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleDeclare_handler_item;
}

void HplsqlParser::Declare_handler_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_handler_item(this);
}

void HplsqlParser::Declare_handler_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_handler_item(this);
}


antlrcpp::Any HplsqlParser::Declare_handler_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitDeclare_handler_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Declare_handler_itemContext* HplsqlParser::declare_handler_item() {
  Declare_handler_itemContext *_localctx = _tracker.createInstance<Declare_handler_itemContext>(_ctx, getState());
  enterRule(_localctx, 62, HplsqlParser::RuleDeclare_handler_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(817);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_CONTINUE

    || _la == HplsqlParser::T_EXIT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(818);
    match(HplsqlParser::T_HANDLER);
    setState(819);
    match(HplsqlParser::T_FOR);
    setState(825);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx)) {
    case 1: {
      setState(820);
      match(HplsqlParser::T_SQLEXCEPTION);
      break;
    }

    case 2: {
      setState(821);
      match(HplsqlParser::T_SQLWARNING);
      break;
    }

    case 3: {
      setState(822);
      match(HplsqlParser::T_NOT);
      setState(823);
      match(HplsqlParser::T_FOUND);
      break;
    }

    case 4: {
      setState(824);
      ident();
      break;
    }

    default:
      break;
    }
    setState(827);
    single_block_stmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declare_temporary_table_itemContext ------------------------------------------------------------------

HplsqlParser::Declare_temporary_table_itemContext::Declare_temporary_table_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Declare_temporary_table_itemContext::T_TEMPORARY() {
  return getToken(HplsqlParser::T_TEMPORARY, 0);
}

tree::TerminalNode* HplsqlParser::Declare_temporary_table_itemContext::T_TABLE() {
  return getToken(HplsqlParser::T_TABLE, 0);
}

HplsqlParser::IdentContext* HplsqlParser::Declare_temporary_table_itemContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

HplsqlParser::Create_table_definitionContext* HplsqlParser::Declare_temporary_table_itemContext::create_table_definition() {
  return getRuleContext<HplsqlParser::Create_table_definitionContext>(0);
}

tree::TerminalNode* HplsqlParser::Declare_temporary_table_itemContext::T_GLOBAL() {
  return getToken(HplsqlParser::T_GLOBAL, 0);
}

HplsqlParser::Create_table_preoptionsContext* HplsqlParser::Declare_temporary_table_itemContext::create_table_preoptions() {
  return getRuleContext<HplsqlParser::Create_table_preoptionsContext>(0);
}


size_t HplsqlParser::Declare_temporary_table_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleDeclare_temporary_table_item;
}

void HplsqlParser::Declare_temporary_table_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclare_temporary_table_item(this);
}

void HplsqlParser::Declare_temporary_table_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclare_temporary_table_item(this);
}


antlrcpp::Any HplsqlParser::Declare_temporary_table_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitDeclare_temporary_table_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Declare_temporary_table_itemContext* HplsqlParser::declare_temporary_table_item() {
  Declare_temporary_table_itemContext *_localctx = _tracker.createInstance<Declare_temporary_table_itemContext>(_ctx, getState());
  enterRule(_localctx, 64, HplsqlParser::RuleDeclare_temporary_table_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(830);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_GLOBAL) {
      setState(829);
      match(HplsqlParser::T_GLOBAL);
    }
    setState(832);
    match(HplsqlParser::T_TEMPORARY);
    setState(833);
    match(HplsqlParser::T_TABLE);
    setState(834);
    ident();
    setState(836);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_ROW

    || _la == HplsqlParser::T_STORED || _la == HplsqlParser::T_COMMA) {
      setState(835);
      create_table_preoptions();
    }
    setState(838);
    create_table_definition();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_stmtContext ------------------------------------------------------------------

HplsqlParser::Create_table_stmtContext::Create_table_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_table_stmtContext::T_CREATE() {
  return getToken(HplsqlParser::T_CREATE, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_stmtContext::T_TABLE() {
  return getToken(HplsqlParser::T_TABLE, 0);
}

HplsqlParser::Table_nameContext* HplsqlParser::Create_table_stmtContext::table_name() {
  return getRuleContext<HplsqlParser::Table_nameContext>(0);
}

HplsqlParser::Create_table_definitionContext* HplsqlParser::Create_table_stmtContext::create_table_definition() {
  return getRuleContext<HplsqlParser::Create_table_definitionContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_table_stmtContext::T_IF() {
  return getToken(HplsqlParser::T_IF, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_stmtContext::T_NOT() {
  return getToken(HplsqlParser::T_NOT, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_stmtContext::T_EXISTS() {
  return getToken(HplsqlParser::T_EXISTS, 0);
}

HplsqlParser::Create_table_preoptionsContext* HplsqlParser::Create_table_stmtContext::create_table_preoptions() {
  return getRuleContext<HplsqlParser::Create_table_preoptionsContext>(0);
}


size_t HplsqlParser::Create_table_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_table_stmt;
}

void HplsqlParser::Create_table_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_stmt(this);
}

void HplsqlParser::Create_table_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_stmt(this);
}


antlrcpp::Any HplsqlParser::Create_table_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_table_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_table_stmtContext* HplsqlParser::create_table_stmt() {
  Create_table_stmtContext *_localctx = _tracker.createInstance<Create_table_stmtContext>(_ctx, getState());
  enterRule(_localctx, 66, HplsqlParser::RuleCreate_table_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(840);
    match(HplsqlParser::T_CREATE);
    setState(841);
    match(HplsqlParser::T_TABLE);
    setState(845);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
    case 1: {
      setState(842);
      match(HplsqlParser::T_IF);
      setState(843);
      match(HplsqlParser::T_NOT);
      setState(844);
      match(HplsqlParser::T_EXISTS);
      break;
    }

    default:
      break;
    }
    setState(847);
    table_name();
    setState(849);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_ROW

    || _la == HplsqlParser::T_STORED || _la == HplsqlParser::T_COMMA) {
      setState(848);
      create_table_preoptions();
    }
    setState(851);
    create_table_definition();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_local_temp_table_stmtContext ------------------------------------------------------------------

HplsqlParser::Create_local_temp_table_stmtContext::Create_local_temp_table_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_local_temp_table_stmtContext::T_CREATE() {
  return getToken(HplsqlParser::T_CREATE, 0);
}

tree::TerminalNode* HplsqlParser::Create_local_temp_table_stmtContext::T_TABLE() {
  return getToken(HplsqlParser::T_TABLE, 0);
}

HplsqlParser::IdentContext* HplsqlParser::Create_local_temp_table_stmtContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

HplsqlParser::Create_table_definitionContext* HplsqlParser::Create_local_temp_table_stmtContext::create_table_definition() {
  return getRuleContext<HplsqlParser::Create_table_definitionContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_local_temp_table_stmtContext::T_LOCAL() {
  return getToken(HplsqlParser::T_LOCAL, 0);
}

tree::TerminalNode* HplsqlParser::Create_local_temp_table_stmtContext::T_TEMPORARY() {
  return getToken(HplsqlParser::T_TEMPORARY, 0);
}

tree::TerminalNode* HplsqlParser::Create_local_temp_table_stmtContext::T_VOLATILE() {
  return getToken(HplsqlParser::T_VOLATILE, 0);
}

HplsqlParser::Create_table_preoptionsContext* HplsqlParser::Create_local_temp_table_stmtContext::create_table_preoptions() {
  return getRuleContext<HplsqlParser::Create_table_preoptionsContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_local_temp_table_stmtContext::T_SET() {
  return getToken(HplsqlParser::T_SET, 0);
}

tree::TerminalNode* HplsqlParser::Create_local_temp_table_stmtContext::T_MULTISET() {
  return getToken(HplsqlParser::T_MULTISET, 0);
}


size_t HplsqlParser::Create_local_temp_table_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_local_temp_table_stmt;
}

void HplsqlParser::Create_local_temp_table_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_local_temp_table_stmt(this);
}

void HplsqlParser::Create_local_temp_table_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_local_temp_table_stmt(this);
}


antlrcpp::Any HplsqlParser::Create_local_temp_table_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_local_temp_table_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_local_temp_table_stmtContext* HplsqlParser::create_local_temp_table_stmt() {
  Create_local_temp_table_stmtContext *_localctx = _tracker.createInstance<Create_local_temp_table_stmtContext>(_ctx, getState());
  enterRule(_localctx, 68, HplsqlParser::RuleCreate_local_temp_table_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(853);
    match(HplsqlParser::T_CREATE);
    setState(860);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_LOCAL: {
        setState(854);
        match(HplsqlParser::T_LOCAL);
        setState(855);
        match(HplsqlParser::T_TEMPORARY);
        break;
      }

      case HplsqlParser::T_MULTISET:
      case HplsqlParser::T_SET:
      case HplsqlParser::T_VOLATILE: {
        setState(857);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_MULTISET || _la == HplsqlParser::T_SET) {
          setState(856);
          _la = _input->LA(1);
          if (!(_la == HplsqlParser::T_MULTISET || _la == HplsqlParser::T_SET)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(859);
        match(HplsqlParser::T_VOLATILE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(862);
    match(HplsqlParser::T_TABLE);
    setState(863);
    ident();
    setState(865);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_ROW

    || _la == HplsqlParser::T_STORED || _la == HplsqlParser::T_COMMA) {
      setState(864);
      create_table_preoptions();
    }
    setState(867);
    create_table_definition();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_definitionContext ------------------------------------------------------------------

HplsqlParser::Create_table_definitionContext::Create_table_definitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_table_definitionContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

HplsqlParser::Select_stmtContext* HplsqlParser::Create_table_definitionContext::select_stmt() {
  return getRuleContext<HplsqlParser::Select_stmtContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_table_definitionContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

HplsqlParser::Create_table_columnsContext* HplsqlParser::Create_table_definitionContext::create_table_columns() {
  return getRuleContext<HplsqlParser::Create_table_columnsContext>(0);
}

HplsqlParser::Create_table_optionsContext* HplsqlParser::Create_table_definitionContext::create_table_options() {
  return getRuleContext<HplsqlParser::Create_table_optionsContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_table_definitionContext::T_AS() {
  return getToken(HplsqlParser::T_AS, 0);
}


size_t HplsqlParser::Create_table_definitionContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_table_definition;
}

void HplsqlParser::Create_table_definitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_definition(this);
}

void HplsqlParser::Create_table_definitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_definition(this);
}


antlrcpp::Any HplsqlParser::Create_table_definitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_table_definition(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_table_definitionContext* HplsqlParser::create_table_definition() {
  Create_table_definitionContext *_localctx = _tracker.createInstance<Create_table_definitionContext>(_ctx, getState());
  enterRule(_localctx, 70, HplsqlParser::RuleCreate_table_definition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(884);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx)) {
    case 1: {
      setState(870);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HplsqlParser::T_AS) {
        setState(869);
        match(HplsqlParser::T_AS);
      }
      setState(872);
      match(HplsqlParser::T_OPEN_P);
      setState(873);
      select_stmt();
      setState(874);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 2: {
      setState(877);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HplsqlParser::T_AS) {
        setState(876);
        match(HplsqlParser::T_AS);
      }
      setState(879);
      select_stmt();
      break;
    }

    case 3: {
      setState(880);
      match(HplsqlParser::T_OPEN_P);
      setState(881);
      create_table_columns();
      setState(882);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    default:
      break;
    }
    setState(887);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx)) {
    case 1: {
      setState(886);
      create_table_options();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_columnsContext ------------------------------------------------------------------

HplsqlParser::Create_table_columnsContext::Create_table_columnsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HplsqlParser::Create_table_columns_itemContext *> HplsqlParser::Create_table_columnsContext::create_table_columns_item() {
  return getRuleContexts<HplsqlParser::Create_table_columns_itemContext>();
}

HplsqlParser::Create_table_columns_itemContext* HplsqlParser::Create_table_columnsContext::create_table_columns_item(size_t i) {
  return getRuleContext<HplsqlParser::Create_table_columns_itemContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Create_table_columnsContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Create_table_columnsContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Create_table_columnsContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_table_columns;
}

void HplsqlParser::Create_table_columnsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_columns(this);
}

void HplsqlParser::Create_table_columnsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_columns(this);
}


antlrcpp::Any HplsqlParser::Create_table_columnsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_table_columns(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_table_columnsContext* HplsqlParser::create_table_columns() {
  Create_table_columnsContext *_localctx = _tracker.createInstance<Create_table_columnsContext>(_ctx, getState());
  enterRule(_localctx, 72, HplsqlParser::RuleCreate_table_columns);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(889);
    create_table_columns_item();
    setState(894);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HplsqlParser::T_COMMA) {
      setState(890);
      match(HplsqlParser::T_COMMA);
      setState(891);
      create_table_columns_item();
      setState(896);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_columns_itemContext ------------------------------------------------------------------

HplsqlParser::Create_table_columns_itemContext::Create_table_columns_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Column_nameContext* HplsqlParser::Create_table_columns_itemContext::column_name() {
  return getRuleContext<HplsqlParser::Column_nameContext>(0);
}

HplsqlParser::DtypeContext* HplsqlParser::Create_table_columns_itemContext::dtype() {
  return getRuleContext<HplsqlParser::DtypeContext>(0);
}

HplsqlParser::Dtype_lenContext* HplsqlParser::Create_table_columns_itemContext::dtype_len() {
  return getRuleContext<HplsqlParser::Dtype_lenContext>(0);
}

std::vector<HplsqlParser::Dtype_attrContext *> HplsqlParser::Create_table_columns_itemContext::dtype_attr() {
  return getRuleContexts<HplsqlParser::Dtype_attrContext>();
}

HplsqlParser::Dtype_attrContext* HplsqlParser::Create_table_columns_itemContext::dtype_attr(size_t i) {
  return getRuleContext<HplsqlParser::Dtype_attrContext>(i);
}

std::vector<HplsqlParser::Create_table_column_inline_consContext *> HplsqlParser::Create_table_columns_itemContext::create_table_column_inline_cons() {
  return getRuleContexts<HplsqlParser::Create_table_column_inline_consContext>();
}

HplsqlParser::Create_table_column_inline_consContext* HplsqlParser::Create_table_columns_itemContext::create_table_column_inline_cons(size_t i) {
  return getRuleContext<HplsqlParser::Create_table_column_inline_consContext>(i);
}

HplsqlParser::Create_table_column_consContext* HplsqlParser::Create_table_columns_itemContext::create_table_column_cons() {
  return getRuleContext<HplsqlParser::Create_table_column_consContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_table_columns_itemContext::T_CONSTRAINT() {
  return getToken(HplsqlParser::T_CONSTRAINT, 0);
}

HplsqlParser::IdentContext* HplsqlParser::Create_table_columns_itemContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}


size_t HplsqlParser::Create_table_columns_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_table_columns_item;
}

void HplsqlParser::Create_table_columns_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_columns_item(this);
}

void HplsqlParser::Create_table_columns_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_columns_item(this);
}


antlrcpp::Any HplsqlParser::Create_table_columns_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_table_columns_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_table_columns_itemContext* HplsqlParser::create_table_columns_item() {
  Create_table_columns_itemContext *_localctx = _tracker.createInstance<Create_table_columns_itemContext>(_ctx, getState());
  enterRule(_localctx, 74, HplsqlParser::RuleCreate_table_columns_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(919);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(897);
      column_name();
      setState(898);
      dtype();
      setState(900);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HplsqlParser::T_OPEN_P) {
        setState(899);
        dtype_len();
      }
      setState(905);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(902);
          dtype_attr(); 
        }
        setState(907);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx);
      }
      setState(911);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == HplsqlParser::T_AUTO_INCREMENT || ((((_la - 75) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 75)) & ((1ULL << (HplsqlParser::T_DEFAULT - 75))
        | (1ULL << (HplsqlParser::T_ENABLE - 75))
        | (1ULL << (HplsqlParser::T_IDENTITY - 75)))) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & ((1ULL << (HplsqlParser::T_NOT - 193))
        | (1ULL << (HplsqlParser::T_NULL - 193))
        | (1ULL << (HplsqlParser::T_PRIMARY - 193))
        | (1ULL << (HplsqlParser::T_REFERENCES - 193)))) != 0) || ((((_la - 298) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 298)) & ((1ULL << (HplsqlParser::T_UNIQUE - 298))
        | (1ULL << (HplsqlParser::T_WITH - 298))
        | (1ULL << (HplsqlParser::T_COLON - 298))
        | (1ULL << (HplsqlParser::T_EQUAL - 298)))) != 0)) {
        setState(908);
        create_table_column_inline_cons();
        setState(913);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(916);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HplsqlParser::T_CONSTRAINT) {
        setState(914);
        match(HplsqlParser::T_CONSTRAINT);
        setState(915);
        ident();
      }
      setState(918);
      create_table_column_cons();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_nameContext ------------------------------------------------------------------

HplsqlParser::Column_nameContext::Column_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::IdentContext* HplsqlParser::Column_nameContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}


size_t HplsqlParser::Column_nameContext::getRuleIndex() const {
  return HplsqlParser::RuleColumn_name;
}

void HplsqlParser::Column_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_name(this);
}

void HplsqlParser::Column_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_name(this);
}


antlrcpp::Any HplsqlParser::Column_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitColumn_name(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Column_nameContext* HplsqlParser::column_name() {
  Column_nameContext *_localctx = _tracker.createInstance<Column_nameContext>(_ctx, getState());
  enterRule(_localctx, 76, HplsqlParser::RuleColumn_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(921);
    ident();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_column_inline_consContext ------------------------------------------------------------------

HplsqlParser::Create_table_column_inline_consContext::Create_table_column_inline_consContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Dtype_defaultContext* HplsqlParser::Create_table_column_inline_consContext::dtype_default() {
  return getRuleContext<HplsqlParser::Dtype_defaultContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_table_column_inline_consContext::T_NULL() {
  return getToken(HplsqlParser::T_NULL, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_column_inline_consContext::T_NOT() {
  return getToken(HplsqlParser::T_NOT, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_column_inline_consContext::T_PRIMARY() {
  return getToken(HplsqlParser::T_PRIMARY, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_column_inline_consContext::T_KEY() {
  return getToken(HplsqlParser::T_KEY, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_column_inline_consContext::T_UNIQUE() {
  return getToken(HplsqlParser::T_UNIQUE, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_column_inline_consContext::T_REFERENCES() {
  return getToken(HplsqlParser::T_REFERENCES, 0);
}

HplsqlParser::Table_nameContext* HplsqlParser::Create_table_column_inline_consContext::table_name() {
  return getRuleContext<HplsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_table_column_inline_consContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

HplsqlParser::IdentContext* HplsqlParser::Create_table_column_inline_consContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_table_column_inline_consContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

std::vector<HplsqlParser::Create_table_fk_actionContext *> HplsqlParser::Create_table_column_inline_consContext::create_table_fk_action() {
  return getRuleContexts<HplsqlParser::Create_table_fk_actionContext>();
}

HplsqlParser::Create_table_fk_actionContext* HplsqlParser::Create_table_column_inline_consContext::create_table_fk_action(size_t i) {
  return getRuleContext<HplsqlParser::Create_table_fk_actionContext>(i);
}

tree::TerminalNode* HplsqlParser::Create_table_column_inline_consContext::T_IDENTITY() {
  return getToken(HplsqlParser::T_IDENTITY, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Create_table_column_inline_consContext::L_INT() {
  return getTokens(HplsqlParser::L_INT);
}

tree::TerminalNode* HplsqlParser::Create_table_column_inline_consContext::L_INT(size_t i) {
  return getToken(HplsqlParser::L_INT, i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Create_table_column_inline_consContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Create_table_column_inline_consContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}

tree::TerminalNode* HplsqlParser::Create_table_column_inline_consContext::T_AUTO_INCREMENT() {
  return getToken(HplsqlParser::T_AUTO_INCREMENT, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_column_inline_consContext::T_ENABLE() {
  return getToken(HplsqlParser::T_ENABLE, 0);
}


size_t HplsqlParser::Create_table_column_inline_consContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_table_column_inline_cons;
}

void HplsqlParser::Create_table_column_inline_consContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_column_inline_cons(this);
}

void HplsqlParser::Create_table_column_inline_consContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_column_inline_cons(this);
}


antlrcpp::Any HplsqlParser::Create_table_column_inline_consContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_table_column_inline_cons(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_table_column_inline_consContext* HplsqlParser::create_table_column_inline_cons() {
  Create_table_column_inline_consContext *_localctx = _tracker.createInstance<Create_table_column_inline_consContext>(_ctx, getState());
  enterRule(_localctx, 78, HplsqlParser::RuleCreate_table_column_inline_cons);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(955);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_DEFAULT:
      case HplsqlParser::T_WITH:
      case HplsqlParser::T_COLON:
      case HplsqlParser::T_EQUAL: {
        enterOuterAlt(_localctx, 1);
        setState(923);
        dtype_default();
        break;
      }

      case HplsqlParser::T_NOT:
      case HplsqlParser::T_NULL: {
        enterOuterAlt(_localctx, 2);
        setState(925);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_NOT) {
          setState(924);
          match(HplsqlParser::T_NOT);
        }
        setState(927);
        match(HplsqlParser::T_NULL);
        break;
      }

      case HplsqlParser::T_PRIMARY: {
        enterOuterAlt(_localctx, 3);
        setState(928);
        match(HplsqlParser::T_PRIMARY);
        setState(929);
        match(HplsqlParser::T_KEY);
        break;
      }

      case HplsqlParser::T_UNIQUE: {
        enterOuterAlt(_localctx, 4);
        setState(930);
        match(HplsqlParser::T_UNIQUE);
        break;
      }

      case HplsqlParser::T_REFERENCES: {
        enterOuterAlt(_localctx, 5);
        setState(931);
        match(HplsqlParser::T_REFERENCES);
        setState(932);
        table_name();
        setState(933);
        match(HplsqlParser::T_OPEN_P);
        setState(934);
        ident();
        setState(935);
        match(HplsqlParser::T_CLOSE_P);
        setState(939);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == HplsqlParser::T_ON) {
          setState(936);
          create_table_fk_action();
          setState(941);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case HplsqlParser::T_IDENTITY: {
        enterOuterAlt(_localctx, 6);
        setState(942);
        match(HplsqlParser::T_IDENTITY);
        setState(943);
        match(HplsqlParser::T_OPEN_P);
        setState(944);
        match(HplsqlParser::L_INT);
        setState(949);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == HplsqlParser::T_COMMA) {
          setState(945);
          match(HplsqlParser::T_COMMA);
          setState(946);
          match(HplsqlParser::L_INT);
          setState(951);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(952);
        match(HplsqlParser::T_CLOSE_P);
        break;
      }

      case HplsqlParser::T_AUTO_INCREMENT: {
        enterOuterAlt(_localctx, 7);
        setState(953);
        match(HplsqlParser::T_AUTO_INCREMENT);
        break;
      }

      case HplsqlParser::T_ENABLE: {
        enterOuterAlt(_localctx, 8);
        setState(954);
        match(HplsqlParser::T_ENABLE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_column_consContext ------------------------------------------------------------------

HplsqlParser::Create_table_column_consContext::Create_table_column_consContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_table_column_consContext::T_PRIMARY() {
  return getToken(HplsqlParser::T_PRIMARY, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_column_consContext::T_KEY() {
  return getToken(HplsqlParser::T_KEY, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Create_table_column_consContext::T_OPEN_P() {
  return getTokens(HplsqlParser::T_OPEN_P);
}

tree::TerminalNode* HplsqlParser::Create_table_column_consContext::T_OPEN_P(size_t i) {
  return getToken(HplsqlParser::T_OPEN_P, i);
}

std::vector<HplsqlParser::IdentContext *> HplsqlParser::Create_table_column_consContext::ident() {
  return getRuleContexts<HplsqlParser::IdentContext>();
}

HplsqlParser::IdentContext* HplsqlParser::Create_table_column_consContext::ident(size_t i) {
  return getRuleContext<HplsqlParser::IdentContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Create_table_column_consContext::T_CLOSE_P() {
  return getTokens(HplsqlParser::T_CLOSE_P);
}

tree::TerminalNode* HplsqlParser::Create_table_column_consContext::T_CLOSE_P(size_t i) {
  return getToken(HplsqlParser::T_CLOSE_P, i);
}

tree::TerminalNode* HplsqlParser::Create_table_column_consContext::T_CLUSTERED() {
  return getToken(HplsqlParser::T_CLUSTERED, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Create_table_column_consContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Create_table_column_consContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}

tree::TerminalNode* HplsqlParser::Create_table_column_consContext::T_ENABLE() {
  return getToken(HplsqlParser::T_ENABLE, 0);
}

HplsqlParser::Index_storage_clauseContext* HplsqlParser::Create_table_column_consContext::index_storage_clause() {
  return getRuleContext<HplsqlParser::Index_storage_clauseContext>(0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Create_table_column_consContext::T_ASC() {
  return getTokens(HplsqlParser::T_ASC);
}

tree::TerminalNode* HplsqlParser::Create_table_column_consContext::T_ASC(size_t i) {
  return getToken(HplsqlParser::T_ASC, i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Create_table_column_consContext::T_DESC() {
  return getTokens(HplsqlParser::T_DESC);
}

tree::TerminalNode* HplsqlParser::Create_table_column_consContext::T_DESC(size_t i) {
  return getToken(HplsqlParser::T_DESC, i);
}

tree::TerminalNode* HplsqlParser::Create_table_column_consContext::T_FOREIGN() {
  return getToken(HplsqlParser::T_FOREIGN, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_column_consContext::T_REFERENCES() {
  return getToken(HplsqlParser::T_REFERENCES, 0);
}

HplsqlParser::Table_nameContext* HplsqlParser::Create_table_column_consContext::table_name() {
  return getRuleContext<HplsqlParser::Table_nameContext>(0);
}

std::vector<HplsqlParser::Create_table_fk_actionContext *> HplsqlParser::Create_table_column_consContext::create_table_fk_action() {
  return getRuleContexts<HplsqlParser::Create_table_fk_actionContext>();
}

HplsqlParser::Create_table_fk_actionContext* HplsqlParser::Create_table_column_consContext::create_table_fk_action(size_t i) {
  return getRuleContext<HplsqlParser::Create_table_fk_actionContext>(i);
}


size_t HplsqlParser::Create_table_column_consContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_table_column_cons;
}

void HplsqlParser::Create_table_column_consContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_column_cons(this);
}

void HplsqlParser::Create_table_column_consContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_column_cons(this);
}


antlrcpp::Any HplsqlParser::Create_table_column_consContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_table_column_cons(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_table_column_consContext* HplsqlParser::create_table_column_cons() {
  Create_table_column_consContext *_localctx = _tracker.createInstance<Create_table_column_consContext>(_ctx, getState());
  enterRule(_localctx, 80, HplsqlParser::RuleCreate_table_column_cons);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1014);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_PRIMARY: {
        enterOuterAlt(_localctx, 1);
        setState(957);
        match(HplsqlParser::T_PRIMARY);
        setState(958);
        match(HplsqlParser::T_KEY);
        setState(960);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_CLUSTERED) {
          setState(959);
          match(HplsqlParser::T_CLUSTERED);
        }
        setState(962);
        match(HplsqlParser::T_OPEN_P);
        setState(963);
        ident();
        setState(965);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_ASC || _la == HplsqlParser::T_DESC) {
          setState(964);
          _la = _input->LA(1);
          if (!(_la == HplsqlParser::T_ASC || _la == HplsqlParser::T_DESC)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(974);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == HplsqlParser::T_COMMA) {
          setState(967);
          match(HplsqlParser::T_COMMA);
          setState(968);
          ident();
          setState(970);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == HplsqlParser::T_ASC || _la == HplsqlParser::T_DESC) {
            setState(969);
            _la = _input->LA(1);
            if (!(_la == HplsqlParser::T_ASC || _la == HplsqlParser::T_DESC)) {
            _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
          }
          setState(976);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(977);
        match(HplsqlParser::T_CLOSE_P);
        setState(979);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_ENABLE) {
          setState(978);
          match(HplsqlParser::T_ENABLE);
        }
        setState(982);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_WITH) {
          setState(981);
          index_storage_clause();
        }
        break;
      }

      case HplsqlParser::T_FOREIGN: {
        enterOuterAlt(_localctx, 2);
        setState(984);
        match(HplsqlParser::T_FOREIGN);
        setState(985);
        match(HplsqlParser::T_KEY);
        setState(986);
        match(HplsqlParser::T_OPEN_P);
        setState(987);
        ident();
        setState(992);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == HplsqlParser::T_COMMA) {
          setState(988);
          match(HplsqlParser::T_COMMA);
          setState(989);
          ident();
          setState(994);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(995);
        match(HplsqlParser::T_CLOSE_P);
        setState(996);
        match(HplsqlParser::T_REFERENCES);
        setState(997);
        table_name();
        setState(998);
        match(HplsqlParser::T_OPEN_P);
        setState(999);
        ident();
        setState(1004);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == HplsqlParser::T_COMMA) {
          setState(1000);
          match(HplsqlParser::T_COMMA);
          setState(1001);
          ident();
          setState(1006);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1007);
        match(HplsqlParser::T_CLOSE_P);
        setState(1011);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == HplsqlParser::T_ON) {
          setState(1008);
          create_table_fk_action();
          setState(1013);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_fk_actionContext ------------------------------------------------------------------

HplsqlParser::Create_table_fk_actionContext::Create_table_fk_actionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_table_fk_actionContext::T_ON() {
  return getToken(HplsqlParser::T_ON, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_fk_actionContext::T_UPDATE() {
  return getToken(HplsqlParser::T_UPDATE, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_fk_actionContext::T_DELETE() {
  return getToken(HplsqlParser::T_DELETE, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_fk_actionContext::T_NO() {
  return getToken(HplsqlParser::T_NO, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_fk_actionContext::T_ACTION() {
  return getToken(HplsqlParser::T_ACTION, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_fk_actionContext::T_RESTRICT() {
  return getToken(HplsqlParser::T_RESTRICT, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_fk_actionContext::T_SET() {
  return getToken(HplsqlParser::T_SET, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_fk_actionContext::T_NULL() {
  return getToken(HplsqlParser::T_NULL, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_fk_actionContext::T_DEFAULT() {
  return getToken(HplsqlParser::T_DEFAULT, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_fk_actionContext::T_CASCADE() {
  return getToken(HplsqlParser::T_CASCADE, 0);
}


size_t HplsqlParser::Create_table_fk_actionContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_table_fk_action;
}

void HplsqlParser::Create_table_fk_actionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_fk_action(this);
}

void HplsqlParser::Create_table_fk_actionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_fk_action(this);
}


antlrcpp::Any HplsqlParser::Create_table_fk_actionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_table_fk_action(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_table_fk_actionContext* HplsqlParser::create_table_fk_action() {
  Create_table_fk_actionContext *_localctx = _tracker.createInstance<Create_table_fk_actionContext>(_ctx, getState());
  enterRule(_localctx, 82, HplsqlParser::RuleCreate_table_fk_action);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1016);
    match(HplsqlParser::T_ON);
    setState(1017);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_DELETE || _la == HplsqlParser::T_UPDATE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1026);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx)) {
    case 1: {
      setState(1018);
      match(HplsqlParser::T_NO);
      setState(1019);
      match(HplsqlParser::T_ACTION);
      break;
    }

    case 2: {
      setState(1020);
      match(HplsqlParser::T_RESTRICT);
      break;
    }

    case 3: {
      setState(1021);
      match(HplsqlParser::T_SET);
      setState(1022);
      match(HplsqlParser::T_NULL);
      break;
    }

    case 4: {
      setState(1023);
      match(HplsqlParser::T_SET);
      setState(1024);
      match(HplsqlParser::T_DEFAULT);
      break;
    }

    case 5: {
      setState(1025);
      match(HplsqlParser::T_CASCADE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_preoptionsContext ------------------------------------------------------------------

HplsqlParser::Create_table_preoptionsContext::Create_table_preoptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HplsqlParser::Create_table_preoptions_itemContext *> HplsqlParser::Create_table_preoptionsContext::create_table_preoptions_item() {
  return getRuleContexts<HplsqlParser::Create_table_preoptions_itemContext>();
}

HplsqlParser::Create_table_preoptions_itemContext* HplsqlParser::Create_table_preoptionsContext::create_table_preoptions_item(size_t i) {
  return getRuleContext<HplsqlParser::Create_table_preoptions_itemContext>(i);
}


size_t HplsqlParser::Create_table_preoptionsContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_table_preoptions;
}

void HplsqlParser::Create_table_preoptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_preoptions(this);
}

void HplsqlParser::Create_table_preoptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_preoptions(this);
}


antlrcpp::Any HplsqlParser::Create_table_preoptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_table_preoptions(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_table_preoptionsContext* HplsqlParser::create_table_preoptions() {
  Create_table_preoptionsContext *_localctx = _tracker.createInstance<Create_table_preoptionsContext>(_ctx, getState());
  enterRule(_localctx, 84, HplsqlParser::RuleCreate_table_preoptions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1029); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1028);
      create_table_preoptions_item();
      setState(1031); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == HplsqlParser::T_ROW

    || _la == HplsqlParser::T_STORED || _la == HplsqlParser::T_COMMA);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_preoptions_itemContext ------------------------------------------------------------------

HplsqlParser::Create_table_preoptions_itemContext::Create_table_preoptions_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_table_preoptions_itemContext::T_COMMA() {
  return getToken(HplsqlParser::T_COMMA, 0);
}

HplsqlParser::Create_table_preoptions_td_itemContext* HplsqlParser::Create_table_preoptions_itemContext::create_table_preoptions_td_item() {
  return getRuleContext<HplsqlParser::Create_table_preoptions_td_itemContext>(0);
}

HplsqlParser::Create_table_options_hive_itemContext* HplsqlParser::Create_table_preoptions_itemContext::create_table_options_hive_item() {
  return getRuleContext<HplsqlParser::Create_table_options_hive_itemContext>(0);
}


size_t HplsqlParser::Create_table_preoptions_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_table_preoptions_item;
}

void HplsqlParser::Create_table_preoptions_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_preoptions_item(this);
}

void HplsqlParser::Create_table_preoptions_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_preoptions_item(this);
}


antlrcpp::Any HplsqlParser::Create_table_preoptions_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_table_preoptions_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_table_preoptions_itemContext* HplsqlParser::create_table_preoptions_item() {
  Create_table_preoptions_itemContext *_localctx = _tracker.createInstance<Create_table_preoptions_itemContext>(_ctx, getState());
  enterRule(_localctx, 86, HplsqlParser::RuleCreate_table_preoptions_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1036);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_COMMA: {
        enterOuterAlt(_localctx, 1);
        setState(1033);
        match(HplsqlParser::T_COMMA);
        setState(1034);
        create_table_preoptions_td_item();
        break;
      }

      case HplsqlParser::T_ROW:
      case HplsqlParser::T_STORED: {
        enterOuterAlt(_localctx, 2);
        setState(1035);
        create_table_options_hive_item();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_preoptions_td_itemContext ------------------------------------------------------------------

HplsqlParser::Create_table_preoptions_td_itemContext::Create_table_preoptions_td_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_table_preoptions_td_itemContext::T_LOG() {
  return getToken(HplsqlParser::T_LOG, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_preoptions_td_itemContext::T_FALLBACK() {
  return getToken(HplsqlParser::T_FALLBACK, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_preoptions_td_itemContext::T_NO() {
  return getToken(HplsqlParser::T_NO, 0);
}


size_t HplsqlParser::Create_table_preoptions_td_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_table_preoptions_td_item;
}

void HplsqlParser::Create_table_preoptions_td_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_preoptions_td_item(this);
}

void HplsqlParser::Create_table_preoptions_td_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_preoptions_td_item(this);
}


antlrcpp::Any HplsqlParser::Create_table_preoptions_td_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_table_preoptions_td_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_table_preoptions_td_itemContext* HplsqlParser::create_table_preoptions_td_item() {
  Create_table_preoptions_td_itemContext *_localctx = _tracker.createInstance<Create_table_preoptions_td_itemContext>(_ctx, getState());
  enterRule(_localctx, 88, HplsqlParser::RuleCreate_table_preoptions_td_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1039);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_NO) {
      setState(1038);
      match(HplsqlParser::T_NO);
    }
    setState(1041);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_FALLBACK

    || _la == HplsqlParser::T_LOG)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_optionsContext ------------------------------------------------------------------

HplsqlParser::Create_table_optionsContext::Create_table_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HplsqlParser::Create_table_options_itemContext *> HplsqlParser::Create_table_optionsContext::create_table_options_item() {
  return getRuleContexts<HplsqlParser::Create_table_options_itemContext>();
}

HplsqlParser::Create_table_options_itemContext* HplsqlParser::Create_table_optionsContext::create_table_options_item(size_t i) {
  return getRuleContext<HplsqlParser::Create_table_options_itemContext>(i);
}


size_t HplsqlParser::Create_table_optionsContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_table_options;
}

void HplsqlParser::Create_table_optionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_options(this);
}

void HplsqlParser::Create_table_optionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_options(this);
}


antlrcpp::Any HplsqlParser::Create_table_optionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_table_options(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_table_optionsContext* HplsqlParser::create_table_options() {
  Create_table_optionsContext *_localctx = _tracker.createInstance<Create_table_optionsContext>(_ctx, getState());
  enterRule(_localctx, 90, HplsqlParser::RuleCreate_table_options);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1044); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1043);
              create_table_options_item();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1046); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_options_itemContext ------------------------------------------------------------------

HplsqlParser::Create_table_options_itemContext::Create_table_options_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_table_options_itemContext::T_ON() {
  return getToken(HplsqlParser::T_ON, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_itemContext::T_COMMIT() {
  return getToken(HplsqlParser::T_COMMIT, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_itemContext::T_ROWS() {
  return getToken(HplsqlParser::T_ROWS, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_itemContext::T_DELETE() {
  return getToken(HplsqlParser::T_DELETE, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_itemContext::T_PRESERVE() {
  return getToken(HplsqlParser::T_PRESERVE, 0);
}

HplsqlParser::Create_table_options_ora_itemContext* HplsqlParser::Create_table_options_itemContext::create_table_options_ora_item() {
  return getRuleContext<HplsqlParser::Create_table_options_ora_itemContext>(0);
}

HplsqlParser::Create_table_options_db2_itemContext* HplsqlParser::Create_table_options_itemContext::create_table_options_db2_item() {
  return getRuleContext<HplsqlParser::Create_table_options_db2_itemContext>(0);
}

HplsqlParser::Create_table_options_td_itemContext* HplsqlParser::Create_table_options_itemContext::create_table_options_td_item() {
  return getRuleContext<HplsqlParser::Create_table_options_td_itemContext>(0);
}

HplsqlParser::Create_table_options_hive_itemContext* HplsqlParser::Create_table_options_itemContext::create_table_options_hive_item() {
  return getRuleContext<HplsqlParser::Create_table_options_hive_itemContext>(0);
}

HplsqlParser::Create_table_options_mssql_itemContext* HplsqlParser::Create_table_options_itemContext::create_table_options_mssql_item() {
  return getRuleContext<HplsqlParser::Create_table_options_mssql_itemContext>(0);
}

HplsqlParser::Create_table_options_mysql_itemContext* HplsqlParser::Create_table_options_itemContext::create_table_options_mysql_item() {
  return getRuleContext<HplsqlParser::Create_table_options_mysql_itemContext>(0);
}


size_t HplsqlParser::Create_table_options_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_table_options_item;
}

void HplsqlParser::Create_table_options_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_options_item(this);
}

void HplsqlParser::Create_table_options_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_options_item(this);
}


antlrcpp::Any HplsqlParser::Create_table_options_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_table_options_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_table_options_itemContext* HplsqlParser::create_table_options_item() {
  Create_table_options_itemContext *_localctx = _tracker.createInstance<Create_table_options_itemContext>(_ctx, getState());
  enterRule(_localctx, 92, HplsqlParser::RuleCreate_table_options_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1058);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1048);
      match(HplsqlParser::T_ON);
      setState(1049);
      match(HplsqlParser::T_COMMIT);
      setState(1050);
      _la = _input->LA(1);
      if (!(_la == HplsqlParser::T_DELETE || _la == HplsqlParser::T_PRESERVE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1051);
      match(HplsqlParser::T_ROWS);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1052);
      create_table_options_ora_item();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1053);
      create_table_options_db2_item();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1054);
      create_table_options_td_item();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1055);
      create_table_options_hive_item();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1056);
      create_table_options_mssql_item();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1057);
      create_table_options_mysql_item();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_options_ora_itemContext ------------------------------------------------------------------

HplsqlParser::Create_table_options_ora_itemContext::Create_table_options_ora_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_table_options_ora_itemContext::T_SEGMENT() {
  return getToken(HplsqlParser::T_SEGMENT, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_ora_itemContext::T_CREATION() {
  return getToken(HplsqlParser::T_CREATION, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_ora_itemContext::T_IMMEDIATE() {
  return getToken(HplsqlParser::T_IMMEDIATE, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_ora_itemContext::T_DEFERRED() {
  return getToken(HplsqlParser::T_DEFERRED, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Create_table_options_ora_itemContext::L_INT() {
  return getTokens(HplsqlParser::L_INT);
}

tree::TerminalNode* HplsqlParser::Create_table_options_ora_itemContext::L_INT(size_t i) {
  return getToken(HplsqlParser::L_INT, i);
}

tree::TerminalNode* HplsqlParser::Create_table_options_ora_itemContext::T_PCTFREE() {
  return getToken(HplsqlParser::T_PCTFREE, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_ora_itemContext::T_PCTUSED() {
  return getToken(HplsqlParser::T_PCTUSED, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_ora_itemContext::T_INITRANS() {
  return getToken(HplsqlParser::T_INITRANS, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_ora_itemContext::T_MAXTRANS() {
  return getToken(HplsqlParser::T_MAXTRANS, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_ora_itemContext::T_NOCOMPRESS() {
  return getToken(HplsqlParser::T_NOCOMPRESS, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_ora_itemContext::T_LOGGING() {
  return getToken(HplsqlParser::T_LOGGING, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_ora_itemContext::T_NOLOGGING() {
  return getToken(HplsqlParser::T_NOLOGGING, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_ora_itemContext::T_STORAGE() {
  return getToken(HplsqlParser::T_STORAGE, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_ora_itemContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_ora_itemContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

std::vector<HplsqlParser::IdentContext *> HplsqlParser::Create_table_options_ora_itemContext::ident() {
  return getRuleContexts<HplsqlParser::IdentContext>();
}

HplsqlParser::IdentContext* HplsqlParser::Create_table_options_ora_itemContext::ident(size_t i) {
  return getRuleContext<HplsqlParser::IdentContext>(i);
}

tree::TerminalNode* HplsqlParser::Create_table_options_ora_itemContext::T_TABLESPACE() {
  return getToken(HplsqlParser::T_TABLESPACE, 0);
}


size_t HplsqlParser::Create_table_options_ora_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_table_options_ora_item;
}

void HplsqlParser::Create_table_options_ora_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_options_ora_item(this);
}

void HplsqlParser::Create_table_options_ora_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_options_ora_item(this);
}


antlrcpp::Any HplsqlParser::Create_table_options_ora_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_table_options_ora_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_table_options_ora_itemContext* HplsqlParser::create_table_options_ora_item() {
  Create_table_options_ora_itemContext *_localctx = _tracker.createInstance<Create_table_options_ora_itemContext>(_ctx, getState());
  enterRule(_localctx, 94, HplsqlParser::RuleCreate_table_options_ora_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1078);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_SEGMENT: {
        enterOuterAlt(_localctx, 1);
        setState(1060);
        match(HplsqlParser::T_SEGMENT);
        setState(1061);
        match(HplsqlParser::T_CREATION);
        setState(1062);
        _la = _input->LA(1);
        if (!(_la == HplsqlParser::T_DEFERRED

        || _la == HplsqlParser::T_IMMEDIATE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case HplsqlParser::T_INITRANS:
      case HplsqlParser::T_MAXTRANS:
      case HplsqlParser::T_PCTFREE:
      case HplsqlParser::T_PCTUSED: {
        enterOuterAlt(_localctx, 2);
        setState(1063);
        _la = _input->LA(1);
        if (!(_la == HplsqlParser::T_INITRANS

        || _la == HplsqlParser::T_MAXTRANS || _la == HplsqlParser::T_PCTFREE

        || _la == HplsqlParser::T_PCTUSED)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1064);
        match(HplsqlParser::L_INT);
        break;
      }

      case HplsqlParser::T_NOCOMPRESS: {
        enterOuterAlt(_localctx, 3);
        setState(1065);
        match(HplsqlParser::T_NOCOMPRESS);
        break;
      }

      case HplsqlParser::T_LOGGING:
      case HplsqlParser::T_NOLOGGING: {
        enterOuterAlt(_localctx, 4);
        setState(1066);
        _la = _input->LA(1);
        if (!(_la == HplsqlParser::T_LOGGING

        || _la == HplsqlParser::T_NOLOGGING)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case HplsqlParser::T_STORAGE: {
        enterOuterAlt(_localctx, 5);
        setState(1067);
        match(HplsqlParser::T_STORAGE);
        setState(1068);
        match(HplsqlParser::T_OPEN_P);
        setState(1071); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(1071);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case HplsqlParser::T_ACTION:
            case HplsqlParser::T_ADD2:
            case HplsqlParser::T_ALL:
            case HplsqlParser::T_ALLOCATE:
            case HplsqlParser::T_ALTER:
            case HplsqlParser::T_AND:
            case HplsqlParser::T_ANSI_NULLS:
            case HplsqlParser::T_ANSI_PADDING:
            case HplsqlParser::T_AS:
            case HplsqlParser::T_ASC:
            case HplsqlParser::T_ASSOCIATE:
            case HplsqlParser::T_AT:
            case HplsqlParser::T_AUTO_INCREMENT:
            case HplsqlParser::T_AVG:
            case HplsqlParser::T_BATCHSIZE:
            case HplsqlParser::T_BEGIN:
            case HplsqlParser::T_BETWEEN:
            case HplsqlParser::T_BIGINT:
            case HplsqlParser::T_BINARY_DOUBLE:
            case HplsqlParser::T_BINARY_FLOAT:
            case HplsqlParser::T_BIT:
            case HplsqlParser::T_BODY:
            case HplsqlParser::T_BREAK:
            case HplsqlParser::T_BY:
            case HplsqlParser::T_BYTE:
            case HplsqlParser::T_CALL:
            case HplsqlParser::T_CALLER:
            case HplsqlParser::T_CASCADE:
            case HplsqlParser::T_CASE:
            case HplsqlParser::T_CASESPECIFIC:
            case HplsqlParser::T_CAST:
            case HplsqlParser::T_CHAR:
            case HplsqlParser::T_CHARACTER:
            case HplsqlParser::T_CHARSET:
            case HplsqlParser::T_CLIENT:
            case HplsqlParser::T_CLOSE:
            case HplsqlParser::T_CLUSTERED:
            case HplsqlParser::T_CMP:
            case HplsqlParser::T_COLLECT:
            case HplsqlParser::T_COLLECTION:
            case HplsqlParser::T_COLUMN:
            case HplsqlParser::T_COMMENT:
            case HplsqlParser::T_CONSTANT:
            case HplsqlParser::T_COMMIT:
            case HplsqlParser::T_COMPRESS:
            case HplsqlParser::T_CONCAT:
            case HplsqlParser::T_CONDITION:
            case HplsqlParser::T_CONSTRAINT:
            case HplsqlParser::T_CONTINUE:
            case HplsqlParser::T_COPY:
            case HplsqlParser::T_COUNT:
            case HplsqlParser::T_COUNT_BIG:
            case HplsqlParser::T_CREATE:
            case HplsqlParser::T_CREATION:
            case HplsqlParser::T_CREATOR:
            case HplsqlParser::T_CS:
            case HplsqlParser::T_CURRENT:
            case HplsqlParser::T_CURRENT_SCHEMA:
            case HplsqlParser::T_CURSOR:
            case HplsqlParser::T_DATABASE:
            case HplsqlParser::T_DATA:
            case HplsqlParser::T_DATE:
            case HplsqlParser::T_DATETIME:
            case HplsqlParser::T_DAY:
            case HplsqlParser::T_DAYS:
            case HplsqlParser::T_DEC:
            case HplsqlParser::T_DECIMAL:
            case HplsqlParser::T_DECLARE:
            case HplsqlParser::T_DEFAULT:
            case HplsqlParser::T_DEFERRED:
            case HplsqlParser::T_DEFINED:
            case HplsqlParser::T_DEFINER:
            case HplsqlParser::T_DEFINITION:
            case HplsqlParser::T_DELETE:
            case HplsqlParser::T_DELIMITED:
            case HplsqlParser::T_DELIMITER:
            case HplsqlParser::T_DESC:
            case HplsqlParser::T_DESCRIBE:
            case HplsqlParser::T_DIAGNOSTICS:
            case HplsqlParser::T_DIR:
            case HplsqlParser::T_DIRECTORY:
            case HplsqlParser::T_DISTINCT:
            case HplsqlParser::T_DISTRIBUTE:
            case HplsqlParser::T_DO:
            case HplsqlParser::T_DOUBLE:
            case HplsqlParser::T_DROP:
            case HplsqlParser::T_DYNAMIC:
            case HplsqlParser::T_ENABLE:
            case HplsqlParser::T_ENGINE:
            case HplsqlParser::T_ESCAPED:
            case HplsqlParser::T_EXCEPT:
            case HplsqlParser::T_EXEC:
            case HplsqlParser::T_EXECUTE:
            case HplsqlParser::T_EXCEPTION:
            case HplsqlParser::T_EXCLUSIVE:
            case HplsqlParser::T_EXISTS:
            case HplsqlParser::T_EXIT:
            case HplsqlParser::T_FALLBACK:
            case HplsqlParser::T_FALSE:
            case HplsqlParser::T_FETCH:
            case HplsqlParser::T_FIELDS:
            case HplsqlParser::T_FILE:
            case HplsqlParser::T_FILES:
            case HplsqlParser::T_FLOAT:
            case HplsqlParser::T_FOR:
            case HplsqlParser::T_FOREIGN:
            case HplsqlParser::T_FORMAT:
            case HplsqlParser::T_FOUND:
            case HplsqlParser::T_FROM:
            case HplsqlParser::T_FULL:
            case HplsqlParser::T_FUNCTION:
            case HplsqlParser::T_GET:
            case HplsqlParser::T_GLOBAL:
            case HplsqlParser::T_GO:
            case HplsqlParser::T_GRANT:
            case HplsqlParser::T_GROUP:
            case HplsqlParser::T_HANDLER:
            case HplsqlParser::T_HASH:
            case HplsqlParser::T_HAVING:
            case HplsqlParser::T_HDFS:
            case HplsqlParser::T_HIVE:
            case HplsqlParser::T_HOST:
            case HplsqlParser::T_IDENTITY:
            case HplsqlParser::T_IF:
            case HplsqlParser::T_IGNORE:
            case HplsqlParser::T_IMMEDIATE:
            case HplsqlParser::T_IN:
            case HplsqlParser::T_INCLUDE:
            case HplsqlParser::T_INDEX:
            case HplsqlParser::T_INITRANS:
            case HplsqlParser::T_INNER:
            case HplsqlParser::T_INOUT:
            case HplsqlParser::T_INSERT:
            case HplsqlParser::T_INT:
            case HplsqlParser::T_INT2:
            case HplsqlParser::T_INT4:
            case HplsqlParser::T_INT8:
            case HplsqlParser::T_INTEGER:
            case HplsqlParser::T_INTERSECT:
            case HplsqlParser::T_INTERVAL:
            case HplsqlParser::T_INTO:
            case HplsqlParser::T_INVOKER:
            case HplsqlParser::T_IS:
            case HplsqlParser::T_ISOPEN:
            case HplsqlParser::T_ITEMS:
            case HplsqlParser::T_JOIN:
            case HplsqlParser::T_KEEP:
            case HplsqlParser::T_KEY:
            case HplsqlParser::T_KEYS:
            case HplsqlParser::T_LANGUAGE:
            case HplsqlParser::T_LEAVE:
            case HplsqlParser::T_LEFT:
            case HplsqlParser::T_LIKE:
            case HplsqlParser::T_LIMIT:
            case HplsqlParser::T_LINES:
            case HplsqlParser::T_LOCAL:
            case HplsqlParser::T_LOCATION:
            case HplsqlParser::T_LOCATOR:
            case HplsqlParser::T_LOCATORS:
            case HplsqlParser::T_LOCKS:
            case HplsqlParser::T_LOG:
            case HplsqlParser::T_LOGGED:
            case HplsqlParser::T_LOGGING:
            case HplsqlParser::T_LOOP:
            case HplsqlParser::T_MAP:
            case HplsqlParser::T_MATCHED:
            case HplsqlParser::T_MAX:
            case HplsqlParser::T_MAXTRANS:
            case HplsqlParser::T_MERGE:
            case HplsqlParser::T_MESSAGE_TEXT:
            case HplsqlParser::T_MICROSECOND:
            case HplsqlParser::T_MICROSECONDS:
            case HplsqlParser::T_MIN:
            case HplsqlParser::T_MULTISET:
            case HplsqlParser::T_NCHAR:
            case HplsqlParser::T_NEW:
            case HplsqlParser::T_NVARCHAR:
            case HplsqlParser::T_NO:
            case HplsqlParser::T_NOCOUNT:
            case HplsqlParser::T_NOCOMPRESS:
            case HplsqlParser::T_NOLOGGING:
            case HplsqlParser::T_NONE:
            case HplsqlParser::T_NOT:
            case HplsqlParser::T_NOTFOUND:
            case HplsqlParser::T_NUMERIC:
            case HplsqlParser::T_NUMBER:
            case HplsqlParser::T_OBJECT:
            case HplsqlParser::T_OFF:
            case HplsqlParser::T_ON:
            case HplsqlParser::T_ONLY:
            case HplsqlParser::T_OPEN:
            case HplsqlParser::T_OR:
            case HplsqlParser::T_ORDER:
            case HplsqlParser::T_OUT:
            case HplsqlParser::T_OUTER:
            case HplsqlParser::T_OVER:
            case HplsqlParser::T_OVERWRITE:
            case HplsqlParser::T_OWNER:
            case HplsqlParser::T_PACKAGE:
            case HplsqlParser::T_PARTITION:
            case HplsqlParser::T_PCTFREE:
            case HplsqlParser::T_PCTUSED:
            case HplsqlParser::T_PRECISION:
            case HplsqlParser::T_PRESERVE:
            case HplsqlParser::T_PRIMARY:
            case HplsqlParser::T_PRINT:
            case HplsqlParser::T_PROC:
            case HplsqlParser::T_PROCEDURE:
            case HplsqlParser::T_QUALIFY:
            case HplsqlParser::T_QUERY_BAND:
            case HplsqlParser::T_QUIT:
            case HplsqlParser::T_QUOTED_IDENTIFIER:
            case HplsqlParser::T_RAISE:
            case HplsqlParser::T_REAL:
            case HplsqlParser::T_REFERENCES:
            case HplsqlParser::T_REGEXP:
            case HplsqlParser::T_REPLACE:
            case HplsqlParser::T_RESIGNAL:
            case HplsqlParser::T_RESTRICT:
            case HplsqlParser::T_RESULT:
            case HplsqlParser::T_RESULT_SET_LOCATOR:
            case HplsqlParser::T_RETURN:
            case HplsqlParser::T_RETURNS:
            case HplsqlParser::T_REVERSE:
            case HplsqlParser::T_RIGHT:
            case HplsqlParser::T_RLIKE:
            case HplsqlParser::T_ROLE:
            case HplsqlParser::T_ROLLBACK:
            case HplsqlParser::T_ROW:
            case HplsqlParser::T_ROWS:
            case HplsqlParser::T_ROW_COUNT:
            case HplsqlParser::T_RR:
            case HplsqlParser::T_RS:
            case HplsqlParser::T_PWD:
            case HplsqlParser::T_TRIM:
            case HplsqlParser::T_SCHEMA:
            case HplsqlParser::T_SECOND:
            case HplsqlParser::T_SECONDS:
            case HplsqlParser::T_SECURITY:
            case HplsqlParser::T_SEGMENT:
            case HplsqlParser::T_SEL:
            case HplsqlParser::T_SELECT:
            case HplsqlParser::T_SET:
            case HplsqlParser::T_SESSION:
            case HplsqlParser::T_SESSIONS:
            case HplsqlParser::T_SETS:
            case HplsqlParser::T_SHARE:
            case HplsqlParser::T_SIGNAL:
            case HplsqlParser::T_SIMPLE_DOUBLE:
            case HplsqlParser::T_SIMPLE_FLOAT:
            case HplsqlParser::T_SMALLDATETIME:
            case HplsqlParser::T_SMALLINT:
            case HplsqlParser::T_SQL:
            case HplsqlParser::T_SQLEXCEPTION:
            case HplsqlParser::T_SQLINSERT:
            case HplsqlParser::T_SQLSTATE:
            case HplsqlParser::T_SQLWARNING:
            case HplsqlParser::T_STATS:
            case HplsqlParser::T_STATISTICS:
            case HplsqlParser::T_STEP:
            case HplsqlParser::T_STORAGE:
            case HplsqlParser::T_STORED:
            case HplsqlParser::T_STRING:
            case HplsqlParser::T_SUBDIR:
            case HplsqlParser::T_SUBSTRING:
            case HplsqlParser::T_SUM:
            case HplsqlParser::T_SYS_REFCURSOR:
            case HplsqlParser::T_TABLE:
            case HplsqlParser::T_TABLESPACE:
            case HplsqlParser::T_TEMPORARY:
            case HplsqlParser::T_TERMINATED:
            case HplsqlParser::T_TEXTIMAGE_ON:
            case HplsqlParser::T_THEN:
            case HplsqlParser::T_TIMESTAMP:
            case HplsqlParser::T_TITLE:
            case HplsqlParser::T_TO:
            case HplsqlParser::T_TOP:
            case HplsqlParser::T_TRANSACTION:
            case HplsqlParser::T_TRUE:
            case HplsqlParser::T_TRUNCATE:
            case HplsqlParser::T_UNIQUE:
            case HplsqlParser::T_UPDATE:
            case HplsqlParser::T_UR:
            case HplsqlParser::T_USE:
            case HplsqlParser::T_USING:
            case HplsqlParser::T_VALUE:
            case HplsqlParser::T_VALUES:
            case HplsqlParser::T_VAR:
            case HplsqlParser::T_VARCHAR:
            case HplsqlParser::T_VARCHAR2:
            case HplsqlParser::T_VARYING:
            case HplsqlParser::T_VOLATILE:
            case HplsqlParser::T_WHILE:
            case HplsqlParser::T_WITH:
            case HplsqlParser::T_WITHOUT:
            case HplsqlParser::T_WORK:
            case HplsqlParser::T_XACT_ABORT:
            case HplsqlParser::T_XML:
            case HplsqlParser::T_YES:
            case HplsqlParser::T_ACTIVITY_COUNT:
            case HplsqlParser::T_CUME_DIST:
            case HplsqlParser::T_CURRENT_DATE:
            case HplsqlParser::T_CURRENT_TIMESTAMP:
            case HplsqlParser::T_CURRENT_USER:
            case HplsqlParser::T_DENSE_RANK:
            case HplsqlParser::T_FIRST_VALUE:
            case HplsqlParser::T_LAG:
            case HplsqlParser::T_LAST_VALUE:
            case HplsqlParser::T_LEAD:
            case HplsqlParser::T_PART_COUNT:
            case HplsqlParser::T_PART_LOC:
            case HplsqlParser::T_RANK:
            case HplsqlParser::T_ROW_NUMBER:
            case HplsqlParser::T_STDEV:
            case HplsqlParser::T_SYSDATE:
            case HplsqlParser::T_VARIANCE:
            case HplsqlParser::T_USER:
            case HplsqlParser::L_ID: {
              setState(1069);
              ident();
              break;
            }

            case HplsqlParser::L_INT: {
              setState(1070);
              match(HplsqlParser::L_INT);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          setState(1073); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << HplsqlParser::T_ACTION)
          | (1ULL << HplsqlParser::T_ADD2)
          | (1ULL << HplsqlParser::T_ALL)
          | (1ULL << HplsqlParser::T_ALLOCATE)
          | (1ULL << HplsqlParser::T_ALTER)
          | (1ULL << HplsqlParser::T_AND)
          | (1ULL << HplsqlParser::T_ANSI_NULLS)
          | (1ULL << HplsqlParser::T_ANSI_PADDING)
          | (1ULL << HplsqlParser::T_AS)
          | (1ULL << HplsqlParser::T_ASC)
          | (1ULL << HplsqlParser::T_ASSOCIATE)
          | (1ULL << HplsqlParser::T_AT)
          | (1ULL << HplsqlParser::T_AUTO_INCREMENT)
          | (1ULL << HplsqlParser::T_AVG)
          | (1ULL << HplsqlParser::T_BATCHSIZE)
          | (1ULL << HplsqlParser::T_BEGIN)
          | (1ULL << HplsqlParser::T_BETWEEN)
          | (1ULL << HplsqlParser::T_BIGINT)
          | (1ULL << HplsqlParser::T_BINARY_DOUBLE)
          | (1ULL << HplsqlParser::T_BINARY_FLOAT)
          | (1ULL << HplsqlParser::T_BIT)
          | (1ULL << HplsqlParser::T_BODY)
          | (1ULL << HplsqlParser::T_BREAK)
          | (1ULL << HplsqlParser::T_BY)
          | (1ULL << HplsqlParser::T_BYTE)
          | (1ULL << HplsqlParser::T_CALL)
          | (1ULL << HplsqlParser::T_CALLER)
          | (1ULL << HplsqlParser::T_CASCADE)
          | (1ULL << HplsqlParser::T_CASE)
          | (1ULL << HplsqlParser::T_CASESPECIFIC)
          | (1ULL << HplsqlParser::T_CAST)
          | (1ULL << HplsqlParser::T_CHAR)
          | (1ULL << HplsqlParser::T_CHARACTER)
          | (1ULL << HplsqlParser::T_CHARSET)
          | (1ULL << HplsqlParser::T_CLIENT)
          | (1ULL << HplsqlParser::T_CLOSE)
          | (1ULL << HplsqlParser::T_CLUSTERED)
          | (1ULL << HplsqlParser::T_CMP)
          | (1ULL << HplsqlParser::T_COLLECT)
          | (1ULL << HplsqlParser::T_COLLECTION)
          | (1ULL << HplsqlParser::T_COLUMN)
          | (1ULL << HplsqlParser::T_COMMENT)
          | (1ULL << HplsqlParser::T_CONSTANT)
          | (1ULL << HplsqlParser::T_COMMIT)
          | (1ULL << HplsqlParser::T_COMPRESS)
          | (1ULL << HplsqlParser::T_CONCAT)
          | (1ULL << HplsqlParser::T_CONDITION)
          | (1ULL << HplsqlParser::T_CONSTRAINT)
          | (1ULL << HplsqlParser::T_CONTINUE)
          | (1ULL << HplsqlParser::T_COPY)
          | (1ULL << HplsqlParser::T_COUNT)
          | (1ULL << HplsqlParser::T_COUNT_BIG)
          | (1ULL << HplsqlParser::T_CREATE)
          | (1ULL << HplsqlParser::T_CREATION)
          | (1ULL << HplsqlParser::T_CREATOR)
          | (1ULL << HplsqlParser::T_CS)
          | (1ULL << HplsqlParser::T_CURRENT))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & ((1ULL << (HplsqlParser::T_CURRENT_SCHEMA - 64))
          | (1ULL << (HplsqlParser::T_CURSOR - 64))
          | (1ULL << (HplsqlParser::T_DATABASE - 64))
          | (1ULL << (HplsqlParser::T_DATA - 64))
          | (1ULL << (HplsqlParser::T_DATE - 64))
          | (1ULL << (HplsqlParser::T_DATETIME - 64))
          | (1ULL << (HplsqlParser::T_DAY - 64))
          | (1ULL << (HplsqlParser::T_DAYS - 64))
          | (1ULL << (HplsqlParser::T_DEC - 64))
          | (1ULL << (HplsqlParser::T_DECIMAL - 64))
          | (1ULL << (HplsqlParser::T_DECLARE - 64))
          | (1ULL << (HplsqlParser::T_DEFAULT - 64))
          | (1ULL << (HplsqlParser::T_DEFERRED - 64))
          | (1ULL << (HplsqlParser::T_DEFINED - 64))
          | (1ULL << (HplsqlParser::T_DEFINER - 64))
          | (1ULL << (HplsqlParser::T_DEFINITION - 64))
          | (1ULL << (HplsqlParser::T_DELETE - 64))
          | (1ULL << (HplsqlParser::T_DELIMITED - 64))
          | (1ULL << (HplsqlParser::T_DELIMITER - 64))
          | (1ULL << (HplsqlParser::T_DESC - 64))
          | (1ULL << (HplsqlParser::T_DESCRIBE - 64))
          | (1ULL << (HplsqlParser::T_DIAGNOSTICS - 64))
          | (1ULL << (HplsqlParser::T_DIR - 64))
          | (1ULL << (HplsqlParser::T_DIRECTORY - 64))
          | (1ULL << (HplsqlParser::T_DISTINCT - 64))
          | (1ULL << (HplsqlParser::T_DISTRIBUTE - 64))
          | (1ULL << (HplsqlParser::T_DO - 64))
          | (1ULL << (HplsqlParser::T_DOUBLE - 64))
          | (1ULL << (HplsqlParser::T_DROP - 64))
          | (1ULL << (HplsqlParser::T_DYNAMIC - 64))
          | (1ULL << (HplsqlParser::T_ENABLE - 64))
          | (1ULL << (HplsqlParser::T_ENGINE - 64))
          | (1ULL << (HplsqlParser::T_ESCAPED - 64))
          | (1ULL << (HplsqlParser::T_EXCEPT - 64))
          | (1ULL << (HplsqlParser::T_EXEC - 64))
          | (1ULL << (HplsqlParser::T_EXECUTE - 64))
          | (1ULL << (HplsqlParser::T_EXCEPTION - 64))
          | (1ULL << (HplsqlParser::T_EXCLUSIVE - 64))
          | (1ULL << (HplsqlParser::T_EXISTS - 64))
          | (1ULL << (HplsqlParser::T_EXIT - 64))
          | (1ULL << (HplsqlParser::T_FALLBACK - 64))
          | (1ULL << (HplsqlParser::T_FALSE - 64))
          | (1ULL << (HplsqlParser::T_FETCH - 64))
          | (1ULL << (HplsqlParser::T_FIELDS - 64))
          | (1ULL << (HplsqlParser::T_FILE - 64))
          | (1ULL << (HplsqlParser::T_FILES - 64))
          | (1ULL << (HplsqlParser::T_FLOAT - 64))
          | (1ULL << (HplsqlParser::T_FOR - 64))
          | (1ULL << (HplsqlParser::T_FOREIGN - 64))
          | (1ULL << (HplsqlParser::T_FORMAT - 64))
          | (1ULL << (HplsqlParser::T_FOUND - 64))
          | (1ULL << (HplsqlParser::T_FROM - 64))
          | (1ULL << (HplsqlParser::T_FULL - 64))
          | (1ULL << (HplsqlParser::T_FUNCTION - 64))
          | (1ULL << (HplsqlParser::T_GET - 64))
          | (1ULL << (HplsqlParser::T_GLOBAL - 64))
          | (1ULL << (HplsqlParser::T_GO - 64))
          | (1ULL << (HplsqlParser::T_GRANT - 64))
          | (1ULL << (HplsqlParser::T_GROUP - 64))
          | (1ULL << (HplsqlParser::T_HANDLER - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 128)) & ((1ULL << (HplsqlParser::T_HASH - 128))
          | (1ULL << (HplsqlParser::T_HAVING - 128))
          | (1ULL << (HplsqlParser::T_HDFS - 128))
          | (1ULL << (HplsqlParser::T_HIVE - 128))
          | (1ULL << (HplsqlParser::T_HOST - 128))
          | (1ULL << (HplsqlParser::T_IDENTITY - 128))
          | (1ULL << (HplsqlParser::T_IF - 128))
          | (1ULL << (HplsqlParser::T_IGNORE - 128))
          | (1ULL << (HplsqlParser::T_IMMEDIATE - 128))
          | (1ULL << (HplsqlParser::T_IN - 128))
          | (1ULL << (HplsqlParser::T_INCLUDE - 128))
          | (1ULL << (HplsqlParser::T_INDEX - 128))
          | (1ULL << (HplsqlParser::T_INITRANS - 128))
          | (1ULL << (HplsqlParser::T_INNER - 128))
          | (1ULL << (HplsqlParser::T_INOUT - 128))
          | (1ULL << (HplsqlParser::T_INSERT - 128))
          | (1ULL << (HplsqlParser::T_INT - 128))
          | (1ULL << (HplsqlParser::T_INT2 - 128))
          | (1ULL << (HplsqlParser::T_INT4 - 128))
          | (1ULL << (HplsqlParser::T_INT8 - 128))
          | (1ULL << (HplsqlParser::T_INTEGER - 128))
          | (1ULL << (HplsqlParser::T_INTERSECT - 128))
          | (1ULL << (HplsqlParser::T_INTERVAL - 128))
          | (1ULL << (HplsqlParser::T_INTO - 128))
          | (1ULL << (HplsqlParser::T_INVOKER - 128))
          | (1ULL << (HplsqlParser::T_IS - 128))
          | (1ULL << (HplsqlParser::T_ISOPEN - 128))
          | (1ULL << (HplsqlParser::T_ITEMS - 128))
          | (1ULL << (HplsqlParser::T_JOIN - 128))
          | (1ULL << (HplsqlParser::T_KEEP - 128))
          | (1ULL << (HplsqlParser::T_KEY - 128))
          | (1ULL << (HplsqlParser::T_KEYS - 128))
          | (1ULL << (HplsqlParser::T_LANGUAGE - 128))
          | (1ULL << (HplsqlParser::T_LEAVE - 128))
          | (1ULL << (HplsqlParser::T_LEFT - 128))
          | (1ULL << (HplsqlParser::T_LIKE - 128))
          | (1ULL << (HplsqlParser::T_LIMIT - 128))
          | (1ULL << (HplsqlParser::T_LINES - 128))
          | (1ULL << (HplsqlParser::T_LOCAL - 128))
          | (1ULL << (HplsqlParser::T_LOCATION - 128))
          | (1ULL << (HplsqlParser::T_LOCATOR - 128))
          | (1ULL << (HplsqlParser::T_LOCATORS - 128))
          | (1ULL << (HplsqlParser::T_LOCKS - 128))
          | (1ULL << (HplsqlParser::T_LOG - 128))
          | (1ULL << (HplsqlParser::T_LOGGED - 128))
          | (1ULL << (HplsqlParser::T_LOGGING - 128))
          | (1ULL << (HplsqlParser::T_LOOP - 128))
          | (1ULL << (HplsqlParser::T_MAP - 128))
          | (1ULL << (HplsqlParser::T_MATCHED - 128))
          | (1ULL << (HplsqlParser::T_MAX - 128))
          | (1ULL << (HplsqlParser::T_MAXTRANS - 128))
          | (1ULL << (HplsqlParser::T_MERGE - 128))
          | (1ULL << (HplsqlParser::T_MESSAGE_TEXT - 128))
          | (1ULL << (HplsqlParser::T_MICROSECOND - 128))
          | (1ULL << (HplsqlParser::T_MICROSECONDS - 128))
          | (1ULL << (HplsqlParser::T_MIN - 128))
          | (1ULL << (HplsqlParser::T_MULTISET - 128))
          | (1ULL << (HplsqlParser::T_NCHAR - 128))
          | (1ULL << (HplsqlParser::T_NEW - 128))
          | (1ULL << (HplsqlParser::T_NVARCHAR - 128))
          | (1ULL << (HplsqlParser::T_NO - 128))
          | (1ULL << (HplsqlParser::T_NOCOUNT - 128))
          | (1ULL << (HplsqlParser::T_NOCOMPRESS - 128))
          | (1ULL << (HplsqlParser::T_NOLOGGING - 128)))) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 192)) & ((1ULL << (HplsqlParser::T_NONE - 192))
          | (1ULL << (HplsqlParser::T_NOT - 192))
          | (1ULL << (HplsqlParser::T_NOTFOUND - 192))
          | (1ULL << (HplsqlParser::T_NUMERIC - 192))
          | (1ULL << (HplsqlParser::T_NUMBER - 192))
          | (1ULL << (HplsqlParser::T_OBJECT - 192))
          | (1ULL << (HplsqlParser::T_OFF - 192))
          | (1ULL << (HplsqlParser::T_ON - 192))
          | (1ULL << (HplsqlParser::T_ONLY - 192))
          | (1ULL << (HplsqlParser::T_OPEN - 192))
          | (1ULL << (HplsqlParser::T_OR - 192))
          | (1ULL << (HplsqlParser::T_ORDER - 192))
          | (1ULL << (HplsqlParser::T_OUT - 192))
          | (1ULL << (HplsqlParser::T_OUTER - 192))
          | (1ULL << (HplsqlParser::T_OVER - 192))
          | (1ULL << (HplsqlParser::T_OVERWRITE - 192))
          | (1ULL << (HplsqlParser::T_OWNER - 192))
          | (1ULL << (HplsqlParser::T_PACKAGE - 192))
          | (1ULL << (HplsqlParser::T_PARTITION - 192))
          | (1ULL << (HplsqlParser::T_PCTFREE - 192))
          | (1ULL << (HplsqlParser::T_PCTUSED - 192))
          | (1ULL << (HplsqlParser::T_PRECISION - 192))
          | (1ULL << (HplsqlParser::T_PRESERVE - 192))
          | (1ULL << (HplsqlParser::T_PRIMARY - 192))
          | (1ULL << (HplsqlParser::T_PRINT - 192))
          | (1ULL << (HplsqlParser::T_PROC - 192))
          | (1ULL << (HplsqlParser::T_PROCEDURE - 192))
          | (1ULL << (HplsqlParser::T_QUALIFY - 192))
          | (1ULL << (HplsqlParser::T_QUERY_BAND - 192))
          | (1ULL << (HplsqlParser::T_QUIT - 192))
          | (1ULL << (HplsqlParser::T_QUOTED_IDENTIFIER - 192))
          | (1ULL << (HplsqlParser::T_RAISE - 192))
          | (1ULL << (HplsqlParser::T_REAL - 192))
          | (1ULL << (HplsqlParser::T_REFERENCES - 192))
          | (1ULL << (HplsqlParser::T_REGEXP - 192))
          | (1ULL << (HplsqlParser::T_REPLACE - 192))
          | (1ULL << (HplsqlParser::T_RESIGNAL - 192))
          | (1ULL << (HplsqlParser::T_RESTRICT - 192))
          | (1ULL << (HplsqlParser::T_RESULT - 192))
          | (1ULL << (HplsqlParser::T_RESULT_SET_LOCATOR - 192))
          | (1ULL << (HplsqlParser::T_RETURN - 192))
          | (1ULL << (HplsqlParser::T_RETURNS - 192))
          | (1ULL << (HplsqlParser::T_REVERSE - 192))
          | (1ULL << (HplsqlParser::T_RIGHT - 192))
          | (1ULL << (HplsqlParser::T_RLIKE - 192))
          | (1ULL << (HplsqlParser::T_ROLE - 192))
          | (1ULL << (HplsqlParser::T_ROLLBACK - 192))
          | (1ULL << (HplsqlParser::T_ROW - 192))
          | (1ULL << (HplsqlParser::T_ROWS - 192))
          | (1ULL << (HplsqlParser::T_ROW_COUNT - 192))
          | (1ULL << (HplsqlParser::T_RR - 192))
          | (1ULL << (HplsqlParser::T_RS - 192))
          | (1ULL << (HplsqlParser::T_PWD - 192))
          | (1ULL << (HplsqlParser::T_TRIM - 192))
          | (1ULL << (HplsqlParser::T_SCHEMA - 192))
          | (1ULL << (HplsqlParser::T_SECOND - 192))
          | (1ULL << (HplsqlParser::T_SECONDS - 192))
          | (1ULL << (HplsqlParser::T_SECURITY - 192))
          | (1ULL << (HplsqlParser::T_SEGMENT - 192))
          | (1ULL << (HplsqlParser::T_SEL - 192))
          | (1ULL << (HplsqlParser::T_SELECT - 192)))) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 256)) & ((1ULL << (HplsqlParser::T_SET - 256))
          | (1ULL << (HplsqlParser::T_SESSION - 256))
          | (1ULL << (HplsqlParser::T_SESSIONS - 256))
          | (1ULL << (HplsqlParser::T_SETS - 256))
          | (1ULL << (HplsqlParser::T_SHARE - 256))
          | (1ULL << (HplsqlParser::T_SIGNAL - 256))
          | (1ULL << (HplsqlParser::T_SIMPLE_DOUBLE - 256))
          | (1ULL << (HplsqlParser::T_SIMPLE_FLOAT - 256))
          | (1ULL << (HplsqlParser::T_SMALLDATETIME - 256))
          | (1ULL << (HplsqlParser::T_SMALLINT - 256))
          | (1ULL << (HplsqlParser::T_SQL - 256))
          | (1ULL << (HplsqlParser::T_SQLEXCEPTION - 256))
          | (1ULL << (HplsqlParser::T_SQLINSERT - 256))
          | (1ULL << (HplsqlParser::T_SQLSTATE - 256))
          | (1ULL << (HplsqlParser::T_SQLWARNING - 256))
          | (1ULL << (HplsqlParser::T_STATS - 256))
          | (1ULL << (HplsqlParser::T_STATISTICS - 256))
          | (1ULL << (HplsqlParser::T_STEP - 256))
          | (1ULL << (HplsqlParser::T_STORAGE - 256))
          | (1ULL << (HplsqlParser::T_STORED - 256))
          | (1ULL << (HplsqlParser::T_STRING - 256))
          | (1ULL << (HplsqlParser::T_SUBDIR - 256))
          | (1ULL << (HplsqlParser::T_SUBSTRING - 256))
          | (1ULL << (HplsqlParser::T_SUM - 256))
          | (1ULL << (HplsqlParser::T_SYS_REFCURSOR - 256))
          | (1ULL << (HplsqlParser::T_TABLE - 256))
          | (1ULL << (HplsqlParser::T_TABLESPACE - 256))
          | (1ULL << (HplsqlParser::T_TEMPORARY - 256))
          | (1ULL << (HplsqlParser::T_TERMINATED - 256))
          | (1ULL << (HplsqlParser::T_TEXTIMAGE_ON - 256))
          | (1ULL << (HplsqlParser::T_THEN - 256))
          | (1ULL << (HplsqlParser::T_TIMESTAMP - 256))
          | (1ULL << (HplsqlParser::T_TITLE - 256))
          | (1ULL << (HplsqlParser::T_TO - 256))
          | (1ULL << (HplsqlParser::T_TOP - 256))
          | (1ULL << (HplsqlParser::T_TRANSACTION - 256))
          | (1ULL << (HplsqlParser::T_TRUE - 256))
          | (1ULL << (HplsqlParser::T_TRUNCATE - 256))
          | (1ULL << (HplsqlParser::T_UNIQUE - 256))
          | (1ULL << (HplsqlParser::T_UPDATE - 256))
          | (1ULL << (HplsqlParser::T_UR - 256))
          | (1ULL << (HplsqlParser::T_USE - 256))
          | (1ULL << (HplsqlParser::T_USING - 256))
          | (1ULL << (HplsqlParser::T_VALUE - 256))
          | (1ULL << (HplsqlParser::T_VALUES - 256))
          | (1ULL << (HplsqlParser::T_VAR - 256))
          | (1ULL << (HplsqlParser::T_VARCHAR - 256))
          | (1ULL << (HplsqlParser::T_VARCHAR2 - 256))
          | (1ULL << (HplsqlParser::T_VARYING - 256))
          | (1ULL << (HplsqlParser::T_VOLATILE - 256))
          | (1ULL << (HplsqlParser::T_WHILE - 256))
          | (1ULL << (HplsqlParser::T_WITH - 256))
          | (1ULL << (HplsqlParser::T_WITHOUT - 256))
          | (1ULL << (HplsqlParser::T_WORK - 256))
          | (1ULL << (HplsqlParser::T_XACT_ABORT - 256))
          | (1ULL << (HplsqlParser::T_XML - 256))
          | (1ULL << (HplsqlParser::T_YES - 256))
          | (1ULL << (HplsqlParser::T_ACTIVITY_COUNT - 256)))) != 0) || ((((_la - 320) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 320)) & ((1ULL << (HplsqlParser::T_CUME_DIST - 320))
          | (1ULL << (HplsqlParser::T_CURRENT_DATE - 320))
          | (1ULL << (HplsqlParser::T_CURRENT_TIMESTAMP - 320))
          | (1ULL << (HplsqlParser::T_CURRENT_USER - 320))
          | (1ULL << (HplsqlParser::T_DENSE_RANK - 320))
          | (1ULL << (HplsqlParser::T_FIRST_VALUE - 320))
          | (1ULL << (HplsqlParser::T_LAG - 320))
          | (1ULL << (HplsqlParser::T_LAST_VALUE - 320))
          | (1ULL << (HplsqlParser::T_LEAD - 320))
          | (1ULL << (HplsqlParser::T_PART_COUNT - 320))
          | (1ULL << (HplsqlParser::T_PART_LOC - 320))
          | (1ULL << (HplsqlParser::T_RANK - 320))
          | (1ULL << (HplsqlParser::T_ROW_NUMBER - 320))
          | (1ULL << (HplsqlParser::T_STDEV - 320))
          | (1ULL << (HplsqlParser::T_SYSDATE - 320))
          | (1ULL << (HplsqlParser::T_VARIANCE - 320))
          | (1ULL << (HplsqlParser::T_USER - 320))
          | (1ULL << (HplsqlParser::L_ID - 320))
          | (1ULL << (HplsqlParser::L_INT - 320)))) != 0));
        setState(1075);
        match(HplsqlParser::T_CLOSE_P);
        break;
      }

      case HplsqlParser::T_TABLESPACE: {
        enterOuterAlt(_localctx, 6);
        setState(1076);
        match(HplsqlParser::T_TABLESPACE);
        setState(1077);
        ident();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_options_db2_itemContext ------------------------------------------------------------------

HplsqlParser::Create_table_options_db2_itemContext::Create_table_options_db2_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_table_options_db2_itemContext::T_IN() {
  return getToken(HplsqlParser::T_IN, 0);
}

std::vector<HplsqlParser::IdentContext *> HplsqlParser::Create_table_options_db2_itemContext::ident() {
  return getRuleContexts<HplsqlParser::IdentContext>();
}

HplsqlParser::IdentContext* HplsqlParser::Create_table_options_db2_itemContext::ident(size_t i) {
  return getRuleContext<HplsqlParser::IdentContext>(i);
}

tree::TerminalNode* HplsqlParser::Create_table_options_db2_itemContext::T_INDEX() {
  return getToken(HplsqlParser::T_INDEX, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_db2_itemContext::T_WITH() {
  return getToken(HplsqlParser::T_WITH, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_db2_itemContext::T_REPLACE() {
  return getToken(HplsqlParser::T_REPLACE, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_db2_itemContext::T_DISTRIBUTE() {
  return getToken(HplsqlParser::T_DISTRIBUTE, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_db2_itemContext::T_BY() {
  return getToken(HplsqlParser::T_BY, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_db2_itemContext::T_HASH() {
  return getToken(HplsqlParser::T_HASH, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_db2_itemContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_db2_itemContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Create_table_options_db2_itemContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Create_table_options_db2_itemContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}

tree::TerminalNode* HplsqlParser::Create_table_options_db2_itemContext::T_LOGGED() {
  return getToken(HplsqlParser::T_LOGGED, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_db2_itemContext::T_NOT() {
  return getToken(HplsqlParser::T_NOT, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_db2_itemContext::T_COMPRESS() {
  return getToken(HplsqlParser::T_COMPRESS, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_db2_itemContext::T_YES() {
  return getToken(HplsqlParser::T_YES, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_db2_itemContext::T_NO() {
  return getToken(HplsqlParser::T_NO, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_db2_itemContext::T_DEFINITION() {
  return getToken(HplsqlParser::T_DEFINITION, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_db2_itemContext::T_ONLY() {
  return getToken(HplsqlParser::T_ONLY, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_db2_itemContext::T_RESTRICT() {
  return getToken(HplsqlParser::T_RESTRICT, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_db2_itemContext::T_ON() {
  return getToken(HplsqlParser::T_ON, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_db2_itemContext::T_DROP() {
  return getToken(HplsqlParser::T_DROP, 0);
}


size_t HplsqlParser::Create_table_options_db2_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_table_options_db2_item;
}

void HplsqlParser::Create_table_options_db2_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_options_db2_item(this);
}

void HplsqlParser::Create_table_options_db2_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_options_db2_item(this);
}


antlrcpp::Any HplsqlParser::Create_table_options_db2_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_table_options_db2_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_table_options_db2_itemContext* HplsqlParser::create_table_options_db2_item() {
  Create_table_options_db2_itemContext *_localctx = _tracker.createInstance<Create_table_options_db2_itemContext>(_ctx, getState());
  enterRule(_localctx, 96, HplsqlParser::RuleCreate_table_options_db2_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1113);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 92, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1081);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HplsqlParser::T_INDEX) {
        setState(1080);
        match(HplsqlParser::T_INDEX);
      }
      setState(1083);
      match(HplsqlParser::T_IN);
      setState(1084);
      ident();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1085);
      match(HplsqlParser::T_WITH);
      setState(1086);
      match(HplsqlParser::T_REPLACE);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1087);
      match(HplsqlParser::T_DISTRIBUTE);
      setState(1088);
      match(HplsqlParser::T_BY);
      setState(1089);
      match(HplsqlParser::T_HASH);
      setState(1090);
      match(HplsqlParser::T_OPEN_P);
      setState(1091);
      ident();
      setState(1096);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == HplsqlParser::T_COMMA) {
        setState(1092);
        match(HplsqlParser::T_COMMA);
        setState(1093);
        ident();
        setState(1098);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1099);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1102);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HplsqlParser::T_NOT) {
        setState(1101);
        match(HplsqlParser::T_NOT);
      }
      setState(1104);
      match(HplsqlParser::T_LOGGED);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1105);
      match(HplsqlParser::T_COMPRESS);
      setState(1106);
      _la = _input->LA(1);
      if (!(_la == HplsqlParser::T_NO || _la == HplsqlParser::T_YES)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1107);
      match(HplsqlParser::T_DEFINITION);
      setState(1108);
      match(HplsqlParser::T_ONLY);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1109);
      match(HplsqlParser::T_WITH);
      setState(1110);
      match(HplsqlParser::T_RESTRICT);
      setState(1111);
      match(HplsqlParser::T_ON);
      setState(1112);
      match(HplsqlParser::T_DROP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_options_td_itemContext ------------------------------------------------------------------

HplsqlParser::Create_table_options_td_itemContext::Create_table_options_td_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_table_options_td_itemContext::T_PRIMARY() {
  return getToken(HplsqlParser::T_PRIMARY, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_td_itemContext::T_INDEX() {
  return getToken(HplsqlParser::T_INDEX, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_td_itemContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

std::vector<HplsqlParser::IdentContext *> HplsqlParser::Create_table_options_td_itemContext::ident() {
  return getRuleContexts<HplsqlParser::IdentContext>();
}

HplsqlParser::IdentContext* HplsqlParser::Create_table_options_td_itemContext::ident(size_t i) {
  return getRuleContext<HplsqlParser::IdentContext>(i);
}

tree::TerminalNode* HplsqlParser::Create_table_options_td_itemContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_td_itemContext::T_UNIQUE() {
  return getToken(HplsqlParser::T_UNIQUE, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Create_table_options_td_itemContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Create_table_options_td_itemContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}

tree::TerminalNode* HplsqlParser::Create_table_options_td_itemContext::T_WITH() {
  return getToken(HplsqlParser::T_WITH, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_td_itemContext::T_DATA() {
  return getToken(HplsqlParser::T_DATA, 0);
}


size_t HplsqlParser::Create_table_options_td_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_table_options_td_item;
}

void HplsqlParser::Create_table_options_td_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_options_td_item(this);
}

void HplsqlParser::Create_table_options_td_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_options_td_item(this);
}


antlrcpp::Any HplsqlParser::Create_table_options_td_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_table_options_td_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_table_options_td_itemContext* HplsqlParser::create_table_options_td_item() {
  Create_table_options_td_itemContext *_localctx = _tracker.createInstance<Create_table_options_td_itemContext>(_ctx, getState());
  enterRule(_localctx, 98, HplsqlParser::RuleCreate_table_options_td_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1133);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_PRIMARY:
      case HplsqlParser::T_UNIQUE: {
        enterOuterAlt(_localctx, 1);
        setState(1116);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_UNIQUE) {
          setState(1115);
          match(HplsqlParser::T_UNIQUE);
        }
        setState(1118);
        match(HplsqlParser::T_PRIMARY);
        setState(1119);
        match(HplsqlParser::T_INDEX);
        setState(1120);
        match(HplsqlParser::T_OPEN_P);
        setState(1121);
        ident();
        setState(1126);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == HplsqlParser::T_COMMA) {
          setState(1122);
          match(HplsqlParser::T_COMMA);
          setState(1123);
          ident();
          setState(1128);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1129);
        match(HplsqlParser::T_CLOSE_P);
        break;
      }

      case HplsqlParser::T_WITH: {
        enterOuterAlt(_localctx, 2);
        setState(1131);
        match(HplsqlParser::T_WITH);
        setState(1132);
        match(HplsqlParser::T_DATA);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_options_hive_itemContext ------------------------------------------------------------------

HplsqlParser::Create_table_options_hive_itemContext::Create_table_options_hive_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Create_table_hive_row_formatContext* HplsqlParser::Create_table_options_hive_itemContext::create_table_hive_row_format() {
  return getRuleContext<HplsqlParser::Create_table_hive_row_formatContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_hive_itemContext::T_STORED() {
  return getToken(HplsqlParser::T_STORED, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_hive_itemContext::T_AS() {
  return getToken(HplsqlParser::T_AS, 0);
}

HplsqlParser::IdentContext* HplsqlParser::Create_table_options_hive_itemContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}


size_t HplsqlParser::Create_table_options_hive_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_table_options_hive_item;
}

void HplsqlParser::Create_table_options_hive_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_options_hive_item(this);
}

void HplsqlParser::Create_table_options_hive_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_options_hive_item(this);
}


antlrcpp::Any HplsqlParser::Create_table_options_hive_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_table_options_hive_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_table_options_hive_itemContext* HplsqlParser::create_table_options_hive_item() {
  Create_table_options_hive_itemContext *_localctx = _tracker.createInstance<Create_table_options_hive_itemContext>(_ctx, getState());
  enterRule(_localctx, 100, HplsqlParser::RuleCreate_table_options_hive_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1139);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_ROW: {
        enterOuterAlt(_localctx, 1);
        setState(1135);
        create_table_hive_row_format();
        break;
      }

      case HplsqlParser::T_STORED: {
        enterOuterAlt(_localctx, 2);
        setState(1136);
        match(HplsqlParser::T_STORED);
        setState(1137);
        match(HplsqlParser::T_AS);
        setState(1138);
        ident();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_hive_row_formatContext ------------------------------------------------------------------

HplsqlParser::Create_table_hive_row_formatContext::Create_table_hive_row_formatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_table_hive_row_formatContext::T_ROW() {
  return getToken(HplsqlParser::T_ROW, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_hive_row_formatContext::T_FORMAT() {
  return getToken(HplsqlParser::T_FORMAT, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_hive_row_formatContext::T_DELIMITED() {
  return getToken(HplsqlParser::T_DELIMITED, 0);
}

std::vector<HplsqlParser::Create_table_hive_row_format_fieldsContext *> HplsqlParser::Create_table_hive_row_formatContext::create_table_hive_row_format_fields() {
  return getRuleContexts<HplsqlParser::Create_table_hive_row_format_fieldsContext>();
}

HplsqlParser::Create_table_hive_row_format_fieldsContext* HplsqlParser::Create_table_hive_row_formatContext::create_table_hive_row_format_fields(size_t i) {
  return getRuleContext<HplsqlParser::Create_table_hive_row_format_fieldsContext>(i);
}


size_t HplsqlParser::Create_table_hive_row_formatContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_table_hive_row_format;
}

void HplsqlParser::Create_table_hive_row_formatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_hive_row_format(this);
}

void HplsqlParser::Create_table_hive_row_formatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_hive_row_format(this);
}


antlrcpp::Any HplsqlParser::Create_table_hive_row_formatContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_table_hive_row_format(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_table_hive_row_formatContext* HplsqlParser::create_table_hive_row_format() {
  Create_table_hive_row_formatContext *_localctx = _tracker.createInstance<Create_table_hive_row_formatContext>(_ctx, getState());
  enterRule(_localctx, 102, HplsqlParser::RuleCreate_table_hive_row_format);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1141);
    match(HplsqlParser::T_ROW);
    setState(1142);
    match(HplsqlParser::T_FORMAT);
    setState(1143);
    match(HplsqlParser::T_DELIMITED);
    setState(1147);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 97, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1144);
        create_table_hive_row_format_fields(); 
      }
      setState(1149);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 97, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_hive_row_format_fieldsContext ------------------------------------------------------------------

HplsqlParser::Create_table_hive_row_format_fieldsContext::Create_table_hive_row_format_fieldsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_table_hive_row_format_fieldsContext::T_FIELDS() {
  return getToken(HplsqlParser::T_FIELDS, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_hive_row_format_fieldsContext::T_TERMINATED() {
  return getToken(HplsqlParser::T_TERMINATED, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Create_table_hive_row_format_fieldsContext::T_BY() {
  return getTokens(HplsqlParser::T_BY);
}

tree::TerminalNode* HplsqlParser::Create_table_hive_row_format_fieldsContext::T_BY(size_t i) {
  return getToken(HplsqlParser::T_BY, i);
}

std::vector<HplsqlParser::ExprContext *> HplsqlParser::Create_table_hive_row_format_fieldsContext::expr() {
  return getRuleContexts<HplsqlParser::ExprContext>();
}

HplsqlParser::ExprContext* HplsqlParser::Create_table_hive_row_format_fieldsContext::expr(size_t i) {
  return getRuleContext<HplsqlParser::ExprContext>(i);
}

tree::TerminalNode* HplsqlParser::Create_table_hive_row_format_fieldsContext::T_ESCAPED() {
  return getToken(HplsqlParser::T_ESCAPED, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_hive_row_format_fieldsContext::T_COLLECTION() {
  return getToken(HplsqlParser::T_COLLECTION, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_hive_row_format_fieldsContext::T_ITEMS() {
  return getToken(HplsqlParser::T_ITEMS, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_hive_row_format_fieldsContext::T_MAP() {
  return getToken(HplsqlParser::T_MAP, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_hive_row_format_fieldsContext::T_KEYS() {
  return getToken(HplsqlParser::T_KEYS, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_hive_row_format_fieldsContext::T_LINES() {
  return getToken(HplsqlParser::T_LINES, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_hive_row_format_fieldsContext::T_NULL() {
  return getToken(HplsqlParser::T_NULL, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_hive_row_format_fieldsContext::T_DEFINED() {
  return getToken(HplsqlParser::T_DEFINED, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_hive_row_format_fieldsContext::T_AS() {
  return getToken(HplsqlParser::T_AS, 0);
}


size_t HplsqlParser::Create_table_hive_row_format_fieldsContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_table_hive_row_format_fields;
}

void HplsqlParser::Create_table_hive_row_format_fieldsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_hive_row_format_fields(this);
}

void HplsqlParser::Create_table_hive_row_format_fieldsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_hive_row_format_fields(this);
}


antlrcpp::Any HplsqlParser::Create_table_hive_row_format_fieldsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_table_hive_row_format_fields(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_table_hive_row_format_fieldsContext* HplsqlParser::create_table_hive_row_format_fields() {
  Create_table_hive_row_format_fieldsContext *_localctx = _tracker.createInstance<Create_table_hive_row_format_fieldsContext>(_ctx, getState());
  enterRule(_localctx, 104, HplsqlParser::RuleCreate_table_hive_row_format_fields);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1177);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_FIELDS: {
        enterOuterAlt(_localctx, 1);
        setState(1150);
        match(HplsqlParser::T_FIELDS);
        setState(1151);
        match(HplsqlParser::T_TERMINATED);
        setState(1152);
        match(HplsqlParser::T_BY);
        setState(1153);
        expr(0);
        setState(1157);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx)) {
        case 1: {
          setState(1154);
          match(HplsqlParser::T_ESCAPED);
          setState(1155);
          match(HplsqlParser::T_BY);
          setState(1156);
          expr(0);
          break;
        }

        default:
          break;
        }
        break;
      }

      case HplsqlParser::T_COLLECTION: {
        enterOuterAlt(_localctx, 2);
        setState(1159);
        match(HplsqlParser::T_COLLECTION);
        setState(1160);
        match(HplsqlParser::T_ITEMS);
        setState(1161);
        match(HplsqlParser::T_TERMINATED);
        setState(1162);
        match(HplsqlParser::T_BY);
        setState(1163);
        expr(0);
        break;
      }

      case HplsqlParser::T_MAP: {
        enterOuterAlt(_localctx, 3);
        setState(1164);
        match(HplsqlParser::T_MAP);
        setState(1165);
        match(HplsqlParser::T_KEYS);
        setState(1166);
        match(HplsqlParser::T_TERMINATED);
        setState(1167);
        match(HplsqlParser::T_BY);
        setState(1168);
        expr(0);
        break;
      }

      case HplsqlParser::T_LINES: {
        enterOuterAlt(_localctx, 4);
        setState(1169);
        match(HplsqlParser::T_LINES);
        setState(1170);
        match(HplsqlParser::T_TERMINATED);
        setState(1171);
        match(HplsqlParser::T_BY);
        setState(1172);
        expr(0);
        break;
      }

      case HplsqlParser::T_NULL: {
        enterOuterAlt(_localctx, 5);
        setState(1173);
        match(HplsqlParser::T_NULL);
        setState(1174);
        match(HplsqlParser::T_DEFINED);
        setState(1175);
        match(HplsqlParser::T_AS);
        setState(1176);
        expr(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_options_mssql_itemContext ------------------------------------------------------------------

HplsqlParser::Create_table_options_mssql_itemContext::Create_table_options_mssql_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_table_options_mssql_itemContext::T_ON() {
  return getToken(HplsqlParser::T_ON, 0);
}

HplsqlParser::IdentContext* HplsqlParser::Create_table_options_mssql_itemContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_mssql_itemContext::T_TEXTIMAGE_ON() {
  return getToken(HplsqlParser::T_TEXTIMAGE_ON, 0);
}


size_t HplsqlParser::Create_table_options_mssql_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_table_options_mssql_item;
}

void HplsqlParser::Create_table_options_mssql_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_options_mssql_item(this);
}

void HplsqlParser::Create_table_options_mssql_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_options_mssql_item(this);
}


antlrcpp::Any HplsqlParser::Create_table_options_mssql_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_table_options_mssql_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_table_options_mssql_itemContext* HplsqlParser::create_table_options_mssql_item() {
  Create_table_options_mssql_itemContext *_localctx = _tracker.createInstance<Create_table_options_mssql_itemContext>(_ctx, getState());
  enterRule(_localctx, 106, HplsqlParser::RuleCreate_table_options_mssql_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1183);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_ON: {
        enterOuterAlt(_localctx, 1);
        setState(1179);
        match(HplsqlParser::T_ON);
        setState(1180);
        ident();
        break;
      }

      case HplsqlParser::T_TEXTIMAGE_ON: {
        enterOuterAlt(_localctx, 2);
        setState(1181);
        match(HplsqlParser::T_TEXTIMAGE_ON);
        setState(1182);
        ident();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_options_mysql_itemContext ------------------------------------------------------------------

HplsqlParser::Create_table_options_mysql_itemContext::Create_table_options_mysql_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_table_options_mysql_itemContext::T_AUTO_INCREMENT() {
  return getToken(HplsqlParser::T_AUTO_INCREMENT, 0);
}

HplsqlParser::ExprContext* HplsqlParser::Create_table_options_mysql_itemContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_mysql_itemContext::T_EQUAL() {
  return getToken(HplsqlParser::T_EQUAL, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_mysql_itemContext::T_COMMENT() {
  return getToken(HplsqlParser::T_COMMENT, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_mysql_itemContext::T_CHARACTER() {
  return getToken(HplsqlParser::T_CHARACTER, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_mysql_itemContext::T_SET() {
  return getToken(HplsqlParser::T_SET, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_mysql_itemContext::T_CHARSET() {
  return getToken(HplsqlParser::T_CHARSET, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_mysql_itemContext::T_DEFAULT() {
  return getToken(HplsqlParser::T_DEFAULT, 0);
}

tree::TerminalNode* HplsqlParser::Create_table_options_mysql_itemContext::T_ENGINE() {
  return getToken(HplsqlParser::T_ENGINE, 0);
}


size_t HplsqlParser::Create_table_options_mysql_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_table_options_mysql_item;
}

void HplsqlParser::Create_table_options_mysql_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_options_mysql_item(this);
}

void HplsqlParser::Create_table_options_mysql_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_options_mysql_item(this);
}


antlrcpp::Any HplsqlParser::Create_table_options_mysql_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_table_options_mysql_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_table_options_mysql_itemContext* HplsqlParser::create_table_options_mysql_item() {
  Create_table_options_mysql_itemContext *_localctx = _tracker.createInstance<Create_table_options_mysql_itemContext>(_ctx, getState());
  enterRule(_localctx, 108, HplsqlParser::RuleCreate_table_options_mysql_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1212);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_AUTO_INCREMENT: {
        enterOuterAlt(_localctx, 1);
        setState(1185);
        match(HplsqlParser::T_AUTO_INCREMENT);
        setState(1187);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_EQUAL) {
          setState(1186);
          match(HplsqlParser::T_EQUAL);
        }
        setState(1189);
        expr(0);
        break;
      }

      case HplsqlParser::T_COMMENT: {
        enterOuterAlt(_localctx, 2);
        setState(1190);
        match(HplsqlParser::T_COMMENT);
        setState(1192);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_EQUAL) {
          setState(1191);
          match(HplsqlParser::T_EQUAL);
        }
        setState(1194);
        expr(0);
        break;
      }

      case HplsqlParser::T_CHARACTER:
      case HplsqlParser::T_CHARSET:
      case HplsqlParser::T_DEFAULT: {
        enterOuterAlt(_localctx, 3);
        setState(1196);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_DEFAULT) {
          setState(1195);
          match(HplsqlParser::T_DEFAULT);
        }
        setState(1201);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case HplsqlParser::T_CHARACTER: {
            setState(1198);
            match(HplsqlParser::T_CHARACTER);
            setState(1199);
            match(HplsqlParser::T_SET);
            break;
          }

          case HplsqlParser::T_CHARSET: {
            setState(1200);
            match(HplsqlParser::T_CHARSET);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(1204);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_EQUAL) {
          setState(1203);
          match(HplsqlParser::T_EQUAL);
        }
        setState(1206);
        expr(0);
        break;
      }

      case HplsqlParser::T_ENGINE: {
        enterOuterAlt(_localctx, 4);
        setState(1207);
        match(HplsqlParser::T_ENGINE);
        setState(1209);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_EQUAL) {
          setState(1208);
          match(HplsqlParser::T_EQUAL);
        }
        setState(1211);
        expr(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_table_stmtContext ------------------------------------------------------------------

HplsqlParser::Alter_table_stmtContext::Alter_table_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Alter_table_stmtContext::T_ALTER() {
  return getToken(HplsqlParser::T_ALTER, 0);
}

tree::TerminalNode* HplsqlParser::Alter_table_stmtContext::T_TABLE() {
  return getToken(HplsqlParser::T_TABLE, 0);
}

HplsqlParser::Table_nameContext* HplsqlParser::Alter_table_stmtContext::table_name() {
  return getRuleContext<HplsqlParser::Table_nameContext>(0);
}

HplsqlParser::Alter_table_itemContext* HplsqlParser::Alter_table_stmtContext::alter_table_item() {
  return getRuleContext<HplsqlParser::Alter_table_itemContext>(0);
}


size_t HplsqlParser::Alter_table_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleAlter_table_stmt;
}

void HplsqlParser::Alter_table_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_table_stmt(this);
}

void HplsqlParser::Alter_table_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_table_stmt(this);
}


antlrcpp::Any HplsqlParser::Alter_table_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitAlter_table_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Alter_table_stmtContext* HplsqlParser::alter_table_stmt() {
  Alter_table_stmtContext *_localctx = _tracker.createInstance<Alter_table_stmtContext>(_ctx, getState());
  enterRule(_localctx, 110, HplsqlParser::RuleAlter_table_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1214);
    match(HplsqlParser::T_ALTER);
    setState(1215);
    match(HplsqlParser::T_TABLE);
    setState(1216);
    table_name();
    setState(1217);
    alter_table_item();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_table_itemContext ------------------------------------------------------------------

HplsqlParser::Alter_table_itemContext::Alter_table_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Alter_table_add_constraintContext* HplsqlParser::Alter_table_itemContext::alter_table_add_constraint() {
  return getRuleContext<HplsqlParser::Alter_table_add_constraintContext>(0);
}


size_t HplsqlParser::Alter_table_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleAlter_table_item;
}

void HplsqlParser::Alter_table_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_table_item(this);
}

void HplsqlParser::Alter_table_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_table_item(this);
}


antlrcpp::Any HplsqlParser::Alter_table_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitAlter_table_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Alter_table_itemContext* HplsqlParser::alter_table_item() {
  Alter_table_itemContext *_localctx = _tracker.createInstance<Alter_table_itemContext>(_ctx, getState());
  enterRule(_localctx, 112, HplsqlParser::RuleAlter_table_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1219);
    alter_table_add_constraint();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_table_add_constraintContext ------------------------------------------------------------------

HplsqlParser::Alter_table_add_constraintContext::Alter_table_add_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Alter_table_add_constraintContext::T_ADD2() {
  return getToken(HplsqlParser::T_ADD2, 0);
}

HplsqlParser::Alter_table_add_constraint_itemContext* HplsqlParser::Alter_table_add_constraintContext::alter_table_add_constraint_item() {
  return getRuleContext<HplsqlParser::Alter_table_add_constraint_itemContext>(0);
}

tree::TerminalNode* HplsqlParser::Alter_table_add_constraintContext::T_CONSTRAINT() {
  return getToken(HplsqlParser::T_CONSTRAINT, 0);
}

HplsqlParser::IdentContext* HplsqlParser::Alter_table_add_constraintContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}


size_t HplsqlParser::Alter_table_add_constraintContext::getRuleIndex() const {
  return HplsqlParser::RuleAlter_table_add_constraint;
}

void HplsqlParser::Alter_table_add_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_table_add_constraint(this);
}

void HplsqlParser::Alter_table_add_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_table_add_constraint(this);
}


antlrcpp::Any HplsqlParser::Alter_table_add_constraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitAlter_table_add_constraint(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Alter_table_add_constraintContext* HplsqlParser::alter_table_add_constraint() {
  Alter_table_add_constraintContext *_localctx = _tracker.createInstance<Alter_table_add_constraintContext>(_ctx, getState());
  enterRule(_localctx, 114, HplsqlParser::RuleAlter_table_add_constraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1221);
    match(HplsqlParser::T_ADD2);
    setState(1224);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_CONSTRAINT) {
      setState(1222);
      match(HplsqlParser::T_CONSTRAINT);
      setState(1223);
      ident();
    }
    setState(1226);
    alter_table_add_constraint_item();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_table_add_constraint_itemContext ------------------------------------------------------------------

HplsqlParser::Alter_table_add_constraint_itemContext::Alter_table_add_constraint_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Alter_table_add_constraint_itemContext::T_PRIMARY() {
  return getToken(HplsqlParser::T_PRIMARY, 0);
}

tree::TerminalNode* HplsqlParser::Alter_table_add_constraint_itemContext::T_KEY() {
  return getToken(HplsqlParser::T_KEY, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Alter_table_add_constraint_itemContext::T_OPEN_P() {
  return getTokens(HplsqlParser::T_OPEN_P);
}

tree::TerminalNode* HplsqlParser::Alter_table_add_constraint_itemContext::T_OPEN_P(size_t i) {
  return getToken(HplsqlParser::T_OPEN_P, i);
}

std::vector<HplsqlParser::IdentContext *> HplsqlParser::Alter_table_add_constraint_itemContext::ident() {
  return getRuleContexts<HplsqlParser::IdentContext>();
}

HplsqlParser::IdentContext* HplsqlParser::Alter_table_add_constraint_itemContext::ident(size_t i) {
  return getRuleContext<HplsqlParser::IdentContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Alter_table_add_constraint_itemContext::T_CLOSE_P() {
  return getTokens(HplsqlParser::T_CLOSE_P);
}

tree::TerminalNode* HplsqlParser::Alter_table_add_constraint_itemContext::T_CLOSE_P(size_t i) {
  return getToken(HplsqlParser::T_CLOSE_P, i);
}

tree::TerminalNode* HplsqlParser::Alter_table_add_constraint_itemContext::T_CLUSTERED() {
  return getToken(HplsqlParser::T_CLUSTERED, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Alter_table_add_constraint_itemContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Alter_table_add_constraint_itemContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}

tree::TerminalNode* HplsqlParser::Alter_table_add_constraint_itemContext::T_ENABLE() {
  return getToken(HplsqlParser::T_ENABLE, 0);
}

HplsqlParser::Index_storage_clauseContext* HplsqlParser::Alter_table_add_constraint_itemContext::index_storage_clause() {
  return getRuleContext<HplsqlParser::Index_storage_clauseContext>(0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Alter_table_add_constraint_itemContext::T_ASC() {
  return getTokens(HplsqlParser::T_ASC);
}

tree::TerminalNode* HplsqlParser::Alter_table_add_constraint_itemContext::T_ASC(size_t i) {
  return getToken(HplsqlParser::T_ASC, i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Alter_table_add_constraint_itemContext::T_DESC() {
  return getTokens(HplsqlParser::T_DESC);
}

tree::TerminalNode* HplsqlParser::Alter_table_add_constraint_itemContext::T_DESC(size_t i) {
  return getToken(HplsqlParser::T_DESC, i);
}

tree::TerminalNode* HplsqlParser::Alter_table_add_constraint_itemContext::T_FOREIGN() {
  return getToken(HplsqlParser::T_FOREIGN, 0);
}

tree::TerminalNode* HplsqlParser::Alter_table_add_constraint_itemContext::T_REFERENCES() {
  return getToken(HplsqlParser::T_REFERENCES, 0);
}

HplsqlParser::Table_nameContext* HplsqlParser::Alter_table_add_constraint_itemContext::table_name() {
  return getRuleContext<HplsqlParser::Table_nameContext>(0);
}

std::vector<HplsqlParser::Create_table_fk_actionContext *> HplsqlParser::Alter_table_add_constraint_itemContext::create_table_fk_action() {
  return getRuleContexts<HplsqlParser::Create_table_fk_actionContext>();
}

HplsqlParser::Create_table_fk_actionContext* HplsqlParser::Alter_table_add_constraint_itemContext::create_table_fk_action(size_t i) {
  return getRuleContext<HplsqlParser::Create_table_fk_actionContext>(i);
}

tree::TerminalNode* HplsqlParser::Alter_table_add_constraint_itemContext::T_DEFAULT() {
  return getToken(HplsqlParser::T_DEFAULT, 0);
}

HplsqlParser::ExprContext* HplsqlParser::Alter_table_add_constraint_itemContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}

tree::TerminalNode* HplsqlParser::Alter_table_add_constraint_itemContext::T_FOR() {
  return getToken(HplsqlParser::T_FOR, 0);
}


size_t HplsqlParser::Alter_table_add_constraint_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleAlter_table_add_constraint_item;
}

void HplsqlParser::Alter_table_add_constraint_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_table_add_constraint_item(this);
}

void HplsqlParser::Alter_table_add_constraint_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_table_add_constraint_item(this);
}


antlrcpp::Any HplsqlParser::Alter_table_add_constraint_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitAlter_table_add_constraint_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Alter_table_add_constraint_itemContext* HplsqlParser::alter_table_add_constraint_item() {
  Alter_table_add_constraint_itemContext *_localctx = _tracker.createInstance<Alter_table_add_constraint_itemContext>(_ctx, getState());
  enterRule(_localctx, 116, HplsqlParser::RuleAlter_table_add_constraint_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1290);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_PRIMARY: {
        enterOuterAlt(_localctx, 1);
        setState(1228);
        match(HplsqlParser::T_PRIMARY);
        setState(1229);
        match(HplsqlParser::T_KEY);
        setState(1231);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_CLUSTERED) {
          setState(1230);
          match(HplsqlParser::T_CLUSTERED);
        }
        setState(1233);
        match(HplsqlParser::T_OPEN_P);
        setState(1234);
        ident();
        setState(1236);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_ASC || _la == HplsqlParser::T_DESC) {
          setState(1235);
          _la = _input->LA(1);
          if (!(_la == HplsqlParser::T_ASC || _la == HplsqlParser::T_DESC)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(1245);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == HplsqlParser::T_COMMA) {
          setState(1238);
          match(HplsqlParser::T_COMMA);
          setState(1239);
          ident();
          setState(1241);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == HplsqlParser::T_ASC || _la == HplsqlParser::T_DESC) {
            setState(1240);
            _la = _input->LA(1);
            if (!(_la == HplsqlParser::T_ASC || _la == HplsqlParser::T_DESC)) {
            _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
          }
          setState(1247);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1248);
        match(HplsqlParser::T_CLOSE_P);
        setState(1250);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 113, _ctx)) {
        case 1: {
          setState(1249);
          match(HplsqlParser::T_ENABLE);
          break;
        }

        default:
          break;
        }
        setState(1253);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx)) {
        case 1: {
          setState(1252);
          index_storage_clause();
          break;
        }

        default:
          break;
        }
        break;
      }

      case HplsqlParser::T_FOREIGN: {
        enterOuterAlt(_localctx, 2);
        setState(1255);
        match(HplsqlParser::T_FOREIGN);
        setState(1256);
        match(HplsqlParser::T_KEY);
        setState(1257);
        match(HplsqlParser::T_OPEN_P);
        setState(1258);
        ident();
        setState(1263);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == HplsqlParser::T_COMMA) {
          setState(1259);
          match(HplsqlParser::T_COMMA);
          setState(1260);
          ident();
          setState(1265);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1266);
        match(HplsqlParser::T_CLOSE_P);
        setState(1267);
        match(HplsqlParser::T_REFERENCES);
        setState(1268);
        table_name();
        setState(1269);
        match(HplsqlParser::T_OPEN_P);
        setState(1270);
        ident();
        setState(1275);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == HplsqlParser::T_COMMA) {
          setState(1271);
          match(HplsqlParser::T_COMMA);
          setState(1272);
          ident();
          setState(1277);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1278);
        match(HplsqlParser::T_CLOSE_P);
        setState(1282);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1279);
            create_table_fk_action(); 
          }
          setState(1284);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx);
        }
        break;
      }

      case HplsqlParser::T_DEFAULT: {
        enterOuterAlt(_localctx, 3);
        setState(1285);
        match(HplsqlParser::T_DEFAULT);
        setState(1286);
        expr(0);
        setState(1287);
        match(HplsqlParser::T_FOR);
        setState(1288);
        ident();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DtypeContext ------------------------------------------------------------------

HplsqlParser::DtypeContext::DtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_CHAR() {
  return getToken(HplsqlParser::T_CHAR, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_BIGINT() {
  return getToken(HplsqlParser::T_BIGINT, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_BINARY_DOUBLE() {
  return getToken(HplsqlParser::T_BINARY_DOUBLE, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_BINARY_FLOAT() {
  return getToken(HplsqlParser::T_BINARY_FLOAT, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_BINARY_INTEGER() {
  return getToken(HplsqlParser::T_BINARY_INTEGER, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_BIT() {
  return getToken(HplsqlParser::T_BIT, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_DATE() {
  return getToken(HplsqlParser::T_DATE, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_DATETIME() {
  return getToken(HplsqlParser::T_DATETIME, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_DEC() {
  return getToken(HplsqlParser::T_DEC, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_DECIMAL() {
  return getToken(HplsqlParser::T_DECIMAL, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_DOUBLE() {
  return getToken(HplsqlParser::T_DOUBLE, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_PRECISION() {
  return getToken(HplsqlParser::T_PRECISION, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_FLOAT() {
  return getToken(HplsqlParser::T_FLOAT, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_INT() {
  return getToken(HplsqlParser::T_INT, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_INT2() {
  return getToken(HplsqlParser::T_INT2, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_INT4() {
  return getToken(HplsqlParser::T_INT4, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_INT8() {
  return getToken(HplsqlParser::T_INT8, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_INTEGER() {
  return getToken(HplsqlParser::T_INTEGER, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_NCHAR() {
  return getToken(HplsqlParser::T_NCHAR, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_NVARCHAR() {
  return getToken(HplsqlParser::T_NVARCHAR, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_NUMBER() {
  return getToken(HplsqlParser::T_NUMBER, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_NUMERIC() {
  return getToken(HplsqlParser::T_NUMERIC, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_PLS_INTEGER() {
  return getToken(HplsqlParser::T_PLS_INTEGER, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_REAL() {
  return getToken(HplsqlParser::T_REAL, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_RESULT_SET_LOCATOR() {
  return getToken(HplsqlParser::T_RESULT_SET_LOCATOR, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_VARYING() {
  return getToken(HplsqlParser::T_VARYING, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_SIMPLE_FLOAT() {
  return getToken(HplsqlParser::T_SIMPLE_FLOAT, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_SIMPLE_DOUBLE() {
  return getToken(HplsqlParser::T_SIMPLE_DOUBLE, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_SIMPLE_INTEGER() {
  return getToken(HplsqlParser::T_SIMPLE_INTEGER, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_SMALLINT() {
  return getToken(HplsqlParser::T_SMALLINT, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_SMALLDATETIME() {
  return getToken(HplsqlParser::T_SMALLDATETIME, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_STRING() {
  return getToken(HplsqlParser::T_STRING, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_SYS_REFCURSOR() {
  return getToken(HplsqlParser::T_SYS_REFCURSOR, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_TIMESTAMP() {
  return getToken(HplsqlParser::T_TIMESTAMP, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_TINYINT() {
  return getToken(HplsqlParser::T_TINYINT, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_VARCHAR() {
  return getToken(HplsqlParser::T_VARCHAR, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_VARCHAR2() {
  return getToken(HplsqlParser::T_VARCHAR2, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_XML() {
  return getToken(HplsqlParser::T_XML, 0);
}

HplsqlParser::IdentContext* HplsqlParser::DtypeContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_TYPE() {
  return getToken(HplsqlParser::T_TYPE, 0);
}

tree::TerminalNode* HplsqlParser::DtypeContext::T_ROWTYPE() {
  return getToken(HplsqlParser::T_ROWTYPE, 0);
}


size_t HplsqlParser::DtypeContext::getRuleIndex() const {
  return HplsqlParser::RuleDtype;
}

void HplsqlParser::DtypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDtype(this);
}

void HplsqlParser::DtypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDtype(this);
}


antlrcpp::Any HplsqlParser::DtypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitDtype(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::DtypeContext* HplsqlParser::dtype() {
  DtypeContext *_localctx = _tracker.createInstance<DtypeContext>(_ctx, getState());
  enterRule(_localctx, 118, HplsqlParser::RuleDtype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1337);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1292);
      match(HplsqlParser::T_CHAR);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1293);
      match(HplsqlParser::T_BIGINT);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1294);
      match(HplsqlParser::T_BINARY_DOUBLE);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1295);
      match(HplsqlParser::T_BINARY_FLOAT);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1296);
      match(HplsqlParser::T_BINARY_INTEGER);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1297);
      match(HplsqlParser::T_BIT);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1298);
      match(HplsqlParser::T_DATE);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1299);
      match(HplsqlParser::T_DATETIME);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1300);
      match(HplsqlParser::T_DEC);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1301);
      match(HplsqlParser::T_DECIMAL);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1302);
      match(HplsqlParser::T_DOUBLE);
      setState(1304);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 119, _ctx)) {
      case 1: {
        setState(1303);
        match(HplsqlParser::T_PRECISION);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(1306);
      match(HplsqlParser::T_FLOAT);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(1307);
      match(HplsqlParser::T_INT);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(1308);
      match(HplsqlParser::T_INT2);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(1309);
      match(HplsqlParser::T_INT4);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(1310);
      match(HplsqlParser::T_INT8);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(1311);
      match(HplsqlParser::T_INTEGER);
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(1312);
      match(HplsqlParser::T_NCHAR);
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(1313);
      match(HplsqlParser::T_NVARCHAR);
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(1314);
      match(HplsqlParser::T_NUMBER);
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(1315);
      match(HplsqlParser::T_NUMERIC);
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(1316);
      match(HplsqlParser::T_PLS_INTEGER);
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(1317);
      match(HplsqlParser::T_REAL);
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(1318);
      match(HplsqlParser::T_RESULT_SET_LOCATOR);
      setState(1319);
      match(HplsqlParser::T_VARYING);
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(1320);
      match(HplsqlParser::T_SIMPLE_FLOAT);
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(1321);
      match(HplsqlParser::T_SIMPLE_DOUBLE);
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(1322);
      match(HplsqlParser::T_SIMPLE_INTEGER);
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(1323);
      match(HplsqlParser::T_SMALLINT);
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(1324);
      match(HplsqlParser::T_SMALLDATETIME);
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(1325);
      match(HplsqlParser::T_STRING);
      break;
    }

    case 31: {
      enterOuterAlt(_localctx, 31);
      setState(1326);
      match(HplsqlParser::T_SYS_REFCURSOR);
      break;
    }

    case 32: {
      enterOuterAlt(_localctx, 32);
      setState(1327);
      match(HplsqlParser::T_TIMESTAMP);
      break;
    }

    case 33: {
      enterOuterAlt(_localctx, 33);
      setState(1328);
      match(HplsqlParser::T_TINYINT);
      break;
    }

    case 34: {
      enterOuterAlt(_localctx, 34);
      setState(1329);
      match(HplsqlParser::T_VARCHAR);
      break;
    }

    case 35: {
      enterOuterAlt(_localctx, 35);
      setState(1330);
      match(HplsqlParser::T_VARCHAR2);
      break;
    }

    case 36: {
      enterOuterAlt(_localctx, 36);
      setState(1331);
      match(HplsqlParser::T_XML);
      break;
    }

    case 37: {
      enterOuterAlt(_localctx, 37);
      setState(1332);
      ident();
      setState(1335);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx)) {
      case 1: {
        setState(1333);
        match(HplsqlParser::T__2);
        setState(1334);
        _la = _input->LA(1);
        if (!(_la == HplsqlParser::T_ROWTYPE

        || _la == HplsqlParser::T_TYPE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dtype_lenContext ------------------------------------------------------------------

HplsqlParser::Dtype_lenContext::Dtype_lenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Dtype_lenContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

tree::TerminalNode* HplsqlParser::Dtype_lenContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Dtype_lenContext::L_INT() {
  return getTokens(HplsqlParser::L_INT);
}

tree::TerminalNode* HplsqlParser::Dtype_lenContext::L_INT(size_t i) {
  return getToken(HplsqlParser::L_INT, i);
}

tree::TerminalNode* HplsqlParser::Dtype_lenContext::T_MAX() {
  return getToken(HplsqlParser::T_MAX, 0);
}

tree::TerminalNode* HplsqlParser::Dtype_lenContext::T_COMMA() {
  return getToken(HplsqlParser::T_COMMA, 0);
}

tree::TerminalNode* HplsqlParser::Dtype_lenContext::T_CHAR() {
  return getToken(HplsqlParser::T_CHAR, 0);
}

tree::TerminalNode* HplsqlParser::Dtype_lenContext::T_BYTE() {
  return getToken(HplsqlParser::T_BYTE, 0);
}


size_t HplsqlParser::Dtype_lenContext::getRuleIndex() const {
  return HplsqlParser::RuleDtype_len;
}

void HplsqlParser::Dtype_lenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDtype_len(this);
}

void HplsqlParser::Dtype_lenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDtype_len(this);
}


antlrcpp::Any HplsqlParser::Dtype_lenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitDtype_len(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Dtype_lenContext* HplsqlParser::dtype_len() {
  Dtype_lenContext *_localctx = _tracker.createInstance<Dtype_lenContext>(_ctx, getState());
  enterRule(_localctx, 120, HplsqlParser::RuleDtype_len);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1339);
    match(HplsqlParser::T_OPEN_P);
    setState(1340);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_MAX || _la == HplsqlParser::L_INT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1342);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_BYTE

    || _la == HplsqlParser::T_CHAR) {
      setState(1341);
      _la = _input->LA(1);
      if (!(_la == HplsqlParser::T_BYTE

      || _la == HplsqlParser::T_CHAR)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1346);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_COMMA) {
      setState(1344);
      match(HplsqlParser::T_COMMA);
      setState(1345);
      match(HplsqlParser::L_INT);
    }
    setState(1348);
    match(HplsqlParser::T_CLOSE_P);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dtype_attrContext ------------------------------------------------------------------

HplsqlParser::Dtype_attrContext::Dtype_attrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Dtype_attrContext::T_NULL() {
  return getToken(HplsqlParser::T_NULL, 0);
}

tree::TerminalNode* HplsqlParser::Dtype_attrContext::T_NOT() {
  return getToken(HplsqlParser::T_NOT, 0);
}

tree::TerminalNode* HplsqlParser::Dtype_attrContext::T_CHARACTER() {
  return getToken(HplsqlParser::T_CHARACTER, 0);
}

tree::TerminalNode* HplsqlParser::Dtype_attrContext::T_SET() {
  return getToken(HplsqlParser::T_SET, 0);
}

HplsqlParser::IdentContext* HplsqlParser::Dtype_attrContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

tree::TerminalNode* HplsqlParser::Dtype_attrContext::T_CASESPECIFIC() {
  return getToken(HplsqlParser::T_CASESPECIFIC, 0);
}

tree::TerminalNode* HplsqlParser::Dtype_attrContext::T_CS() {
  return getToken(HplsqlParser::T_CS, 0);
}


size_t HplsqlParser::Dtype_attrContext::getRuleIndex() const {
  return HplsqlParser::RuleDtype_attr;
}

void HplsqlParser::Dtype_attrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDtype_attr(this);
}

void HplsqlParser::Dtype_attrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDtype_attr(this);
}


antlrcpp::Any HplsqlParser::Dtype_attrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitDtype_attr(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Dtype_attrContext* HplsqlParser::dtype_attr() {
  Dtype_attrContext *_localctx = _tracker.createInstance<Dtype_attrContext>(_ctx, getState());
  enterRule(_localctx, 122, HplsqlParser::RuleDtype_attr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1361);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 126, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1351);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HplsqlParser::T_NOT) {
        setState(1350);
        match(HplsqlParser::T_NOT);
      }
      setState(1353);
      match(HplsqlParser::T_NULL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1354);
      match(HplsqlParser::T_CHARACTER);
      setState(1355);
      match(HplsqlParser::T_SET);
      setState(1356);
      ident();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1358);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HplsqlParser::T_NOT) {
        setState(1357);
        match(HplsqlParser::T_NOT);
      }
      setState(1360);
      _la = _input->LA(1);
      if (!(_la == HplsqlParser::T_CASESPECIFIC

      || _la == HplsqlParser::T_CS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dtype_defaultContext ------------------------------------------------------------------

HplsqlParser::Dtype_defaultContext::Dtype_defaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Dtype_defaultContext::T_EQUAL() {
  return getToken(HplsqlParser::T_EQUAL, 0);
}

HplsqlParser::ExprContext* HplsqlParser::Dtype_defaultContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}

tree::TerminalNode* HplsqlParser::Dtype_defaultContext::T_COLON() {
  return getToken(HplsqlParser::T_COLON, 0);
}

tree::TerminalNode* HplsqlParser::Dtype_defaultContext::T_DEFAULT() {
  return getToken(HplsqlParser::T_DEFAULT, 0);
}

tree::TerminalNode* HplsqlParser::Dtype_defaultContext::T_WITH() {
  return getToken(HplsqlParser::T_WITH, 0);
}


size_t HplsqlParser::Dtype_defaultContext::getRuleIndex() const {
  return HplsqlParser::RuleDtype_default;
}

void HplsqlParser::Dtype_defaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDtype_default(this);
}

void HplsqlParser::Dtype_defaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDtype_default(this);
}


antlrcpp::Any HplsqlParser::Dtype_defaultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitDtype_default(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Dtype_defaultContext* HplsqlParser::dtype_default() {
  Dtype_defaultContext *_localctx = _tracker.createInstance<Dtype_defaultContext>(_ctx, getState());
  enterRule(_localctx, 124, HplsqlParser::RuleDtype_default);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1375);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_COLON:
      case HplsqlParser::T_EQUAL: {
        enterOuterAlt(_localctx, 1);
        setState(1364);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_COLON) {
          setState(1363);
          match(HplsqlParser::T_COLON);
        }
        setState(1366);
        match(HplsqlParser::T_EQUAL);
        setState(1367);
        expr(0);
        break;
      }

      case HplsqlParser::T_DEFAULT:
      case HplsqlParser::T_WITH: {
        enterOuterAlt(_localctx, 2);
        setState(1369);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_WITH) {
          setState(1368);
          match(HplsqlParser::T_WITH);
        }
        setState(1371);
        match(HplsqlParser::T_DEFAULT);
        setState(1373);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 129, _ctx)) {
        case 1: {
          setState(1372);
          expr(0);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_database_stmtContext ------------------------------------------------------------------

HplsqlParser::Create_database_stmtContext::Create_database_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_database_stmtContext::T_CREATE() {
  return getToken(HplsqlParser::T_CREATE, 0);
}

HplsqlParser::ExprContext* HplsqlParser::Create_database_stmtContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_database_stmtContext::T_DATABASE() {
  return getToken(HplsqlParser::T_DATABASE, 0);
}

tree::TerminalNode* HplsqlParser::Create_database_stmtContext::T_SCHEMA() {
  return getToken(HplsqlParser::T_SCHEMA, 0);
}

tree::TerminalNode* HplsqlParser::Create_database_stmtContext::T_IF() {
  return getToken(HplsqlParser::T_IF, 0);
}

tree::TerminalNode* HplsqlParser::Create_database_stmtContext::T_NOT() {
  return getToken(HplsqlParser::T_NOT, 0);
}

tree::TerminalNode* HplsqlParser::Create_database_stmtContext::T_EXISTS() {
  return getToken(HplsqlParser::T_EXISTS, 0);
}

std::vector<HplsqlParser::Create_database_optionContext *> HplsqlParser::Create_database_stmtContext::create_database_option() {
  return getRuleContexts<HplsqlParser::Create_database_optionContext>();
}

HplsqlParser::Create_database_optionContext* HplsqlParser::Create_database_stmtContext::create_database_option(size_t i) {
  return getRuleContext<HplsqlParser::Create_database_optionContext>(i);
}


size_t HplsqlParser::Create_database_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_database_stmt;
}

void HplsqlParser::Create_database_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_database_stmt(this);
}

void HplsqlParser::Create_database_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_database_stmt(this);
}


antlrcpp::Any HplsqlParser::Create_database_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_database_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_database_stmtContext* HplsqlParser::create_database_stmt() {
  Create_database_stmtContext *_localctx = _tracker.createInstance<Create_database_stmtContext>(_ctx, getState());
  enterRule(_localctx, 126, HplsqlParser::RuleCreate_database_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1377);
    match(HplsqlParser::T_CREATE);
    setState(1378);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_DATABASE || _la == HplsqlParser::T_SCHEMA)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1382);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 131, _ctx)) {
    case 1: {
      setState(1379);
      match(HplsqlParser::T_IF);
      setState(1380);
      match(HplsqlParser::T_NOT);
      setState(1381);
      match(HplsqlParser::T_EXISTS);
      break;
    }

    default:
      break;
    }
    setState(1384);
    expr(0);
    setState(1388);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1385);
        create_database_option(); 
      }
      setState(1390);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_database_optionContext ------------------------------------------------------------------

HplsqlParser::Create_database_optionContext::Create_database_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_database_optionContext::T_COMMENT() {
  return getToken(HplsqlParser::T_COMMENT, 0);
}

HplsqlParser::ExprContext* HplsqlParser::Create_database_optionContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_database_optionContext::T_LOCATION() {
  return getToken(HplsqlParser::T_LOCATION, 0);
}


size_t HplsqlParser::Create_database_optionContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_database_option;
}

void HplsqlParser::Create_database_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_database_option(this);
}

void HplsqlParser::Create_database_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_database_option(this);
}


antlrcpp::Any HplsqlParser::Create_database_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_database_option(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_database_optionContext* HplsqlParser::create_database_option() {
  Create_database_optionContext *_localctx = _tracker.createInstance<Create_database_optionContext>(_ctx, getState());
  enterRule(_localctx, 128, HplsqlParser::RuleCreate_database_option);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1395);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_COMMENT: {
        enterOuterAlt(_localctx, 1);
        setState(1391);
        match(HplsqlParser::T_COMMENT);
        setState(1392);
        expr(0);
        break;
      }

      case HplsqlParser::T_LOCATION: {
        enterOuterAlt(_localctx, 2);
        setState(1393);
        match(HplsqlParser::T_LOCATION);
        setState(1394);
        expr(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_function_stmtContext ------------------------------------------------------------------

HplsqlParser::Create_function_stmtContext::Create_function_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_function_stmtContext::T_FUNCTION() {
  return getToken(HplsqlParser::T_FUNCTION, 0);
}

HplsqlParser::IdentContext* HplsqlParser::Create_function_stmtContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

HplsqlParser::Create_function_returnContext* HplsqlParser::Create_function_stmtContext::create_function_return() {
  return getRuleContext<HplsqlParser::Create_function_returnContext>(0);
}

HplsqlParser::Single_block_stmtContext* HplsqlParser::Create_function_stmtContext::single_block_stmt() {
  return getRuleContext<HplsqlParser::Single_block_stmtContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_function_stmtContext::T_ALTER() {
  return getToken(HplsqlParser::T_ALTER, 0);
}

tree::TerminalNode* HplsqlParser::Create_function_stmtContext::T_CREATE() {
  return getToken(HplsqlParser::T_CREATE, 0);
}

tree::TerminalNode* HplsqlParser::Create_function_stmtContext::T_REPLACE() {
  return getToken(HplsqlParser::T_REPLACE, 0);
}

HplsqlParser::Create_routine_paramsContext* HplsqlParser::Create_function_stmtContext::create_routine_params() {
  return getRuleContext<HplsqlParser::Create_routine_paramsContext>(0);
}

HplsqlParser::Declare_block_inplaceContext* HplsqlParser::Create_function_stmtContext::declare_block_inplace() {
  return getRuleContext<HplsqlParser::Declare_block_inplaceContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_function_stmtContext::T_AS() {
  return getToken(HplsqlParser::T_AS, 0);
}

tree::TerminalNode* HplsqlParser::Create_function_stmtContext::T_IS() {
  return getToken(HplsqlParser::T_IS, 0);
}

tree::TerminalNode* HplsqlParser::Create_function_stmtContext::T_OR() {
  return getToken(HplsqlParser::T_OR, 0);
}


size_t HplsqlParser::Create_function_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_function_stmt;
}

void HplsqlParser::Create_function_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_function_stmt(this);
}

void HplsqlParser::Create_function_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_function_stmt(this);
}


antlrcpp::Any HplsqlParser::Create_function_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_function_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_function_stmtContext* HplsqlParser::create_function_stmt() {
  Create_function_stmtContext *_localctx = _tracker.createInstance<Create_function_stmtContext>(_ctx, getState());
  enterRule(_localctx, 130, HplsqlParser::RuleCreate_function_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1404);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_ALTER: {
        setState(1397);
        match(HplsqlParser::T_ALTER);
        break;
      }

      case HplsqlParser::T_CREATE: {
        setState(1398);
        match(HplsqlParser::T_CREATE);
        setState(1401);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_OR) {
          setState(1399);
          match(HplsqlParser::T_OR);
          setState(1400);
          match(HplsqlParser::T_REPLACE);
        }
        break;
      }

      case HplsqlParser::T_REPLACE: {
        setState(1403);
        match(HplsqlParser::T_REPLACE);
        break;
      }

      case HplsqlParser::T_FUNCTION: {
        break;
      }

    default:
      break;
    }
    setState(1406);
    match(HplsqlParser::T_FUNCTION);
    setState(1407);
    ident();
    setState(1409);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 136, _ctx)) {
    case 1: {
      setState(1408);
      create_routine_params();
      break;
    }

    default:
      break;
    }
    setState(1411);
    create_function_return();
    setState(1413);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 137, _ctx)) {
    case 1: {
      setState(1412);
      _la = _input->LA(1);
      if (!(_la == HplsqlParser::T_AS || _la == HplsqlParser::T_IS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
    setState(1416);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 138, _ctx)) {
    case 1: {
      setState(1415);
      declare_block_inplace();
      break;
    }

    default:
      break;
    }
    setState(1418);
    single_block_stmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_function_returnContext ------------------------------------------------------------------

HplsqlParser::Create_function_returnContext::Create_function_returnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::DtypeContext* HplsqlParser::Create_function_returnContext::dtype() {
  return getRuleContext<HplsqlParser::DtypeContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_function_returnContext::T_RETURN() {
  return getToken(HplsqlParser::T_RETURN, 0);
}

tree::TerminalNode* HplsqlParser::Create_function_returnContext::T_RETURNS() {
  return getToken(HplsqlParser::T_RETURNS, 0);
}

HplsqlParser::Dtype_lenContext* HplsqlParser::Create_function_returnContext::dtype_len() {
  return getRuleContext<HplsqlParser::Dtype_lenContext>(0);
}


size_t HplsqlParser::Create_function_returnContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_function_return;
}

void HplsqlParser::Create_function_returnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_function_return(this);
}

void HplsqlParser::Create_function_returnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_function_return(this);
}


antlrcpp::Any HplsqlParser::Create_function_returnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_function_return(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_function_returnContext* HplsqlParser::create_function_return() {
  Create_function_returnContext *_localctx = _tracker.createInstance<Create_function_returnContext>(_ctx, getState());
  enterRule(_localctx, 132, HplsqlParser::RuleCreate_function_return);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1420);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_RETURN

    || _la == HplsqlParser::T_RETURNS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1421);
    dtype();
    setState(1423);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 139, _ctx)) {
    case 1: {
      setState(1422);
      dtype_len();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_package_stmtContext ------------------------------------------------------------------

HplsqlParser::Create_package_stmtContext::Create_package_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_package_stmtContext::T_PACKAGE() {
  return getToken(HplsqlParser::T_PACKAGE, 0);
}

std::vector<HplsqlParser::IdentContext *> HplsqlParser::Create_package_stmtContext::ident() {
  return getRuleContexts<HplsqlParser::IdentContext>();
}

HplsqlParser::IdentContext* HplsqlParser::Create_package_stmtContext::ident(size_t i) {
  return getRuleContext<HplsqlParser::IdentContext>(i);
}

HplsqlParser::Package_specContext* HplsqlParser::Create_package_stmtContext::package_spec() {
  return getRuleContext<HplsqlParser::Package_specContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_package_stmtContext::T_END() {
  return getToken(HplsqlParser::T_END, 0);
}

tree::TerminalNode* HplsqlParser::Create_package_stmtContext::T_AS() {
  return getToken(HplsqlParser::T_AS, 0);
}

tree::TerminalNode* HplsqlParser::Create_package_stmtContext::T_IS() {
  return getToken(HplsqlParser::T_IS, 0);
}

tree::TerminalNode* HplsqlParser::Create_package_stmtContext::T_ALTER() {
  return getToken(HplsqlParser::T_ALTER, 0);
}

tree::TerminalNode* HplsqlParser::Create_package_stmtContext::T_CREATE() {
  return getToken(HplsqlParser::T_CREATE, 0);
}

tree::TerminalNode* HplsqlParser::Create_package_stmtContext::T_REPLACE() {
  return getToken(HplsqlParser::T_REPLACE, 0);
}

tree::TerminalNode* HplsqlParser::Create_package_stmtContext::T_SEMICOLON() {
  return getToken(HplsqlParser::T_SEMICOLON, 0);
}

tree::TerminalNode* HplsqlParser::Create_package_stmtContext::T_OR() {
  return getToken(HplsqlParser::T_OR, 0);
}


size_t HplsqlParser::Create_package_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_package_stmt;
}

void HplsqlParser::Create_package_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_package_stmt(this);
}

void HplsqlParser::Create_package_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_package_stmt(this);
}


antlrcpp::Any HplsqlParser::Create_package_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_package_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_package_stmtContext* HplsqlParser::create_package_stmt() {
  Create_package_stmtContext *_localctx = _tracker.createInstance<Create_package_stmtContext>(_ctx, getState());
  enterRule(_localctx, 134, HplsqlParser::RuleCreate_package_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1432);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_ALTER: {
        setState(1425);
        match(HplsqlParser::T_ALTER);
        break;
      }

      case HplsqlParser::T_CREATE: {
        setState(1426);
        match(HplsqlParser::T_CREATE);
        setState(1429);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_OR) {
          setState(1427);
          match(HplsqlParser::T_OR);
          setState(1428);
          match(HplsqlParser::T_REPLACE);
        }
        break;
      }

      case HplsqlParser::T_REPLACE: {
        setState(1431);
        match(HplsqlParser::T_REPLACE);
        break;
      }

      case HplsqlParser::T_PACKAGE: {
        break;
      }

    default:
      break;
    }
    setState(1434);
    match(HplsqlParser::T_PACKAGE);
    setState(1435);
    ident();
    setState(1436);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_AS || _la == HplsqlParser::T_IS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1437);
    package_spec();
    setState(1438);
    match(HplsqlParser::T_END);
    setState(1442);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 142, _ctx)) {
    case 1: {
      setState(1439);
      ident();
      setState(1440);
      match(HplsqlParser::T_SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Package_specContext ------------------------------------------------------------------

HplsqlParser::Package_specContext::Package_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HplsqlParser::Package_spec_itemContext *> HplsqlParser::Package_specContext::package_spec_item() {
  return getRuleContexts<HplsqlParser::Package_spec_itemContext>();
}

HplsqlParser::Package_spec_itemContext* HplsqlParser::Package_specContext::package_spec_item(size_t i) {
  return getRuleContext<HplsqlParser::Package_spec_itemContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Package_specContext::T_SEMICOLON() {
  return getTokens(HplsqlParser::T_SEMICOLON);
}

tree::TerminalNode* HplsqlParser::Package_specContext::T_SEMICOLON(size_t i) {
  return getToken(HplsqlParser::T_SEMICOLON, i);
}


size_t HplsqlParser::Package_specContext::getRuleIndex() const {
  return HplsqlParser::RulePackage_spec;
}

void HplsqlParser::Package_specContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPackage_spec(this);
}

void HplsqlParser::Package_specContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPackage_spec(this);
}


antlrcpp::Any HplsqlParser::Package_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitPackage_spec(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Package_specContext* HplsqlParser::package_spec() {
  Package_specContext *_localctx = _tracker.createInstance<Package_specContext>(_ctx, getState());
  enterRule(_localctx, 136, HplsqlParser::RulePackage_spec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1444);
    package_spec_item();
    setState(1445);
    match(HplsqlParser::T_SEMICOLON);
    setState(1451);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << HplsqlParser::T_ACTION)
      | (1ULL << HplsqlParser::T_ADD2)
      | (1ULL << HplsqlParser::T_ALL)
      | (1ULL << HplsqlParser::T_ALLOCATE)
      | (1ULL << HplsqlParser::T_ALTER)
      | (1ULL << HplsqlParser::T_AND)
      | (1ULL << HplsqlParser::T_ANSI_NULLS)
      | (1ULL << HplsqlParser::T_ANSI_PADDING)
      | (1ULL << HplsqlParser::T_AS)
      | (1ULL << HplsqlParser::T_ASC)
      | (1ULL << HplsqlParser::T_ASSOCIATE)
      | (1ULL << HplsqlParser::T_AT)
      | (1ULL << HplsqlParser::T_AUTO_INCREMENT)
      | (1ULL << HplsqlParser::T_AVG)
      | (1ULL << HplsqlParser::T_BATCHSIZE)
      | (1ULL << HplsqlParser::T_BEGIN)
      | (1ULL << HplsqlParser::T_BETWEEN)
      | (1ULL << HplsqlParser::T_BIGINT)
      | (1ULL << HplsqlParser::T_BINARY_DOUBLE)
      | (1ULL << HplsqlParser::T_BINARY_FLOAT)
      | (1ULL << HplsqlParser::T_BIT)
      | (1ULL << HplsqlParser::T_BODY)
      | (1ULL << HplsqlParser::T_BREAK)
      | (1ULL << HplsqlParser::T_BY)
      | (1ULL << HplsqlParser::T_BYTE)
      | (1ULL << HplsqlParser::T_CALL)
      | (1ULL << HplsqlParser::T_CALLER)
      | (1ULL << HplsqlParser::T_CASCADE)
      | (1ULL << HplsqlParser::T_CASE)
      | (1ULL << HplsqlParser::T_CASESPECIFIC)
      | (1ULL << HplsqlParser::T_CAST)
      | (1ULL << HplsqlParser::T_CHAR)
      | (1ULL << HplsqlParser::T_CHARACTER)
      | (1ULL << HplsqlParser::T_CHARSET)
      | (1ULL << HplsqlParser::T_CLIENT)
      | (1ULL << HplsqlParser::T_CLOSE)
      | (1ULL << HplsqlParser::T_CLUSTERED)
      | (1ULL << HplsqlParser::T_CMP)
      | (1ULL << HplsqlParser::T_COLLECT)
      | (1ULL << HplsqlParser::T_COLLECTION)
      | (1ULL << HplsqlParser::T_COLUMN)
      | (1ULL << HplsqlParser::T_COMMENT)
      | (1ULL << HplsqlParser::T_CONSTANT)
      | (1ULL << HplsqlParser::T_COMMIT)
      | (1ULL << HplsqlParser::T_COMPRESS)
      | (1ULL << HplsqlParser::T_CONCAT)
      | (1ULL << HplsqlParser::T_CONDITION)
      | (1ULL << HplsqlParser::T_CONSTRAINT)
      | (1ULL << HplsqlParser::T_CONTINUE)
      | (1ULL << HplsqlParser::T_COPY)
      | (1ULL << HplsqlParser::T_COUNT)
      | (1ULL << HplsqlParser::T_COUNT_BIG)
      | (1ULL << HplsqlParser::T_CREATE)
      | (1ULL << HplsqlParser::T_CREATION)
      | (1ULL << HplsqlParser::T_CREATOR)
      | (1ULL << HplsqlParser::T_CS)
      | (1ULL << HplsqlParser::T_CURRENT))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (HplsqlParser::T_CURRENT_SCHEMA - 64))
      | (1ULL << (HplsqlParser::T_CURSOR - 64))
      | (1ULL << (HplsqlParser::T_DATABASE - 64))
      | (1ULL << (HplsqlParser::T_DATA - 64))
      | (1ULL << (HplsqlParser::T_DATE - 64))
      | (1ULL << (HplsqlParser::T_DATETIME - 64))
      | (1ULL << (HplsqlParser::T_DAY - 64))
      | (1ULL << (HplsqlParser::T_DAYS - 64))
      | (1ULL << (HplsqlParser::T_DEC - 64))
      | (1ULL << (HplsqlParser::T_DECIMAL - 64))
      | (1ULL << (HplsqlParser::T_DECLARE - 64))
      | (1ULL << (HplsqlParser::T_DEFAULT - 64))
      | (1ULL << (HplsqlParser::T_DEFERRED - 64))
      | (1ULL << (HplsqlParser::T_DEFINED - 64))
      | (1ULL << (HplsqlParser::T_DEFINER - 64))
      | (1ULL << (HplsqlParser::T_DEFINITION - 64))
      | (1ULL << (HplsqlParser::T_DELETE - 64))
      | (1ULL << (HplsqlParser::T_DELIMITED - 64))
      | (1ULL << (HplsqlParser::T_DELIMITER - 64))
      | (1ULL << (HplsqlParser::T_DESC - 64))
      | (1ULL << (HplsqlParser::T_DESCRIBE - 64))
      | (1ULL << (HplsqlParser::T_DIAGNOSTICS - 64))
      | (1ULL << (HplsqlParser::T_DIR - 64))
      | (1ULL << (HplsqlParser::T_DIRECTORY - 64))
      | (1ULL << (HplsqlParser::T_DISTINCT - 64))
      | (1ULL << (HplsqlParser::T_DISTRIBUTE - 64))
      | (1ULL << (HplsqlParser::T_DO - 64))
      | (1ULL << (HplsqlParser::T_DOUBLE - 64))
      | (1ULL << (HplsqlParser::T_DROP - 64))
      | (1ULL << (HplsqlParser::T_DYNAMIC - 64))
      | (1ULL << (HplsqlParser::T_ENABLE - 64))
      | (1ULL << (HplsqlParser::T_ENGINE - 64))
      | (1ULL << (HplsqlParser::T_ESCAPED - 64))
      | (1ULL << (HplsqlParser::T_EXCEPT - 64))
      | (1ULL << (HplsqlParser::T_EXEC - 64))
      | (1ULL << (HplsqlParser::T_EXECUTE - 64))
      | (1ULL << (HplsqlParser::T_EXCEPTION - 64))
      | (1ULL << (HplsqlParser::T_EXCLUSIVE - 64))
      | (1ULL << (HplsqlParser::T_EXISTS - 64))
      | (1ULL << (HplsqlParser::T_EXIT - 64))
      | (1ULL << (HplsqlParser::T_FALLBACK - 64))
      | (1ULL << (HplsqlParser::T_FALSE - 64))
      | (1ULL << (HplsqlParser::T_FETCH - 64))
      | (1ULL << (HplsqlParser::T_FIELDS - 64))
      | (1ULL << (HplsqlParser::T_FILE - 64))
      | (1ULL << (HplsqlParser::T_FILES - 64))
      | (1ULL << (HplsqlParser::T_FLOAT - 64))
      | (1ULL << (HplsqlParser::T_FOR - 64))
      | (1ULL << (HplsqlParser::T_FOREIGN - 64))
      | (1ULL << (HplsqlParser::T_FORMAT - 64))
      | (1ULL << (HplsqlParser::T_FOUND - 64))
      | (1ULL << (HplsqlParser::T_FROM - 64))
      | (1ULL << (HplsqlParser::T_FULL - 64))
      | (1ULL << (HplsqlParser::T_FUNCTION - 64))
      | (1ULL << (HplsqlParser::T_GET - 64))
      | (1ULL << (HplsqlParser::T_GLOBAL - 64))
      | (1ULL << (HplsqlParser::T_GO - 64))
      | (1ULL << (HplsqlParser::T_GRANT - 64))
      | (1ULL << (HplsqlParser::T_GROUP - 64))
      | (1ULL << (HplsqlParser::T_HANDLER - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (HplsqlParser::T_HASH - 128))
      | (1ULL << (HplsqlParser::T_HAVING - 128))
      | (1ULL << (HplsqlParser::T_HDFS - 128))
      | (1ULL << (HplsqlParser::T_HIVE - 128))
      | (1ULL << (HplsqlParser::T_HOST - 128))
      | (1ULL << (HplsqlParser::T_IDENTITY - 128))
      | (1ULL << (HplsqlParser::T_IF - 128))
      | (1ULL << (HplsqlParser::T_IGNORE - 128))
      | (1ULL << (HplsqlParser::T_IMMEDIATE - 128))
      | (1ULL << (HplsqlParser::T_IN - 128))
      | (1ULL << (HplsqlParser::T_INCLUDE - 128))
      | (1ULL << (HplsqlParser::T_INDEX - 128))
      | (1ULL << (HplsqlParser::T_INITRANS - 128))
      | (1ULL << (HplsqlParser::T_INNER - 128))
      | (1ULL << (HplsqlParser::T_INOUT - 128))
      | (1ULL << (HplsqlParser::T_INSERT - 128))
      | (1ULL << (HplsqlParser::T_INT - 128))
      | (1ULL << (HplsqlParser::T_INT2 - 128))
      | (1ULL << (HplsqlParser::T_INT4 - 128))
      | (1ULL << (HplsqlParser::T_INT8 - 128))
      | (1ULL << (HplsqlParser::T_INTEGER - 128))
      | (1ULL << (HplsqlParser::T_INTERSECT - 128))
      | (1ULL << (HplsqlParser::T_INTERVAL - 128))
      | (1ULL << (HplsqlParser::T_INTO - 128))
      | (1ULL << (HplsqlParser::T_INVOKER - 128))
      | (1ULL << (HplsqlParser::T_IS - 128))
      | (1ULL << (HplsqlParser::T_ISOPEN - 128))
      | (1ULL << (HplsqlParser::T_ITEMS - 128))
      | (1ULL << (HplsqlParser::T_JOIN - 128))
      | (1ULL << (HplsqlParser::T_KEEP - 128))
      | (1ULL << (HplsqlParser::T_KEY - 128))
      | (1ULL << (HplsqlParser::T_KEYS - 128))
      | (1ULL << (HplsqlParser::T_LANGUAGE - 128))
      | (1ULL << (HplsqlParser::T_LEAVE - 128))
      | (1ULL << (HplsqlParser::T_LEFT - 128))
      | (1ULL << (HplsqlParser::T_LIKE - 128))
      | (1ULL << (HplsqlParser::T_LIMIT - 128))
      | (1ULL << (HplsqlParser::T_LINES - 128))
      | (1ULL << (HplsqlParser::T_LOCAL - 128))
      | (1ULL << (HplsqlParser::T_LOCATION - 128))
      | (1ULL << (HplsqlParser::T_LOCATOR - 128))
      | (1ULL << (HplsqlParser::T_LOCATORS - 128))
      | (1ULL << (HplsqlParser::T_LOCKS - 128))
      | (1ULL << (HplsqlParser::T_LOG - 128))
      | (1ULL << (HplsqlParser::T_LOGGED - 128))
      | (1ULL << (HplsqlParser::T_LOGGING - 128))
      | (1ULL << (HplsqlParser::T_LOOP - 128))
      | (1ULL << (HplsqlParser::T_MAP - 128))
      | (1ULL << (HplsqlParser::T_MATCHED - 128))
      | (1ULL << (HplsqlParser::T_MAX - 128))
      | (1ULL << (HplsqlParser::T_MAXTRANS - 128))
      | (1ULL << (HplsqlParser::T_MERGE - 128))
      | (1ULL << (HplsqlParser::T_MESSAGE_TEXT - 128))
      | (1ULL << (HplsqlParser::T_MICROSECOND - 128))
      | (1ULL << (HplsqlParser::T_MICROSECONDS - 128))
      | (1ULL << (HplsqlParser::T_MIN - 128))
      | (1ULL << (HplsqlParser::T_MULTISET - 128))
      | (1ULL << (HplsqlParser::T_NCHAR - 128))
      | (1ULL << (HplsqlParser::T_NEW - 128))
      | (1ULL << (HplsqlParser::T_NVARCHAR - 128))
      | (1ULL << (HplsqlParser::T_NO - 128))
      | (1ULL << (HplsqlParser::T_NOCOUNT - 128))
      | (1ULL << (HplsqlParser::T_NOCOMPRESS - 128))
      | (1ULL << (HplsqlParser::T_NOLOGGING - 128)))) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & ((1ULL << (HplsqlParser::T_NONE - 192))
      | (1ULL << (HplsqlParser::T_NOT - 192))
      | (1ULL << (HplsqlParser::T_NOTFOUND - 192))
      | (1ULL << (HplsqlParser::T_NUMERIC - 192))
      | (1ULL << (HplsqlParser::T_NUMBER - 192))
      | (1ULL << (HplsqlParser::T_OBJECT - 192))
      | (1ULL << (HplsqlParser::T_OFF - 192))
      | (1ULL << (HplsqlParser::T_ON - 192))
      | (1ULL << (HplsqlParser::T_ONLY - 192))
      | (1ULL << (HplsqlParser::T_OPEN - 192))
      | (1ULL << (HplsqlParser::T_OR - 192))
      | (1ULL << (HplsqlParser::T_ORDER - 192))
      | (1ULL << (HplsqlParser::T_OUT - 192))
      | (1ULL << (HplsqlParser::T_OUTER - 192))
      | (1ULL << (HplsqlParser::T_OVER - 192))
      | (1ULL << (HplsqlParser::T_OVERWRITE - 192))
      | (1ULL << (HplsqlParser::T_OWNER - 192))
      | (1ULL << (HplsqlParser::T_PACKAGE - 192))
      | (1ULL << (HplsqlParser::T_PARTITION - 192))
      | (1ULL << (HplsqlParser::T_PCTFREE - 192))
      | (1ULL << (HplsqlParser::T_PCTUSED - 192))
      | (1ULL << (HplsqlParser::T_PRECISION - 192))
      | (1ULL << (HplsqlParser::T_PRESERVE - 192))
      | (1ULL << (HplsqlParser::T_PRIMARY - 192))
      | (1ULL << (HplsqlParser::T_PRINT - 192))
      | (1ULL << (HplsqlParser::T_PROC - 192))
      | (1ULL << (HplsqlParser::T_PROCEDURE - 192))
      | (1ULL << (HplsqlParser::T_QUALIFY - 192))
      | (1ULL << (HplsqlParser::T_QUERY_BAND - 192))
      | (1ULL << (HplsqlParser::T_QUIT - 192))
      | (1ULL << (HplsqlParser::T_QUOTED_IDENTIFIER - 192))
      | (1ULL << (HplsqlParser::T_RAISE - 192))
      | (1ULL << (HplsqlParser::T_REAL - 192))
      | (1ULL << (HplsqlParser::T_REFERENCES - 192))
      | (1ULL << (HplsqlParser::T_REGEXP - 192))
      | (1ULL << (HplsqlParser::T_REPLACE - 192))
      | (1ULL << (HplsqlParser::T_RESIGNAL - 192))
      | (1ULL << (HplsqlParser::T_RESTRICT - 192))
      | (1ULL << (HplsqlParser::T_RESULT - 192))
      | (1ULL << (HplsqlParser::T_RESULT_SET_LOCATOR - 192))
      | (1ULL << (HplsqlParser::T_RETURN - 192))
      | (1ULL << (HplsqlParser::T_RETURNS - 192))
      | (1ULL << (HplsqlParser::T_REVERSE - 192))
      | (1ULL << (HplsqlParser::T_RIGHT - 192))
      | (1ULL << (HplsqlParser::T_RLIKE - 192))
      | (1ULL << (HplsqlParser::T_ROLE - 192))
      | (1ULL << (HplsqlParser::T_ROLLBACK - 192))
      | (1ULL << (HplsqlParser::T_ROW - 192))
      | (1ULL << (HplsqlParser::T_ROWS - 192))
      | (1ULL << (HplsqlParser::T_ROW_COUNT - 192))
      | (1ULL << (HplsqlParser::T_RR - 192))
      | (1ULL << (HplsqlParser::T_RS - 192))
      | (1ULL << (HplsqlParser::T_PWD - 192))
      | (1ULL << (HplsqlParser::T_TRIM - 192))
      | (1ULL << (HplsqlParser::T_SCHEMA - 192))
      | (1ULL << (HplsqlParser::T_SECOND - 192))
      | (1ULL << (HplsqlParser::T_SECONDS - 192))
      | (1ULL << (HplsqlParser::T_SECURITY - 192))
      | (1ULL << (HplsqlParser::T_SEGMENT - 192))
      | (1ULL << (HplsqlParser::T_SEL - 192))
      | (1ULL << (HplsqlParser::T_SELECT - 192)))) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 256)) & ((1ULL << (HplsqlParser::T_SET - 256))
      | (1ULL << (HplsqlParser::T_SESSION - 256))
      | (1ULL << (HplsqlParser::T_SESSIONS - 256))
      | (1ULL << (HplsqlParser::T_SETS - 256))
      | (1ULL << (HplsqlParser::T_SHARE - 256))
      | (1ULL << (HplsqlParser::T_SIGNAL - 256))
      | (1ULL << (HplsqlParser::T_SIMPLE_DOUBLE - 256))
      | (1ULL << (HplsqlParser::T_SIMPLE_FLOAT - 256))
      | (1ULL << (HplsqlParser::T_SMALLDATETIME - 256))
      | (1ULL << (HplsqlParser::T_SMALLINT - 256))
      | (1ULL << (HplsqlParser::T_SQL - 256))
      | (1ULL << (HplsqlParser::T_SQLEXCEPTION - 256))
      | (1ULL << (HplsqlParser::T_SQLINSERT - 256))
      | (1ULL << (HplsqlParser::T_SQLSTATE - 256))
      | (1ULL << (HplsqlParser::T_SQLWARNING - 256))
      | (1ULL << (HplsqlParser::T_STATS - 256))
      | (1ULL << (HplsqlParser::T_STATISTICS - 256))
      | (1ULL << (HplsqlParser::T_STEP - 256))
      | (1ULL << (HplsqlParser::T_STORAGE - 256))
      | (1ULL << (HplsqlParser::T_STORED - 256))
      | (1ULL << (HplsqlParser::T_STRING - 256))
      | (1ULL << (HplsqlParser::T_SUBDIR - 256))
      | (1ULL << (HplsqlParser::T_SUBSTRING - 256))
      | (1ULL << (HplsqlParser::T_SUM - 256))
      | (1ULL << (HplsqlParser::T_SYS_REFCURSOR - 256))
      | (1ULL << (HplsqlParser::T_TABLE - 256))
      | (1ULL << (HplsqlParser::T_TABLESPACE - 256))
      | (1ULL << (HplsqlParser::T_TEMPORARY - 256))
      | (1ULL << (HplsqlParser::T_TERMINATED - 256))
      | (1ULL << (HplsqlParser::T_TEXTIMAGE_ON - 256))
      | (1ULL << (HplsqlParser::T_THEN - 256))
      | (1ULL << (HplsqlParser::T_TIMESTAMP - 256))
      | (1ULL << (HplsqlParser::T_TITLE - 256))
      | (1ULL << (HplsqlParser::T_TO - 256))
      | (1ULL << (HplsqlParser::T_TOP - 256))
      | (1ULL << (HplsqlParser::T_TRANSACTION - 256))
      | (1ULL << (HplsqlParser::T_TRUE - 256))
      | (1ULL << (HplsqlParser::T_TRUNCATE - 256))
      | (1ULL << (HplsqlParser::T_UNIQUE - 256))
      | (1ULL << (HplsqlParser::T_UPDATE - 256))
      | (1ULL << (HplsqlParser::T_UR - 256))
      | (1ULL << (HplsqlParser::T_USE - 256))
      | (1ULL << (HplsqlParser::T_USING - 256))
      | (1ULL << (HplsqlParser::T_VALUE - 256))
      | (1ULL << (HplsqlParser::T_VALUES - 256))
      | (1ULL << (HplsqlParser::T_VAR - 256))
      | (1ULL << (HplsqlParser::T_VARCHAR - 256))
      | (1ULL << (HplsqlParser::T_VARCHAR2 - 256))
      | (1ULL << (HplsqlParser::T_VARYING - 256))
      | (1ULL << (HplsqlParser::T_VOLATILE - 256))
      | (1ULL << (HplsqlParser::T_WHILE - 256))
      | (1ULL << (HplsqlParser::T_WITH - 256))
      | (1ULL << (HplsqlParser::T_WITHOUT - 256))
      | (1ULL << (HplsqlParser::T_WORK - 256))
      | (1ULL << (HplsqlParser::T_XACT_ABORT - 256))
      | (1ULL << (HplsqlParser::T_XML - 256))
      | (1ULL << (HplsqlParser::T_YES - 256))
      | (1ULL << (HplsqlParser::T_ACTIVITY_COUNT - 256)))) != 0) || ((((_la - 320) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 320)) & ((1ULL << (HplsqlParser::T_CUME_DIST - 320))
      | (1ULL << (HplsqlParser::T_CURRENT_DATE - 320))
      | (1ULL << (HplsqlParser::T_CURRENT_TIMESTAMP - 320))
      | (1ULL << (HplsqlParser::T_CURRENT_USER - 320))
      | (1ULL << (HplsqlParser::T_DENSE_RANK - 320))
      | (1ULL << (HplsqlParser::T_FIRST_VALUE - 320))
      | (1ULL << (HplsqlParser::T_LAG - 320))
      | (1ULL << (HplsqlParser::T_LAST_VALUE - 320))
      | (1ULL << (HplsqlParser::T_LEAD - 320))
      | (1ULL << (HplsqlParser::T_PART_COUNT - 320))
      | (1ULL << (HplsqlParser::T_PART_LOC - 320))
      | (1ULL << (HplsqlParser::T_RANK - 320))
      | (1ULL << (HplsqlParser::T_ROW_NUMBER - 320))
      | (1ULL << (HplsqlParser::T_STDEV - 320))
      | (1ULL << (HplsqlParser::T_SYSDATE - 320))
      | (1ULL << (HplsqlParser::T_VARIANCE - 320))
      | (1ULL << (HplsqlParser::T_USER - 320))
      | (1ULL << (HplsqlParser::L_ID - 320)))) != 0)) {
      setState(1446);
      package_spec_item();
      setState(1447);
      match(HplsqlParser::T_SEMICOLON);
      setState(1453);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Package_spec_itemContext ------------------------------------------------------------------

HplsqlParser::Package_spec_itemContext::Package_spec_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Declare_stmt_itemContext* HplsqlParser::Package_spec_itemContext::declare_stmt_item() {
  return getRuleContext<HplsqlParser::Declare_stmt_itemContext>(0);
}

tree::TerminalNode* HplsqlParser::Package_spec_itemContext::T_FUNCTION() {
  return getToken(HplsqlParser::T_FUNCTION, 0);
}

HplsqlParser::IdentContext* HplsqlParser::Package_spec_itemContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

HplsqlParser::Create_function_returnContext* HplsqlParser::Package_spec_itemContext::create_function_return() {
  return getRuleContext<HplsqlParser::Create_function_returnContext>(0);
}

HplsqlParser::Create_routine_paramsContext* HplsqlParser::Package_spec_itemContext::create_routine_params() {
  return getRuleContext<HplsqlParser::Create_routine_paramsContext>(0);
}

tree::TerminalNode* HplsqlParser::Package_spec_itemContext::T_PROCEDURE() {
  return getToken(HplsqlParser::T_PROCEDURE, 0);
}

tree::TerminalNode* HplsqlParser::Package_spec_itemContext::T_PROC() {
  return getToken(HplsqlParser::T_PROC, 0);
}


size_t HplsqlParser::Package_spec_itemContext::getRuleIndex() const {
  return HplsqlParser::RulePackage_spec_item;
}

void HplsqlParser::Package_spec_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPackage_spec_item(this);
}

void HplsqlParser::Package_spec_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPackage_spec_item(this);
}


antlrcpp::Any HplsqlParser::Package_spec_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitPackage_spec_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Package_spec_itemContext* HplsqlParser::package_spec_item() {
  Package_spec_itemContext *_localctx = _tracker.createInstance<Package_spec_itemContext>(_ctx, getState());
  enterRule(_localctx, 138, HplsqlParser::RulePackage_spec_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1467);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 146, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1454);
      declare_stmt_item();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1455);
      match(HplsqlParser::T_FUNCTION);
      setState(1456);
      ident();
      setState(1458);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx)) {
      case 1: {
        setState(1457);
        create_routine_params();
        break;
      }

      default:
        break;
      }
      setState(1460);
      create_function_return();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1462);
      _la = _input->LA(1);
      if (!(_la == HplsqlParser::T_PROC

      || _la == HplsqlParser::T_PROCEDURE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1463);
      ident();
      setState(1465);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 145, _ctx)) {
      case 1: {
        setState(1464);
        create_routine_params();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_package_body_stmtContext ------------------------------------------------------------------

HplsqlParser::Create_package_body_stmtContext::Create_package_body_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_package_body_stmtContext::T_PACKAGE() {
  return getToken(HplsqlParser::T_PACKAGE, 0);
}

tree::TerminalNode* HplsqlParser::Create_package_body_stmtContext::T_BODY() {
  return getToken(HplsqlParser::T_BODY, 0);
}

std::vector<HplsqlParser::IdentContext *> HplsqlParser::Create_package_body_stmtContext::ident() {
  return getRuleContexts<HplsqlParser::IdentContext>();
}

HplsqlParser::IdentContext* HplsqlParser::Create_package_body_stmtContext::ident(size_t i) {
  return getRuleContext<HplsqlParser::IdentContext>(i);
}

HplsqlParser::Package_bodyContext* HplsqlParser::Create_package_body_stmtContext::package_body() {
  return getRuleContext<HplsqlParser::Package_bodyContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_package_body_stmtContext::T_END() {
  return getToken(HplsqlParser::T_END, 0);
}

tree::TerminalNode* HplsqlParser::Create_package_body_stmtContext::T_AS() {
  return getToken(HplsqlParser::T_AS, 0);
}

tree::TerminalNode* HplsqlParser::Create_package_body_stmtContext::T_IS() {
  return getToken(HplsqlParser::T_IS, 0);
}

tree::TerminalNode* HplsqlParser::Create_package_body_stmtContext::T_ALTER() {
  return getToken(HplsqlParser::T_ALTER, 0);
}

tree::TerminalNode* HplsqlParser::Create_package_body_stmtContext::T_CREATE() {
  return getToken(HplsqlParser::T_CREATE, 0);
}

tree::TerminalNode* HplsqlParser::Create_package_body_stmtContext::T_REPLACE() {
  return getToken(HplsqlParser::T_REPLACE, 0);
}

tree::TerminalNode* HplsqlParser::Create_package_body_stmtContext::T_SEMICOLON() {
  return getToken(HplsqlParser::T_SEMICOLON, 0);
}

tree::TerminalNode* HplsqlParser::Create_package_body_stmtContext::T_OR() {
  return getToken(HplsqlParser::T_OR, 0);
}


size_t HplsqlParser::Create_package_body_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_package_body_stmt;
}

void HplsqlParser::Create_package_body_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_package_body_stmt(this);
}

void HplsqlParser::Create_package_body_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_package_body_stmt(this);
}


antlrcpp::Any HplsqlParser::Create_package_body_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_package_body_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_package_body_stmtContext* HplsqlParser::create_package_body_stmt() {
  Create_package_body_stmtContext *_localctx = _tracker.createInstance<Create_package_body_stmtContext>(_ctx, getState());
  enterRule(_localctx, 140, HplsqlParser::RuleCreate_package_body_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1476);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_ALTER: {
        setState(1469);
        match(HplsqlParser::T_ALTER);
        break;
      }

      case HplsqlParser::T_CREATE: {
        setState(1470);
        match(HplsqlParser::T_CREATE);
        setState(1473);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_OR) {
          setState(1471);
          match(HplsqlParser::T_OR);
          setState(1472);
          match(HplsqlParser::T_REPLACE);
        }
        break;
      }

      case HplsqlParser::T_REPLACE: {
        setState(1475);
        match(HplsqlParser::T_REPLACE);
        break;
      }

      case HplsqlParser::T_PACKAGE: {
        break;
      }

    default:
      break;
    }
    setState(1478);
    match(HplsqlParser::T_PACKAGE);
    setState(1479);
    match(HplsqlParser::T_BODY);
    setState(1480);
    ident();
    setState(1481);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_AS || _la == HplsqlParser::T_IS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1482);
    package_body();
    setState(1483);
    match(HplsqlParser::T_END);
    setState(1487);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 149, _ctx)) {
    case 1: {
      setState(1484);
      ident();
      setState(1485);
      match(HplsqlParser::T_SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Package_bodyContext ------------------------------------------------------------------

HplsqlParser::Package_bodyContext::Package_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HplsqlParser::Package_body_itemContext *> HplsqlParser::Package_bodyContext::package_body_item() {
  return getRuleContexts<HplsqlParser::Package_body_itemContext>();
}

HplsqlParser::Package_body_itemContext* HplsqlParser::Package_bodyContext::package_body_item(size_t i) {
  return getRuleContext<HplsqlParser::Package_body_itemContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Package_bodyContext::T_SEMICOLON() {
  return getTokens(HplsqlParser::T_SEMICOLON);
}

tree::TerminalNode* HplsqlParser::Package_bodyContext::T_SEMICOLON(size_t i) {
  return getToken(HplsqlParser::T_SEMICOLON, i);
}


size_t HplsqlParser::Package_bodyContext::getRuleIndex() const {
  return HplsqlParser::RulePackage_body;
}

void HplsqlParser::Package_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPackage_body(this);
}

void HplsqlParser::Package_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPackage_body(this);
}


antlrcpp::Any HplsqlParser::Package_bodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitPackage_body(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Package_bodyContext* HplsqlParser::package_body() {
  Package_bodyContext *_localctx = _tracker.createInstance<Package_bodyContext>(_ctx, getState());
  enterRule(_localctx, 142, HplsqlParser::RulePackage_body);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1489);
    package_body_item();
    setState(1490);
    match(HplsqlParser::T_SEMICOLON);
    setState(1496);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << HplsqlParser::T_ACTION)
      | (1ULL << HplsqlParser::T_ADD2)
      | (1ULL << HplsqlParser::T_ALL)
      | (1ULL << HplsqlParser::T_ALLOCATE)
      | (1ULL << HplsqlParser::T_ALTER)
      | (1ULL << HplsqlParser::T_AND)
      | (1ULL << HplsqlParser::T_ANSI_NULLS)
      | (1ULL << HplsqlParser::T_ANSI_PADDING)
      | (1ULL << HplsqlParser::T_AS)
      | (1ULL << HplsqlParser::T_ASC)
      | (1ULL << HplsqlParser::T_ASSOCIATE)
      | (1ULL << HplsqlParser::T_AT)
      | (1ULL << HplsqlParser::T_AUTO_INCREMENT)
      | (1ULL << HplsqlParser::T_AVG)
      | (1ULL << HplsqlParser::T_BATCHSIZE)
      | (1ULL << HplsqlParser::T_BEGIN)
      | (1ULL << HplsqlParser::T_BETWEEN)
      | (1ULL << HplsqlParser::T_BIGINT)
      | (1ULL << HplsqlParser::T_BINARY_DOUBLE)
      | (1ULL << HplsqlParser::T_BINARY_FLOAT)
      | (1ULL << HplsqlParser::T_BIT)
      | (1ULL << HplsqlParser::T_BODY)
      | (1ULL << HplsqlParser::T_BREAK)
      | (1ULL << HplsqlParser::T_BY)
      | (1ULL << HplsqlParser::T_BYTE)
      | (1ULL << HplsqlParser::T_CALL)
      | (1ULL << HplsqlParser::T_CALLER)
      | (1ULL << HplsqlParser::T_CASCADE)
      | (1ULL << HplsqlParser::T_CASE)
      | (1ULL << HplsqlParser::T_CASESPECIFIC)
      | (1ULL << HplsqlParser::T_CAST)
      | (1ULL << HplsqlParser::T_CHAR)
      | (1ULL << HplsqlParser::T_CHARACTER)
      | (1ULL << HplsqlParser::T_CHARSET)
      | (1ULL << HplsqlParser::T_CLIENT)
      | (1ULL << HplsqlParser::T_CLOSE)
      | (1ULL << HplsqlParser::T_CLUSTERED)
      | (1ULL << HplsqlParser::T_CMP)
      | (1ULL << HplsqlParser::T_COLLECT)
      | (1ULL << HplsqlParser::T_COLLECTION)
      | (1ULL << HplsqlParser::T_COLUMN)
      | (1ULL << HplsqlParser::T_COMMENT)
      | (1ULL << HplsqlParser::T_CONSTANT)
      | (1ULL << HplsqlParser::T_COMMIT)
      | (1ULL << HplsqlParser::T_COMPRESS)
      | (1ULL << HplsqlParser::T_CONCAT)
      | (1ULL << HplsqlParser::T_CONDITION)
      | (1ULL << HplsqlParser::T_CONSTRAINT)
      | (1ULL << HplsqlParser::T_CONTINUE)
      | (1ULL << HplsqlParser::T_COPY)
      | (1ULL << HplsqlParser::T_COUNT)
      | (1ULL << HplsqlParser::T_COUNT_BIG)
      | (1ULL << HplsqlParser::T_CREATE)
      | (1ULL << HplsqlParser::T_CREATION)
      | (1ULL << HplsqlParser::T_CREATOR)
      | (1ULL << HplsqlParser::T_CS)
      | (1ULL << HplsqlParser::T_CURRENT))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (HplsqlParser::T_CURRENT_SCHEMA - 64))
      | (1ULL << (HplsqlParser::T_CURSOR - 64))
      | (1ULL << (HplsqlParser::T_DATABASE - 64))
      | (1ULL << (HplsqlParser::T_DATA - 64))
      | (1ULL << (HplsqlParser::T_DATE - 64))
      | (1ULL << (HplsqlParser::T_DATETIME - 64))
      | (1ULL << (HplsqlParser::T_DAY - 64))
      | (1ULL << (HplsqlParser::T_DAYS - 64))
      | (1ULL << (HplsqlParser::T_DEC - 64))
      | (1ULL << (HplsqlParser::T_DECIMAL - 64))
      | (1ULL << (HplsqlParser::T_DECLARE - 64))
      | (1ULL << (HplsqlParser::T_DEFAULT - 64))
      | (1ULL << (HplsqlParser::T_DEFERRED - 64))
      | (1ULL << (HplsqlParser::T_DEFINED - 64))
      | (1ULL << (HplsqlParser::T_DEFINER - 64))
      | (1ULL << (HplsqlParser::T_DEFINITION - 64))
      | (1ULL << (HplsqlParser::T_DELETE - 64))
      | (1ULL << (HplsqlParser::T_DELIMITED - 64))
      | (1ULL << (HplsqlParser::T_DELIMITER - 64))
      | (1ULL << (HplsqlParser::T_DESC - 64))
      | (1ULL << (HplsqlParser::T_DESCRIBE - 64))
      | (1ULL << (HplsqlParser::T_DIAGNOSTICS - 64))
      | (1ULL << (HplsqlParser::T_DIR - 64))
      | (1ULL << (HplsqlParser::T_DIRECTORY - 64))
      | (1ULL << (HplsqlParser::T_DISTINCT - 64))
      | (1ULL << (HplsqlParser::T_DISTRIBUTE - 64))
      | (1ULL << (HplsqlParser::T_DO - 64))
      | (1ULL << (HplsqlParser::T_DOUBLE - 64))
      | (1ULL << (HplsqlParser::T_DROP - 64))
      | (1ULL << (HplsqlParser::T_DYNAMIC - 64))
      | (1ULL << (HplsqlParser::T_ENABLE - 64))
      | (1ULL << (HplsqlParser::T_ENGINE - 64))
      | (1ULL << (HplsqlParser::T_ESCAPED - 64))
      | (1ULL << (HplsqlParser::T_EXCEPT - 64))
      | (1ULL << (HplsqlParser::T_EXEC - 64))
      | (1ULL << (HplsqlParser::T_EXECUTE - 64))
      | (1ULL << (HplsqlParser::T_EXCEPTION - 64))
      | (1ULL << (HplsqlParser::T_EXCLUSIVE - 64))
      | (1ULL << (HplsqlParser::T_EXISTS - 64))
      | (1ULL << (HplsqlParser::T_EXIT - 64))
      | (1ULL << (HplsqlParser::T_FALLBACK - 64))
      | (1ULL << (HplsqlParser::T_FALSE - 64))
      | (1ULL << (HplsqlParser::T_FETCH - 64))
      | (1ULL << (HplsqlParser::T_FIELDS - 64))
      | (1ULL << (HplsqlParser::T_FILE - 64))
      | (1ULL << (HplsqlParser::T_FILES - 64))
      | (1ULL << (HplsqlParser::T_FLOAT - 64))
      | (1ULL << (HplsqlParser::T_FOR - 64))
      | (1ULL << (HplsqlParser::T_FOREIGN - 64))
      | (1ULL << (HplsqlParser::T_FORMAT - 64))
      | (1ULL << (HplsqlParser::T_FOUND - 64))
      | (1ULL << (HplsqlParser::T_FROM - 64))
      | (1ULL << (HplsqlParser::T_FULL - 64))
      | (1ULL << (HplsqlParser::T_FUNCTION - 64))
      | (1ULL << (HplsqlParser::T_GET - 64))
      | (1ULL << (HplsqlParser::T_GLOBAL - 64))
      | (1ULL << (HplsqlParser::T_GO - 64))
      | (1ULL << (HplsqlParser::T_GRANT - 64))
      | (1ULL << (HplsqlParser::T_GROUP - 64))
      | (1ULL << (HplsqlParser::T_HANDLER - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (HplsqlParser::T_HASH - 128))
      | (1ULL << (HplsqlParser::T_HAVING - 128))
      | (1ULL << (HplsqlParser::T_HDFS - 128))
      | (1ULL << (HplsqlParser::T_HIVE - 128))
      | (1ULL << (HplsqlParser::T_HOST - 128))
      | (1ULL << (HplsqlParser::T_IDENTITY - 128))
      | (1ULL << (HplsqlParser::T_IF - 128))
      | (1ULL << (HplsqlParser::T_IGNORE - 128))
      | (1ULL << (HplsqlParser::T_IMMEDIATE - 128))
      | (1ULL << (HplsqlParser::T_IN - 128))
      | (1ULL << (HplsqlParser::T_INCLUDE - 128))
      | (1ULL << (HplsqlParser::T_INDEX - 128))
      | (1ULL << (HplsqlParser::T_INITRANS - 128))
      | (1ULL << (HplsqlParser::T_INNER - 128))
      | (1ULL << (HplsqlParser::T_INOUT - 128))
      | (1ULL << (HplsqlParser::T_INSERT - 128))
      | (1ULL << (HplsqlParser::T_INT - 128))
      | (1ULL << (HplsqlParser::T_INT2 - 128))
      | (1ULL << (HplsqlParser::T_INT4 - 128))
      | (1ULL << (HplsqlParser::T_INT8 - 128))
      | (1ULL << (HplsqlParser::T_INTEGER - 128))
      | (1ULL << (HplsqlParser::T_INTERSECT - 128))
      | (1ULL << (HplsqlParser::T_INTERVAL - 128))
      | (1ULL << (HplsqlParser::T_INTO - 128))
      | (1ULL << (HplsqlParser::T_INVOKER - 128))
      | (1ULL << (HplsqlParser::T_IS - 128))
      | (1ULL << (HplsqlParser::T_ISOPEN - 128))
      | (1ULL << (HplsqlParser::T_ITEMS - 128))
      | (1ULL << (HplsqlParser::T_JOIN - 128))
      | (1ULL << (HplsqlParser::T_KEEP - 128))
      | (1ULL << (HplsqlParser::T_KEY - 128))
      | (1ULL << (HplsqlParser::T_KEYS - 128))
      | (1ULL << (HplsqlParser::T_LANGUAGE - 128))
      | (1ULL << (HplsqlParser::T_LEAVE - 128))
      | (1ULL << (HplsqlParser::T_LEFT - 128))
      | (1ULL << (HplsqlParser::T_LIKE - 128))
      | (1ULL << (HplsqlParser::T_LIMIT - 128))
      | (1ULL << (HplsqlParser::T_LINES - 128))
      | (1ULL << (HplsqlParser::T_LOCAL - 128))
      | (1ULL << (HplsqlParser::T_LOCATION - 128))
      | (1ULL << (HplsqlParser::T_LOCATOR - 128))
      | (1ULL << (HplsqlParser::T_LOCATORS - 128))
      | (1ULL << (HplsqlParser::T_LOCKS - 128))
      | (1ULL << (HplsqlParser::T_LOG - 128))
      | (1ULL << (HplsqlParser::T_LOGGED - 128))
      | (1ULL << (HplsqlParser::T_LOGGING - 128))
      | (1ULL << (HplsqlParser::T_LOOP - 128))
      | (1ULL << (HplsqlParser::T_MAP - 128))
      | (1ULL << (HplsqlParser::T_MATCHED - 128))
      | (1ULL << (HplsqlParser::T_MAX - 128))
      | (1ULL << (HplsqlParser::T_MAXTRANS - 128))
      | (1ULL << (HplsqlParser::T_MERGE - 128))
      | (1ULL << (HplsqlParser::T_MESSAGE_TEXT - 128))
      | (1ULL << (HplsqlParser::T_MICROSECOND - 128))
      | (1ULL << (HplsqlParser::T_MICROSECONDS - 128))
      | (1ULL << (HplsqlParser::T_MIN - 128))
      | (1ULL << (HplsqlParser::T_MULTISET - 128))
      | (1ULL << (HplsqlParser::T_NCHAR - 128))
      | (1ULL << (HplsqlParser::T_NEW - 128))
      | (1ULL << (HplsqlParser::T_NVARCHAR - 128))
      | (1ULL << (HplsqlParser::T_NO - 128))
      | (1ULL << (HplsqlParser::T_NOCOUNT - 128))
      | (1ULL << (HplsqlParser::T_NOCOMPRESS - 128))
      | (1ULL << (HplsqlParser::T_NOLOGGING - 128)))) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & ((1ULL << (HplsqlParser::T_NONE - 192))
      | (1ULL << (HplsqlParser::T_NOT - 192))
      | (1ULL << (HplsqlParser::T_NOTFOUND - 192))
      | (1ULL << (HplsqlParser::T_NUMERIC - 192))
      | (1ULL << (HplsqlParser::T_NUMBER - 192))
      | (1ULL << (HplsqlParser::T_OBJECT - 192))
      | (1ULL << (HplsqlParser::T_OFF - 192))
      | (1ULL << (HplsqlParser::T_ON - 192))
      | (1ULL << (HplsqlParser::T_ONLY - 192))
      | (1ULL << (HplsqlParser::T_OPEN - 192))
      | (1ULL << (HplsqlParser::T_OR - 192))
      | (1ULL << (HplsqlParser::T_ORDER - 192))
      | (1ULL << (HplsqlParser::T_OUT - 192))
      | (1ULL << (HplsqlParser::T_OUTER - 192))
      | (1ULL << (HplsqlParser::T_OVER - 192))
      | (1ULL << (HplsqlParser::T_OVERWRITE - 192))
      | (1ULL << (HplsqlParser::T_OWNER - 192))
      | (1ULL << (HplsqlParser::T_PACKAGE - 192))
      | (1ULL << (HplsqlParser::T_PARTITION - 192))
      | (1ULL << (HplsqlParser::T_PCTFREE - 192))
      | (1ULL << (HplsqlParser::T_PCTUSED - 192))
      | (1ULL << (HplsqlParser::T_PRECISION - 192))
      | (1ULL << (HplsqlParser::T_PRESERVE - 192))
      | (1ULL << (HplsqlParser::T_PRIMARY - 192))
      | (1ULL << (HplsqlParser::T_PRINT - 192))
      | (1ULL << (HplsqlParser::T_PROC - 192))
      | (1ULL << (HplsqlParser::T_PROCEDURE - 192))
      | (1ULL << (HplsqlParser::T_QUALIFY - 192))
      | (1ULL << (HplsqlParser::T_QUERY_BAND - 192))
      | (1ULL << (HplsqlParser::T_QUIT - 192))
      | (1ULL << (HplsqlParser::T_QUOTED_IDENTIFIER - 192))
      | (1ULL << (HplsqlParser::T_RAISE - 192))
      | (1ULL << (HplsqlParser::T_REAL - 192))
      | (1ULL << (HplsqlParser::T_REFERENCES - 192))
      | (1ULL << (HplsqlParser::T_REGEXP - 192))
      | (1ULL << (HplsqlParser::T_REPLACE - 192))
      | (1ULL << (HplsqlParser::T_RESIGNAL - 192))
      | (1ULL << (HplsqlParser::T_RESTRICT - 192))
      | (1ULL << (HplsqlParser::T_RESULT - 192))
      | (1ULL << (HplsqlParser::T_RESULT_SET_LOCATOR - 192))
      | (1ULL << (HplsqlParser::T_RETURN - 192))
      | (1ULL << (HplsqlParser::T_RETURNS - 192))
      | (1ULL << (HplsqlParser::T_REVERSE - 192))
      | (1ULL << (HplsqlParser::T_RIGHT - 192))
      | (1ULL << (HplsqlParser::T_RLIKE - 192))
      | (1ULL << (HplsqlParser::T_ROLE - 192))
      | (1ULL << (HplsqlParser::T_ROLLBACK - 192))
      | (1ULL << (HplsqlParser::T_ROW - 192))
      | (1ULL << (HplsqlParser::T_ROWS - 192))
      | (1ULL << (HplsqlParser::T_ROW_COUNT - 192))
      | (1ULL << (HplsqlParser::T_RR - 192))
      | (1ULL << (HplsqlParser::T_RS - 192))
      | (1ULL << (HplsqlParser::T_PWD - 192))
      | (1ULL << (HplsqlParser::T_TRIM - 192))
      | (1ULL << (HplsqlParser::T_SCHEMA - 192))
      | (1ULL << (HplsqlParser::T_SECOND - 192))
      | (1ULL << (HplsqlParser::T_SECONDS - 192))
      | (1ULL << (HplsqlParser::T_SECURITY - 192))
      | (1ULL << (HplsqlParser::T_SEGMENT - 192))
      | (1ULL << (HplsqlParser::T_SEL - 192))
      | (1ULL << (HplsqlParser::T_SELECT - 192)))) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 256)) & ((1ULL << (HplsqlParser::T_SET - 256))
      | (1ULL << (HplsqlParser::T_SESSION - 256))
      | (1ULL << (HplsqlParser::T_SESSIONS - 256))
      | (1ULL << (HplsqlParser::T_SETS - 256))
      | (1ULL << (HplsqlParser::T_SHARE - 256))
      | (1ULL << (HplsqlParser::T_SIGNAL - 256))
      | (1ULL << (HplsqlParser::T_SIMPLE_DOUBLE - 256))
      | (1ULL << (HplsqlParser::T_SIMPLE_FLOAT - 256))
      | (1ULL << (HplsqlParser::T_SMALLDATETIME - 256))
      | (1ULL << (HplsqlParser::T_SMALLINT - 256))
      | (1ULL << (HplsqlParser::T_SQL - 256))
      | (1ULL << (HplsqlParser::T_SQLEXCEPTION - 256))
      | (1ULL << (HplsqlParser::T_SQLINSERT - 256))
      | (1ULL << (HplsqlParser::T_SQLSTATE - 256))
      | (1ULL << (HplsqlParser::T_SQLWARNING - 256))
      | (1ULL << (HplsqlParser::T_STATS - 256))
      | (1ULL << (HplsqlParser::T_STATISTICS - 256))
      | (1ULL << (HplsqlParser::T_STEP - 256))
      | (1ULL << (HplsqlParser::T_STORAGE - 256))
      | (1ULL << (HplsqlParser::T_STORED - 256))
      | (1ULL << (HplsqlParser::T_STRING - 256))
      | (1ULL << (HplsqlParser::T_SUBDIR - 256))
      | (1ULL << (HplsqlParser::T_SUBSTRING - 256))
      | (1ULL << (HplsqlParser::T_SUM - 256))
      | (1ULL << (HplsqlParser::T_SYS_REFCURSOR - 256))
      | (1ULL << (HplsqlParser::T_TABLE - 256))
      | (1ULL << (HplsqlParser::T_TABLESPACE - 256))
      | (1ULL << (HplsqlParser::T_TEMPORARY - 256))
      | (1ULL << (HplsqlParser::T_TERMINATED - 256))
      | (1ULL << (HplsqlParser::T_TEXTIMAGE_ON - 256))
      | (1ULL << (HplsqlParser::T_THEN - 256))
      | (1ULL << (HplsqlParser::T_TIMESTAMP - 256))
      | (1ULL << (HplsqlParser::T_TITLE - 256))
      | (1ULL << (HplsqlParser::T_TO - 256))
      | (1ULL << (HplsqlParser::T_TOP - 256))
      | (1ULL << (HplsqlParser::T_TRANSACTION - 256))
      | (1ULL << (HplsqlParser::T_TRUE - 256))
      | (1ULL << (HplsqlParser::T_TRUNCATE - 256))
      | (1ULL << (HplsqlParser::T_UNIQUE - 256))
      | (1ULL << (HplsqlParser::T_UPDATE - 256))
      | (1ULL << (HplsqlParser::T_UR - 256))
      | (1ULL << (HplsqlParser::T_USE - 256))
      | (1ULL << (HplsqlParser::T_USING - 256))
      | (1ULL << (HplsqlParser::T_VALUE - 256))
      | (1ULL << (HplsqlParser::T_VALUES - 256))
      | (1ULL << (HplsqlParser::T_VAR - 256))
      | (1ULL << (HplsqlParser::T_VARCHAR - 256))
      | (1ULL << (HplsqlParser::T_VARCHAR2 - 256))
      | (1ULL << (HplsqlParser::T_VARYING - 256))
      | (1ULL << (HplsqlParser::T_VOLATILE - 256))
      | (1ULL << (HplsqlParser::T_WHILE - 256))
      | (1ULL << (HplsqlParser::T_WITH - 256))
      | (1ULL << (HplsqlParser::T_WITHOUT - 256))
      | (1ULL << (HplsqlParser::T_WORK - 256))
      | (1ULL << (HplsqlParser::T_XACT_ABORT - 256))
      | (1ULL << (HplsqlParser::T_XML - 256))
      | (1ULL << (HplsqlParser::T_YES - 256))
      | (1ULL << (HplsqlParser::T_ACTIVITY_COUNT - 256)))) != 0) || ((((_la - 320) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 320)) & ((1ULL << (HplsqlParser::T_CUME_DIST - 320))
      | (1ULL << (HplsqlParser::T_CURRENT_DATE - 320))
      | (1ULL << (HplsqlParser::T_CURRENT_TIMESTAMP - 320))
      | (1ULL << (HplsqlParser::T_CURRENT_USER - 320))
      | (1ULL << (HplsqlParser::T_DENSE_RANK - 320))
      | (1ULL << (HplsqlParser::T_FIRST_VALUE - 320))
      | (1ULL << (HplsqlParser::T_LAG - 320))
      | (1ULL << (HplsqlParser::T_LAST_VALUE - 320))
      | (1ULL << (HplsqlParser::T_LEAD - 320))
      | (1ULL << (HplsqlParser::T_PART_COUNT - 320))
      | (1ULL << (HplsqlParser::T_PART_LOC - 320))
      | (1ULL << (HplsqlParser::T_RANK - 320))
      | (1ULL << (HplsqlParser::T_ROW_NUMBER - 320))
      | (1ULL << (HplsqlParser::T_STDEV - 320))
      | (1ULL << (HplsqlParser::T_SYSDATE - 320))
      | (1ULL << (HplsqlParser::T_VARIANCE - 320))
      | (1ULL << (HplsqlParser::T_USER - 320))
      | (1ULL << (HplsqlParser::L_ID - 320)))) != 0)) {
      setState(1491);
      package_body_item();
      setState(1492);
      match(HplsqlParser::T_SEMICOLON);
      setState(1498);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Package_body_itemContext ------------------------------------------------------------------

HplsqlParser::Package_body_itemContext::Package_body_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Declare_stmt_itemContext* HplsqlParser::Package_body_itemContext::declare_stmt_item() {
  return getRuleContext<HplsqlParser::Declare_stmt_itemContext>(0);
}

HplsqlParser::Create_function_stmtContext* HplsqlParser::Package_body_itemContext::create_function_stmt() {
  return getRuleContext<HplsqlParser::Create_function_stmtContext>(0);
}

HplsqlParser::Create_procedure_stmtContext* HplsqlParser::Package_body_itemContext::create_procedure_stmt() {
  return getRuleContext<HplsqlParser::Create_procedure_stmtContext>(0);
}


size_t HplsqlParser::Package_body_itemContext::getRuleIndex() const {
  return HplsqlParser::RulePackage_body_item;
}

void HplsqlParser::Package_body_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPackage_body_item(this);
}

void HplsqlParser::Package_body_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPackage_body_item(this);
}


antlrcpp::Any HplsqlParser::Package_body_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitPackage_body_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Package_body_itemContext* HplsqlParser::package_body_item() {
  Package_body_itemContext *_localctx = _tracker.createInstance<Package_body_itemContext>(_ctx, getState());
  enterRule(_localctx, 144, HplsqlParser::RulePackage_body_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1502);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 151, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1499);
      declare_stmt_item();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1500);
      create_function_stmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1501);
      create_procedure_stmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_procedure_stmtContext ------------------------------------------------------------------

HplsqlParser::Create_procedure_stmtContext::Create_procedure_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HplsqlParser::IdentContext *> HplsqlParser::Create_procedure_stmtContext::ident() {
  return getRuleContexts<HplsqlParser::IdentContext>();
}

HplsqlParser::IdentContext* HplsqlParser::Create_procedure_stmtContext::ident(size_t i) {
  return getRuleContext<HplsqlParser::IdentContext>(i);
}

HplsqlParser::Proc_blockContext* HplsqlParser::Create_procedure_stmtContext::proc_block() {
  return getRuleContext<HplsqlParser::Proc_blockContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_procedure_stmtContext::T_PROCEDURE() {
  return getToken(HplsqlParser::T_PROCEDURE, 0);
}

tree::TerminalNode* HplsqlParser::Create_procedure_stmtContext::T_PROC() {
  return getToken(HplsqlParser::T_PROC, 0);
}

tree::TerminalNode* HplsqlParser::Create_procedure_stmtContext::T_ALTER() {
  return getToken(HplsqlParser::T_ALTER, 0);
}

tree::TerminalNode* HplsqlParser::Create_procedure_stmtContext::T_CREATE() {
  return getToken(HplsqlParser::T_CREATE, 0);
}

tree::TerminalNode* HplsqlParser::Create_procedure_stmtContext::T_REPLACE() {
  return getToken(HplsqlParser::T_REPLACE, 0);
}

HplsqlParser::Create_routine_paramsContext* HplsqlParser::Create_procedure_stmtContext::create_routine_params() {
  return getRuleContext<HplsqlParser::Create_routine_paramsContext>(0);
}

HplsqlParser::Create_routine_optionsContext* HplsqlParser::Create_procedure_stmtContext::create_routine_options() {
  return getRuleContext<HplsqlParser::Create_routine_optionsContext>(0);
}

HplsqlParser::Declare_block_inplaceContext* HplsqlParser::Create_procedure_stmtContext::declare_block_inplace() {
  return getRuleContext<HplsqlParser::Declare_block_inplaceContext>(0);
}

HplsqlParser::LabelContext* HplsqlParser::Create_procedure_stmtContext::label() {
  return getRuleContext<HplsqlParser::LabelContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_procedure_stmtContext::T_SEMICOLON() {
  return getToken(HplsqlParser::T_SEMICOLON, 0);
}

tree::TerminalNode* HplsqlParser::Create_procedure_stmtContext::T_AS() {
  return getToken(HplsqlParser::T_AS, 0);
}

tree::TerminalNode* HplsqlParser::Create_procedure_stmtContext::T_IS() {
  return getToken(HplsqlParser::T_IS, 0);
}

tree::TerminalNode* HplsqlParser::Create_procedure_stmtContext::T_OR() {
  return getToken(HplsqlParser::T_OR, 0);
}


size_t HplsqlParser::Create_procedure_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_procedure_stmt;
}

void HplsqlParser::Create_procedure_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_procedure_stmt(this);
}

void HplsqlParser::Create_procedure_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_procedure_stmt(this);
}


antlrcpp::Any HplsqlParser::Create_procedure_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_procedure_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_procedure_stmtContext* HplsqlParser::create_procedure_stmt() {
  Create_procedure_stmtContext *_localctx = _tracker.createInstance<Create_procedure_stmtContext>(_ctx, getState());
  enterRule(_localctx, 146, HplsqlParser::RuleCreate_procedure_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1511);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_ALTER: {
        setState(1504);
        match(HplsqlParser::T_ALTER);
        break;
      }

      case HplsqlParser::T_CREATE: {
        setState(1505);
        match(HplsqlParser::T_CREATE);
        setState(1508);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_OR) {
          setState(1506);
          match(HplsqlParser::T_OR);
          setState(1507);
          match(HplsqlParser::T_REPLACE);
        }
        break;
      }

      case HplsqlParser::T_REPLACE: {
        setState(1510);
        match(HplsqlParser::T_REPLACE);
        break;
      }

      case HplsqlParser::T_PROC:
      case HplsqlParser::T_PROCEDURE: {
        break;
      }

    default:
      break;
    }
    setState(1513);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_PROC

    || _la == HplsqlParser::T_PROCEDURE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1514);
    ident();
    setState(1516);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx)) {
    case 1: {
      setState(1515);
      create_routine_params();
      break;
    }

    default:
      break;
    }
    setState(1519);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 155, _ctx)) {
    case 1: {
      setState(1518);
      create_routine_options();
      break;
    }

    default:
      break;
    }
    setState(1522);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 156, _ctx)) {
    case 1: {
      setState(1521);
      _la = _input->LA(1);
      if (!(_la == HplsqlParser::T_AS || _la == HplsqlParser::T_IS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
    setState(1525);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 157, _ctx)) {
    case 1: {
      setState(1524);
      declare_block_inplace();
      break;
    }

    default:
      break;
    }
    setState(1528);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 158, _ctx)) {
    case 1: {
      setState(1527);
      label();
      break;
    }

    default:
      break;
    }
    setState(1530);
    proc_block();
    setState(1534);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 159, _ctx)) {
    case 1: {
      setState(1531);
      ident();
      setState(1532);
      match(HplsqlParser::T_SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_routine_paramsContext ------------------------------------------------------------------

HplsqlParser::Create_routine_paramsContext::Create_routine_paramsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_routine_paramsContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

tree::TerminalNode* HplsqlParser::Create_routine_paramsContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

std::vector<HplsqlParser::Create_routine_param_itemContext *> HplsqlParser::Create_routine_paramsContext::create_routine_param_item() {
  return getRuleContexts<HplsqlParser::Create_routine_param_itemContext>();
}

HplsqlParser::Create_routine_param_itemContext* HplsqlParser::Create_routine_paramsContext::create_routine_param_item(size_t i) {
  return getRuleContext<HplsqlParser::Create_routine_param_itemContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Create_routine_paramsContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Create_routine_paramsContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Create_routine_paramsContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_routine_params;
}

void HplsqlParser::Create_routine_paramsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_routine_params(this);
}

void HplsqlParser::Create_routine_paramsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_routine_params(this);
}


antlrcpp::Any HplsqlParser::Create_routine_paramsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_routine_params(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_routine_paramsContext* HplsqlParser::create_routine_params() {
  Create_routine_paramsContext *_localctx = _tracker.createInstance<Create_routine_paramsContext>(_ctx, getState());
  enterRule(_localctx, 148, HplsqlParser::RuleCreate_routine_params);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1558);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 162, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1536);
      match(HplsqlParser::T_OPEN_P);
      setState(1537);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1538);
      match(HplsqlParser::T_OPEN_P);
      setState(1539);
      create_routine_param_item();
      setState(1544);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == HplsqlParser::T_COMMA) {
        setState(1540);
        match(HplsqlParser::T_COMMA);
        setState(1541);
        create_routine_param_item();
        setState(1546);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1547);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1549);

      if (!(strcasecmp(_input->LT(1)->getText().data(), "IS") &&
              strcasecmp(_input->LT(1)->getText().data(), "AS") &&
              strcasecmp(_input->LT(1)->getText().data(), "DYNAMIC") && strcasecmp(_input->LT(2)->getText().data(), "RESULT")
              )) throw FailedPredicateException(this, "strcasecmp(_input->LT(1)->getText().data(), \"IS\") &&\n        strcasecmp(_input->LT(1)->getText().data(), \"AS\") &&\n        strcasecmp(_input->LT(1)->getText().data(), \"DYNAMIC\") && strcasecmp(_input->LT(2)->getText().data(), \"RESULT\")\n        ");
      setState(1550);
      create_routine_param_item();
      setState(1555);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1551);
          match(HplsqlParser::T_COMMA);
          setState(1552);
          create_routine_param_item(); 
        }
        setState(1557);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, _ctx);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_routine_param_itemContext ------------------------------------------------------------------

HplsqlParser::Create_routine_param_itemContext::Create_routine_param_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::IdentContext* HplsqlParser::Create_routine_param_itemContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

HplsqlParser::DtypeContext* HplsqlParser::Create_routine_param_itemContext::dtype() {
  return getRuleContext<HplsqlParser::DtypeContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_routine_param_itemContext::T_IN() {
  return getToken(HplsqlParser::T_IN, 0);
}

tree::TerminalNode* HplsqlParser::Create_routine_param_itemContext::T_OUT() {
  return getToken(HplsqlParser::T_OUT, 0);
}

tree::TerminalNode* HplsqlParser::Create_routine_param_itemContext::T_INOUT() {
  return getToken(HplsqlParser::T_INOUT, 0);
}

HplsqlParser::Dtype_lenContext* HplsqlParser::Create_routine_param_itemContext::dtype_len() {
  return getRuleContext<HplsqlParser::Dtype_lenContext>(0);
}

std::vector<HplsqlParser::Dtype_attrContext *> HplsqlParser::Create_routine_param_itemContext::dtype_attr() {
  return getRuleContexts<HplsqlParser::Dtype_attrContext>();
}

HplsqlParser::Dtype_attrContext* HplsqlParser::Create_routine_param_itemContext::dtype_attr(size_t i) {
  return getRuleContext<HplsqlParser::Dtype_attrContext>(i);
}

HplsqlParser::Dtype_defaultContext* HplsqlParser::Create_routine_param_itemContext::dtype_default() {
  return getRuleContext<HplsqlParser::Dtype_defaultContext>(0);
}


size_t HplsqlParser::Create_routine_param_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_routine_param_item;
}

void HplsqlParser::Create_routine_param_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_routine_param_item(this);
}

void HplsqlParser::Create_routine_param_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_routine_param_item(this);
}


antlrcpp::Any HplsqlParser::Create_routine_param_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_routine_param_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_routine_param_itemContext* HplsqlParser::create_routine_param_item() {
  Create_routine_param_itemContext *_localctx = _tracker.createInstance<Create_routine_param_itemContext>(_ctx, getState());
  enterRule(_localctx, 150, HplsqlParser::RuleCreate_routine_param_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1602);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 171, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1565);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 163, _ctx)) {
      case 1: {
        setState(1560);
        match(HplsqlParser::T_IN);
        break;
      }

      case 2: {
        setState(1561);
        match(HplsqlParser::T_OUT);
        break;
      }

      case 3: {
        setState(1562);
        match(HplsqlParser::T_INOUT);
        break;
      }

      case 4: {
        setState(1563);
        match(HplsqlParser::T_IN);
        setState(1564);
        match(HplsqlParser::T_OUT);
        break;
      }

      default:
        break;
      }
      setState(1567);
      ident();
      setState(1568);
      dtype();
      setState(1570);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, _ctx)) {
      case 1: {
        setState(1569);
        dtype_len();
        break;
      }

      default:
        break;
      }
      setState(1575);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1572);
          dtype_attr(); 
        }
        setState(1577);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx);
      }
      setState(1579);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 166, _ctx)) {
      case 1: {
        setState(1578);
        dtype_default();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1581);
      ident();
      setState(1587);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, _ctx)) {
      case 1: {
        setState(1582);
        match(HplsqlParser::T_IN);
        break;
      }

      case 2: {
        setState(1583);
        match(HplsqlParser::T_OUT);
        break;
      }

      case 3: {
        setState(1584);
        match(HplsqlParser::T_INOUT);
        break;
      }

      case 4: {
        setState(1585);
        match(HplsqlParser::T_IN);
        setState(1586);
        match(HplsqlParser::T_OUT);
        break;
      }

      default:
        break;
      }
      setState(1589);
      dtype();
      setState(1591);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 168, _ctx)) {
      case 1: {
        setState(1590);
        dtype_len();
        break;
      }

      default:
        break;
      }
      setState(1596);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1593);
          dtype_attr(); 
        }
        setState(1598);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx);
      }
      setState(1600);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 170, _ctx)) {
      case 1: {
        setState(1599);
        dtype_default();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_routine_optionsContext ------------------------------------------------------------------

HplsqlParser::Create_routine_optionsContext::Create_routine_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HplsqlParser::Create_routine_optionContext *> HplsqlParser::Create_routine_optionsContext::create_routine_option() {
  return getRuleContexts<HplsqlParser::Create_routine_optionContext>();
}

HplsqlParser::Create_routine_optionContext* HplsqlParser::Create_routine_optionsContext::create_routine_option(size_t i) {
  return getRuleContext<HplsqlParser::Create_routine_optionContext>(i);
}


size_t HplsqlParser::Create_routine_optionsContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_routine_options;
}

void HplsqlParser::Create_routine_optionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_routine_options(this);
}

void HplsqlParser::Create_routine_optionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_routine_options(this);
}


antlrcpp::Any HplsqlParser::Create_routine_optionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_routine_options(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_routine_optionsContext* HplsqlParser::create_routine_options() {
  Create_routine_optionsContext *_localctx = _tracker.createInstance<Create_routine_optionsContext>(_ctx, getState());
  enterRule(_localctx, 152, HplsqlParser::RuleCreate_routine_options);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1605); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1604);
              create_routine_option();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1607); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 172, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_routine_optionContext ------------------------------------------------------------------

HplsqlParser::Create_routine_optionContext::Create_routine_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_routine_optionContext::T_LANGUAGE() {
  return getToken(HplsqlParser::T_LANGUAGE, 0);
}

tree::TerminalNode* HplsqlParser::Create_routine_optionContext::T_SQL() {
  return getToken(HplsqlParser::T_SQL, 0);
}

tree::TerminalNode* HplsqlParser::Create_routine_optionContext::T_SECURITY() {
  return getToken(HplsqlParser::T_SECURITY, 0);
}

tree::TerminalNode* HplsqlParser::Create_routine_optionContext::T_CREATOR() {
  return getToken(HplsqlParser::T_CREATOR, 0);
}

tree::TerminalNode* HplsqlParser::Create_routine_optionContext::T_DEFINER() {
  return getToken(HplsqlParser::T_DEFINER, 0);
}

tree::TerminalNode* HplsqlParser::Create_routine_optionContext::T_INVOKER() {
  return getToken(HplsqlParser::T_INVOKER, 0);
}

tree::TerminalNode* HplsqlParser::Create_routine_optionContext::T_OWNER() {
  return getToken(HplsqlParser::T_OWNER, 0);
}

tree::TerminalNode* HplsqlParser::Create_routine_optionContext::T_RESULT() {
  return getToken(HplsqlParser::T_RESULT, 0);
}

tree::TerminalNode* HplsqlParser::Create_routine_optionContext::T_SETS() {
  return getToken(HplsqlParser::T_SETS, 0);
}

tree::TerminalNode* HplsqlParser::Create_routine_optionContext::L_INT() {
  return getToken(HplsqlParser::L_INT, 0);
}

tree::TerminalNode* HplsqlParser::Create_routine_optionContext::T_DYNAMIC() {
  return getToken(HplsqlParser::T_DYNAMIC, 0);
}


size_t HplsqlParser::Create_routine_optionContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_routine_option;
}

void HplsqlParser::Create_routine_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_routine_option(this);
}

void HplsqlParser::Create_routine_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_routine_option(this);
}


antlrcpp::Any HplsqlParser::Create_routine_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_routine_option(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_routine_optionContext* HplsqlParser::create_routine_option() {
  Create_routine_optionContext *_localctx = _tracker.createInstance<Create_routine_optionContext>(_ctx, getState());
  enterRule(_localctx, 154, HplsqlParser::RuleCreate_routine_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1620);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_LANGUAGE: {
        enterOuterAlt(_localctx, 1);
        setState(1609);
        match(HplsqlParser::T_LANGUAGE);
        setState(1610);
        match(HplsqlParser::T_SQL);
        break;
      }

      case HplsqlParser::T_SQL: {
        enterOuterAlt(_localctx, 2);
        setState(1611);
        match(HplsqlParser::T_SQL);
        setState(1612);
        match(HplsqlParser::T_SECURITY);
        setState(1613);
        _la = _input->LA(1);
        if (!(_la == HplsqlParser::T_CREATOR

        || _la == HplsqlParser::T_DEFINER || _la == HplsqlParser::T_INVOKER

        || _la == HplsqlParser::T_OWNER)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case HplsqlParser::T_DYNAMIC:
      case HplsqlParser::T_RESULT: {
        enterOuterAlt(_localctx, 3);
        setState(1615);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_DYNAMIC) {
          setState(1614);
          match(HplsqlParser::T_DYNAMIC);
        }
        setState(1617);
        match(HplsqlParser::T_RESULT);
        setState(1618);
        match(HplsqlParser::T_SETS);
        setState(1619);
        match(HplsqlParser::L_INT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_stmtContext ------------------------------------------------------------------

HplsqlParser::Drop_stmtContext::Drop_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Drop_stmtContext::T_DROP() {
  return getToken(HplsqlParser::T_DROP, 0);
}

tree::TerminalNode* HplsqlParser::Drop_stmtContext::T_TABLE() {
  return getToken(HplsqlParser::T_TABLE, 0);
}

HplsqlParser::Table_nameContext* HplsqlParser::Drop_stmtContext::table_name() {
  return getRuleContext<HplsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* HplsqlParser::Drop_stmtContext::T_IF() {
  return getToken(HplsqlParser::T_IF, 0);
}

tree::TerminalNode* HplsqlParser::Drop_stmtContext::T_EXISTS() {
  return getToken(HplsqlParser::T_EXISTS, 0);
}

HplsqlParser::ExprContext* HplsqlParser::Drop_stmtContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}

tree::TerminalNode* HplsqlParser::Drop_stmtContext::T_DATABASE() {
  return getToken(HplsqlParser::T_DATABASE, 0);
}

tree::TerminalNode* HplsqlParser::Drop_stmtContext::T_SCHEMA() {
  return getToken(HplsqlParser::T_SCHEMA, 0);
}


size_t HplsqlParser::Drop_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleDrop_stmt;
}

void HplsqlParser::Drop_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_stmt(this);
}

void HplsqlParser::Drop_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_stmt(this);
}


antlrcpp::Any HplsqlParser::Drop_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitDrop_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Drop_stmtContext* HplsqlParser::drop_stmt() {
  Drop_stmtContext *_localctx = _tracker.createInstance<Drop_stmtContext>(_ctx, getState());
  enterRule(_localctx, 156, HplsqlParser::RuleDrop_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1636);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 177, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1622);
      match(HplsqlParser::T_DROP);
      setState(1623);
      match(HplsqlParser::T_TABLE);
      setState(1626);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 175, _ctx)) {
      case 1: {
        setState(1624);
        match(HplsqlParser::T_IF);
        setState(1625);
        match(HplsqlParser::T_EXISTS);
        break;
      }

      default:
        break;
      }
      setState(1628);
      table_name();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1629);
      match(HplsqlParser::T_DROP);
      setState(1630);
      _la = _input->LA(1);
      if (!(_la == HplsqlParser::T_DATABASE || _la == HplsqlParser::T_SCHEMA)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1633);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 176, _ctx)) {
      case 1: {
        setState(1631);
        match(HplsqlParser::T_IF);
        setState(1632);
        match(HplsqlParser::T_EXISTS);
        break;
      }

      default:
        break;
      }
      setState(1635);
      expr(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- End_transaction_stmtContext ------------------------------------------------------------------

HplsqlParser::End_transaction_stmtContext::End_transaction_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::End_transaction_stmtContext::T_END() {
  return getToken(HplsqlParser::T_END, 0);
}

tree::TerminalNode* HplsqlParser::End_transaction_stmtContext::T_TRANSACTION() {
  return getToken(HplsqlParser::T_TRANSACTION, 0);
}


size_t HplsqlParser::End_transaction_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleEnd_transaction_stmt;
}

void HplsqlParser::End_transaction_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnd_transaction_stmt(this);
}

void HplsqlParser::End_transaction_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnd_transaction_stmt(this);
}


antlrcpp::Any HplsqlParser::End_transaction_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitEnd_transaction_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::End_transaction_stmtContext* HplsqlParser::end_transaction_stmt() {
  End_transaction_stmtContext *_localctx = _tracker.createInstance<End_transaction_stmtContext>(_ctx, getState());
  enterRule(_localctx, 158, HplsqlParser::RuleEnd_transaction_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1638);
    match(HplsqlParser::T_END);
    setState(1639);
    match(HplsqlParser::T_TRANSACTION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Exec_stmtContext ------------------------------------------------------------------

HplsqlParser::Exec_stmtContext::Exec_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::ExprContext* HplsqlParser::Exec_stmtContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}

tree::TerminalNode* HplsqlParser::Exec_stmtContext::T_EXEC() {
  return getToken(HplsqlParser::T_EXEC, 0);
}

tree::TerminalNode* HplsqlParser::Exec_stmtContext::T_EXECUTE() {
  return getToken(HplsqlParser::T_EXECUTE, 0);
}

tree::TerminalNode* HplsqlParser::Exec_stmtContext::T_IMMEDIATE() {
  return getToken(HplsqlParser::T_IMMEDIATE, 0);
}

tree::TerminalNode* HplsqlParser::Exec_stmtContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

HplsqlParser::Expr_func_paramsContext* HplsqlParser::Exec_stmtContext::expr_func_params() {
  return getRuleContext<HplsqlParser::Expr_func_paramsContext>(0);
}

tree::TerminalNode* HplsqlParser::Exec_stmtContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

tree::TerminalNode* HplsqlParser::Exec_stmtContext::T_INTO() {
  return getToken(HplsqlParser::T_INTO, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Exec_stmtContext::L_ID() {
  return getTokens(HplsqlParser::L_ID);
}

tree::TerminalNode* HplsqlParser::Exec_stmtContext::L_ID(size_t i) {
  return getToken(HplsqlParser::L_ID, i);
}

HplsqlParser::Using_clauseContext* HplsqlParser::Exec_stmtContext::using_clause() {
  return getRuleContext<HplsqlParser::Using_clauseContext>(0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Exec_stmtContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Exec_stmtContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Exec_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleExec_stmt;
}

void HplsqlParser::Exec_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExec_stmt(this);
}

void HplsqlParser::Exec_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExec_stmt(this);
}


antlrcpp::Any HplsqlParser::Exec_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitExec_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Exec_stmtContext* HplsqlParser::exec_stmt() {
  Exec_stmtContext *_localctx = _tracker.createInstance<Exec_stmtContext>(_ctx, getState());
  enterRule(_localctx, 160, HplsqlParser::RuleExec_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1641);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_EXEC

    || _la == HplsqlParser::T_EXECUTE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1643);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 178, _ctx)) {
    case 1: {
      setState(1642);
      match(HplsqlParser::T_IMMEDIATE);
      break;
    }

    default:
      break;
    }
    setState(1645);
    expr(0);
    setState(1651);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 179, _ctx)) {
    case 1: {
      setState(1646);
      match(HplsqlParser::T_OPEN_P);
      setState(1647);
      expr_func_params();
      setState(1648);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 2: {
      setState(1650);
      expr_func_params();
      break;
    }

    default:
      break;
    }
    setState(1662);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 181, _ctx)) {
    case 1: {
      setState(1653);
      match(HplsqlParser::T_INTO);
      setState(1654);
      match(HplsqlParser::L_ID);
      setState(1659);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 180, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1655);
          match(HplsqlParser::T_COMMA);
          setState(1656);
          match(HplsqlParser::L_ID); 
        }
        setState(1661);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 180, _ctx);
      }
      break;
    }

    default:
      break;
    }
    setState(1665);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 182, _ctx)) {
    case 1: {
      setState(1664);
      using_clause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_stmtContext ------------------------------------------------------------------

HplsqlParser::If_stmtContext::If_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::If_plsql_stmtContext* HplsqlParser::If_stmtContext::if_plsql_stmt() {
  return getRuleContext<HplsqlParser::If_plsql_stmtContext>(0);
}

HplsqlParser::If_tsql_stmtContext* HplsqlParser::If_stmtContext::if_tsql_stmt() {
  return getRuleContext<HplsqlParser::If_tsql_stmtContext>(0);
}

HplsqlParser::If_bteq_stmtContext* HplsqlParser::If_stmtContext::if_bteq_stmt() {
  return getRuleContext<HplsqlParser::If_bteq_stmtContext>(0);
}


size_t HplsqlParser::If_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleIf_stmt;
}

void HplsqlParser::If_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIf_stmt(this);
}

void HplsqlParser::If_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIf_stmt(this);
}


antlrcpp::Any HplsqlParser::If_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitIf_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::If_stmtContext* HplsqlParser::if_stmt() {
  If_stmtContext *_localctx = _tracker.createInstance<If_stmtContext>(_ctx, getState());
  enterRule(_localctx, 162, HplsqlParser::RuleIf_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1670);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 183, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1667);
      if_plsql_stmt();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1668);
      if_tsql_stmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1669);
      if_bteq_stmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_plsql_stmtContext ------------------------------------------------------------------

HplsqlParser::If_plsql_stmtContext::If_plsql_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> HplsqlParser::If_plsql_stmtContext::T_IF() {
  return getTokens(HplsqlParser::T_IF);
}

tree::TerminalNode* HplsqlParser::If_plsql_stmtContext::T_IF(size_t i) {
  return getToken(HplsqlParser::T_IF, i);
}

HplsqlParser::Bool_exprContext* HplsqlParser::If_plsql_stmtContext::bool_expr() {
  return getRuleContext<HplsqlParser::Bool_exprContext>(0);
}

tree::TerminalNode* HplsqlParser::If_plsql_stmtContext::T_THEN() {
  return getToken(HplsqlParser::T_THEN, 0);
}

HplsqlParser::BlockContext* HplsqlParser::If_plsql_stmtContext::block() {
  return getRuleContext<HplsqlParser::BlockContext>(0);
}

tree::TerminalNode* HplsqlParser::If_plsql_stmtContext::T_END() {
  return getToken(HplsqlParser::T_END, 0);
}

std::vector<HplsqlParser::Elseif_blockContext *> HplsqlParser::If_plsql_stmtContext::elseif_block() {
  return getRuleContexts<HplsqlParser::Elseif_blockContext>();
}

HplsqlParser::Elseif_blockContext* HplsqlParser::If_plsql_stmtContext::elseif_block(size_t i) {
  return getRuleContext<HplsqlParser::Elseif_blockContext>(i);
}

HplsqlParser::Else_blockContext* HplsqlParser::If_plsql_stmtContext::else_block() {
  return getRuleContext<HplsqlParser::Else_blockContext>(0);
}


size_t HplsqlParser::If_plsql_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleIf_plsql_stmt;
}

void HplsqlParser::If_plsql_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIf_plsql_stmt(this);
}

void HplsqlParser::If_plsql_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIf_plsql_stmt(this);
}


antlrcpp::Any HplsqlParser::If_plsql_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitIf_plsql_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::If_plsql_stmtContext* HplsqlParser::if_plsql_stmt() {
  If_plsql_stmtContext *_localctx = _tracker.createInstance<If_plsql_stmtContext>(_ctx, getState());
  enterRule(_localctx, 164, HplsqlParser::RuleIf_plsql_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1672);
    match(HplsqlParser::T_IF);
    setState(1673);
    bool_expr(0);
    setState(1674);
    match(HplsqlParser::T_THEN);
    setState(1675);
    block();
    setState(1679);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HplsqlParser::T_ELSEIF

    || _la == HplsqlParser::T_ELSIF) {
      setState(1676);
      elseif_block();
      setState(1681);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1683);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_ELSE) {
      setState(1682);
      else_block();
    }
    setState(1685);
    match(HplsqlParser::T_END);
    setState(1686);
    match(HplsqlParser::T_IF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_tsql_stmtContext ------------------------------------------------------------------

HplsqlParser::If_tsql_stmtContext::If_tsql_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::If_tsql_stmtContext::T_IF() {
  return getToken(HplsqlParser::T_IF, 0);
}

HplsqlParser::Bool_exprContext* HplsqlParser::If_tsql_stmtContext::bool_expr() {
  return getRuleContext<HplsqlParser::Bool_exprContext>(0);
}

std::vector<HplsqlParser::Single_block_stmtContext *> HplsqlParser::If_tsql_stmtContext::single_block_stmt() {
  return getRuleContexts<HplsqlParser::Single_block_stmtContext>();
}

HplsqlParser::Single_block_stmtContext* HplsqlParser::If_tsql_stmtContext::single_block_stmt(size_t i) {
  return getRuleContext<HplsqlParser::Single_block_stmtContext>(i);
}

tree::TerminalNode* HplsqlParser::If_tsql_stmtContext::T_ELSE() {
  return getToken(HplsqlParser::T_ELSE, 0);
}


size_t HplsqlParser::If_tsql_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleIf_tsql_stmt;
}

void HplsqlParser::If_tsql_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIf_tsql_stmt(this);
}

void HplsqlParser::If_tsql_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIf_tsql_stmt(this);
}


antlrcpp::Any HplsqlParser::If_tsql_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitIf_tsql_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::If_tsql_stmtContext* HplsqlParser::if_tsql_stmt() {
  If_tsql_stmtContext *_localctx = _tracker.createInstance<If_tsql_stmtContext>(_ctx, getState());
  enterRule(_localctx, 166, HplsqlParser::RuleIf_tsql_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1688);
    match(HplsqlParser::T_IF);
    setState(1689);
    bool_expr(0);
    setState(1690);
    single_block_stmt();
    setState(1693);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 186, _ctx)) {
    case 1: {
      setState(1691);
      match(HplsqlParser::T_ELSE);
      setState(1692);
      single_block_stmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_bteq_stmtContext ------------------------------------------------------------------

HplsqlParser::If_bteq_stmtContext::If_bteq_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::If_bteq_stmtContext::T_IF() {
  return getToken(HplsqlParser::T_IF, 0);
}

HplsqlParser::Bool_exprContext* HplsqlParser::If_bteq_stmtContext::bool_expr() {
  return getRuleContext<HplsqlParser::Bool_exprContext>(0);
}

tree::TerminalNode* HplsqlParser::If_bteq_stmtContext::T_THEN() {
  return getToken(HplsqlParser::T_THEN, 0);
}

HplsqlParser::Single_block_stmtContext* HplsqlParser::If_bteq_stmtContext::single_block_stmt() {
  return getRuleContext<HplsqlParser::Single_block_stmtContext>(0);
}


size_t HplsqlParser::If_bteq_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleIf_bteq_stmt;
}

void HplsqlParser::If_bteq_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIf_bteq_stmt(this);
}

void HplsqlParser::If_bteq_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIf_bteq_stmt(this);
}


antlrcpp::Any HplsqlParser::If_bteq_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitIf_bteq_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::If_bteq_stmtContext* HplsqlParser::if_bteq_stmt() {
  If_bteq_stmtContext *_localctx = _tracker.createInstance<If_bteq_stmtContext>(_ctx, getState());
  enterRule(_localctx, 168, HplsqlParser::RuleIf_bteq_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1695);
    match(HplsqlParser::T__3);
    setState(1696);
    match(HplsqlParser::T_IF);
    setState(1697);
    bool_expr(0);
    setState(1698);
    match(HplsqlParser::T_THEN);
    setState(1699);
    single_block_stmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Elseif_blockContext ------------------------------------------------------------------

HplsqlParser::Elseif_blockContext::Elseif_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Bool_exprContext* HplsqlParser::Elseif_blockContext::bool_expr() {
  return getRuleContext<HplsqlParser::Bool_exprContext>(0);
}

tree::TerminalNode* HplsqlParser::Elseif_blockContext::T_THEN() {
  return getToken(HplsqlParser::T_THEN, 0);
}

HplsqlParser::BlockContext* HplsqlParser::Elseif_blockContext::block() {
  return getRuleContext<HplsqlParser::BlockContext>(0);
}

tree::TerminalNode* HplsqlParser::Elseif_blockContext::T_ELSIF() {
  return getToken(HplsqlParser::T_ELSIF, 0);
}

tree::TerminalNode* HplsqlParser::Elseif_blockContext::T_ELSEIF() {
  return getToken(HplsqlParser::T_ELSEIF, 0);
}


size_t HplsqlParser::Elseif_blockContext::getRuleIndex() const {
  return HplsqlParser::RuleElseif_block;
}

void HplsqlParser::Elseif_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElseif_block(this);
}

void HplsqlParser::Elseif_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElseif_block(this);
}


antlrcpp::Any HplsqlParser::Elseif_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitElseif_block(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Elseif_blockContext* HplsqlParser::elseif_block() {
  Elseif_blockContext *_localctx = _tracker.createInstance<Elseif_blockContext>(_ctx, getState());
  enterRule(_localctx, 170, HplsqlParser::RuleElseif_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1701);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_ELSEIF

    || _la == HplsqlParser::T_ELSIF)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1702);
    bool_expr(0);
    setState(1703);
    match(HplsqlParser::T_THEN);
    setState(1704);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Else_blockContext ------------------------------------------------------------------

HplsqlParser::Else_blockContext::Else_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Else_blockContext::T_ELSE() {
  return getToken(HplsqlParser::T_ELSE, 0);
}

HplsqlParser::BlockContext* HplsqlParser::Else_blockContext::block() {
  return getRuleContext<HplsqlParser::BlockContext>(0);
}


size_t HplsqlParser::Else_blockContext::getRuleIndex() const {
  return HplsqlParser::RuleElse_block;
}

void HplsqlParser::Else_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElse_block(this);
}

void HplsqlParser::Else_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElse_block(this);
}


antlrcpp::Any HplsqlParser::Else_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitElse_block(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Else_blockContext* HplsqlParser::else_block() {
  Else_blockContext *_localctx = _tracker.createInstance<Else_blockContext>(_ctx, getState());
  enterRule(_localctx, 172, HplsqlParser::RuleElse_block);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1706);
    match(HplsqlParser::T_ELSE);
    setState(1707);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Include_stmtContext ------------------------------------------------------------------

HplsqlParser::Include_stmtContext::Include_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Include_stmtContext::T_INCLUDE() {
  return getToken(HplsqlParser::T_INCLUDE, 0);
}

HplsqlParser::File_nameContext* HplsqlParser::Include_stmtContext::file_name() {
  return getRuleContext<HplsqlParser::File_nameContext>(0);
}

HplsqlParser::ExprContext* HplsqlParser::Include_stmtContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}


size_t HplsqlParser::Include_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleInclude_stmt;
}

void HplsqlParser::Include_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInclude_stmt(this);
}

void HplsqlParser::Include_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInclude_stmt(this);
}


antlrcpp::Any HplsqlParser::Include_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitInclude_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Include_stmtContext* HplsqlParser::include_stmt() {
  Include_stmtContext *_localctx = _tracker.createInstance<Include_stmtContext>(_ctx, getState());
  enterRule(_localctx, 174, HplsqlParser::RuleInclude_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1709);
    match(HplsqlParser::T_INCLUDE);
    setState(1712);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 187, _ctx)) {
    case 1: {
      setState(1710);
      file_name();
      break;
    }

    case 2: {
      setState(1711);
      expr(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_stmtContext ------------------------------------------------------------------

HplsqlParser::Insert_stmtContext::Insert_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Insert_stmtContext::T_INSERT() {
  return getToken(HplsqlParser::T_INSERT, 0);
}

HplsqlParser::Table_nameContext* HplsqlParser::Insert_stmtContext::table_name() {
  return getRuleContext<HplsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* HplsqlParser::Insert_stmtContext::T_OVERWRITE() {
  return getToken(HplsqlParser::T_OVERWRITE, 0);
}

tree::TerminalNode* HplsqlParser::Insert_stmtContext::T_TABLE() {
  return getToken(HplsqlParser::T_TABLE, 0);
}

tree::TerminalNode* HplsqlParser::Insert_stmtContext::T_INTO() {
  return getToken(HplsqlParser::T_INTO, 0);
}

HplsqlParser::Select_stmtContext* HplsqlParser::Insert_stmtContext::select_stmt() {
  return getRuleContext<HplsqlParser::Select_stmtContext>(0);
}

HplsqlParser::Insert_stmt_rowsContext* HplsqlParser::Insert_stmtContext::insert_stmt_rows() {
  return getRuleContext<HplsqlParser::Insert_stmt_rowsContext>(0);
}

HplsqlParser::Insert_stmt_colsContext* HplsqlParser::Insert_stmtContext::insert_stmt_cols() {
  return getRuleContext<HplsqlParser::Insert_stmt_colsContext>(0);
}


size_t HplsqlParser::Insert_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleInsert_stmt;
}

void HplsqlParser::Insert_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_stmt(this);
}

void HplsqlParser::Insert_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_stmt(this);
}


antlrcpp::Any HplsqlParser::Insert_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitInsert_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Insert_stmtContext* HplsqlParser::insert_stmt() {
  Insert_stmtContext *_localctx = _tracker.createInstance<Insert_stmtContext>(_ctx, getState());
  enterRule(_localctx, 176, HplsqlParser::RuleInsert_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1714);
    match(HplsqlParser::T_INSERT);
    setState(1721);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_OVERWRITE: {
        setState(1715);
        match(HplsqlParser::T_OVERWRITE);
        setState(1716);
        match(HplsqlParser::T_TABLE);
        break;
      }

      case HplsqlParser::T_INTO: {
        setState(1717);
        match(HplsqlParser::T_INTO);
        setState(1719);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 188, _ctx)) {
        case 1: {
          setState(1718);
          match(HplsqlParser::T_TABLE);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1723);
    table_name();
    setState(1725);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 190, _ctx)) {
    case 1: {
      setState(1724);
      insert_stmt_cols();
      break;
    }

    default:
      break;
    }
    setState(1729);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_SEL:
      case HplsqlParser::T_SELECT:
      case HplsqlParser::T_WITH:
      case HplsqlParser::T_OPEN_P: {
        setState(1727);
        select_stmt();
        break;
      }

      case HplsqlParser::T_VALUES: {
        setState(1728);
        insert_stmt_rows();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_stmt_colsContext ------------------------------------------------------------------

HplsqlParser::Insert_stmt_colsContext::Insert_stmt_colsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Insert_stmt_colsContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

std::vector<HplsqlParser::IdentContext *> HplsqlParser::Insert_stmt_colsContext::ident() {
  return getRuleContexts<HplsqlParser::IdentContext>();
}

HplsqlParser::IdentContext* HplsqlParser::Insert_stmt_colsContext::ident(size_t i) {
  return getRuleContext<HplsqlParser::IdentContext>(i);
}

tree::TerminalNode* HplsqlParser::Insert_stmt_colsContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Insert_stmt_colsContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Insert_stmt_colsContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Insert_stmt_colsContext::getRuleIndex() const {
  return HplsqlParser::RuleInsert_stmt_cols;
}

void HplsqlParser::Insert_stmt_colsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_stmt_cols(this);
}

void HplsqlParser::Insert_stmt_colsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_stmt_cols(this);
}


antlrcpp::Any HplsqlParser::Insert_stmt_colsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitInsert_stmt_cols(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Insert_stmt_colsContext* HplsqlParser::insert_stmt_cols() {
  Insert_stmt_colsContext *_localctx = _tracker.createInstance<Insert_stmt_colsContext>(_ctx, getState());
  enterRule(_localctx, 178, HplsqlParser::RuleInsert_stmt_cols);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1731);
    match(HplsqlParser::T_OPEN_P);
    setState(1732);
    ident();
    setState(1737);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HplsqlParser::T_COMMA) {
      setState(1733);
      match(HplsqlParser::T_COMMA);
      setState(1734);
      ident();
      setState(1739);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1740);
    match(HplsqlParser::T_CLOSE_P);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_stmt_rowsContext ------------------------------------------------------------------

HplsqlParser::Insert_stmt_rowsContext::Insert_stmt_rowsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Insert_stmt_rowsContext::T_VALUES() {
  return getToken(HplsqlParser::T_VALUES, 0);
}

std::vector<HplsqlParser::Insert_stmt_rowContext *> HplsqlParser::Insert_stmt_rowsContext::insert_stmt_row() {
  return getRuleContexts<HplsqlParser::Insert_stmt_rowContext>();
}

HplsqlParser::Insert_stmt_rowContext* HplsqlParser::Insert_stmt_rowsContext::insert_stmt_row(size_t i) {
  return getRuleContext<HplsqlParser::Insert_stmt_rowContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Insert_stmt_rowsContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Insert_stmt_rowsContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Insert_stmt_rowsContext::getRuleIndex() const {
  return HplsqlParser::RuleInsert_stmt_rows;
}

void HplsqlParser::Insert_stmt_rowsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_stmt_rows(this);
}

void HplsqlParser::Insert_stmt_rowsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_stmt_rows(this);
}


antlrcpp::Any HplsqlParser::Insert_stmt_rowsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitInsert_stmt_rows(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Insert_stmt_rowsContext* HplsqlParser::insert_stmt_rows() {
  Insert_stmt_rowsContext *_localctx = _tracker.createInstance<Insert_stmt_rowsContext>(_ctx, getState());
  enterRule(_localctx, 180, HplsqlParser::RuleInsert_stmt_rows);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1742);
    match(HplsqlParser::T_VALUES);
    setState(1743);
    insert_stmt_row();
    setState(1748);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 193, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1744);
        match(HplsqlParser::T_COMMA);
        setState(1745);
        insert_stmt_row(); 
      }
      setState(1750);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 193, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_stmt_rowContext ------------------------------------------------------------------

HplsqlParser::Insert_stmt_rowContext::Insert_stmt_rowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Insert_stmt_rowContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

std::vector<HplsqlParser::ExprContext *> HplsqlParser::Insert_stmt_rowContext::expr() {
  return getRuleContexts<HplsqlParser::ExprContext>();
}

HplsqlParser::ExprContext* HplsqlParser::Insert_stmt_rowContext::expr(size_t i) {
  return getRuleContext<HplsqlParser::ExprContext>(i);
}

tree::TerminalNode* HplsqlParser::Insert_stmt_rowContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Insert_stmt_rowContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Insert_stmt_rowContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Insert_stmt_rowContext::getRuleIndex() const {
  return HplsqlParser::RuleInsert_stmt_row;
}

void HplsqlParser::Insert_stmt_rowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_stmt_row(this);
}

void HplsqlParser::Insert_stmt_rowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_stmt_row(this);
}


antlrcpp::Any HplsqlParser::Insert_stmt_rowContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitInsert_stmt_row(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Insert_stmt_rowContext* HplsqlParser::insert_stmt_row() {
  Insert_stmt_rowContext *_localctx = _tracker.createInstance<Insert_stmt_rowContext>(_ctx, getState());
  enterRule(_localctx, 182, HplsqlParser::RuleInsert_stmt_row);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1751);
    match(HplsqlParser::T_OPEN_P);
    setState(1752);
    expr(0);
    setState(1757);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HplsqlParser::T_COMMA) {
      setState(1753);
      match(HplsqlParser::T_COMMA);
      setState(1754);
      expr(0);
      setState(1759);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1760);
    match(HplsqlParser::T_CLOSE_P);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_directory_stmtContext ------------------------------------------------------------------

HplsqlParser::Insert_directory_stmtContext::Insert_directory_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Insert_directory_stmtContext::T_INSERT() {
  return getToken(HplsqlParser::T_INSERT, 0);
}

tree::TerminalNode* HplsqlParser::Insert_directory_stmtContext::T_OVERWRITE() {
  return getToken(HplsqlParser::T_OVERWRITE, 0);
}

tree::TerminalNode* HplsqlParser::Insert_directory_stmtContext::T_DIRECTORY() {
  return getToken(HplsqlParser::T_DIRECTORY, 0);
}

HplsqlParser::Expr_fileContext* HplsqlParser::Insert_directory_stmtContext::expr_file() {
  return getRuleContext<HplsqlParser::Expr_fileContext>(0);
}

HplsqlParser::Expr_selectContext* HplsqlParser::Insert_directory_stmtContext::expr_select() {
  return getRuleContext<HplsqlParser::Expr_selectContext>(0);
}

tree::TerminalNode* HplsqlParser::Insert_directory_stmtContext::T_LOCAL() {
  return getToken(HplsqlParser::T_LOCAL, 0);
}


size_t HplsqlParser::Insert_directory_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleInsert_directory_stmt;
}

void HplsqlParser::Insert_directory_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_directory_stmt(this);
}

void HplsqlParser::Insert_directory_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_directory_stmt(this);
}


antlrcpp::Any HplsqlParser::Insert_directory_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitInsert_directory_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Insert_directory_stmtContext* HplsqlParser::insert_directory_stmt() {
  Insert_directory_stmtContext *_localctx = _tracker.createInstance<Insert_directory_stmtContext>(_ctx, getState());
  enterRule(_localctx, 184, HplsqlParser::RuleInsert_directory_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1762);
    match(HplsqlParser::T_INSERT);
    setState(1763);
    match(HplsqlParser::T_OVERWRITE);
    setState(1765);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_LOCAL) {
      setState(1764);
      match(HplsqlParser::T_LOCAL);
    }
    setState(1767);
    match(HplsqlParser::T_DIRECTORY);
    setState(1768);
    expr_file();
    setState(1769);
    expr_select();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Exit_stmtContext ------------------------------------------------------------------

HplsqlParser::Exit_stmtContext::Exit_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Exit_stmtContext::T_EXIT() {
  return getToken(HplsqlParser::T_EXIT, 0);
}

tree::TerminalNode* HplsqlParser::Exit_stmtContext::L_ID() {
  return getToken(HplsqlParser::L_ID, 0);
}

tree::TerminalNode* HplsqlParser::Exit_stmtContext::T_WHEN() {
  return getToken(HplsqlParser::T_WHEN, 0);
}

HplsqlParser::Bool_exprContext* HplsqlParser::Exit_stmtContext::bool_expr() {
  return getRuleContext<HplsqlParser::Bool_exprContext>(0);
}


size_t HplsqlParser::Exit_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleExit_stmt;
}

void HplsqlParser::Exit_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExit_stmt(this);
}

void HplsqlParser::Exit_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExit_stmt(this);
}


antlrcpp::Any HplsqlParser::Exit_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitExit_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Exit_stmtContext* HplsqlParser::exit_stmt() {
  Exit_stmtContext *_localctx = _tracker.createInstance<Exit_stmtContext>(_ctx, getState());
  enterRule(_localctx, 186, HplsqlParser::RuleExit_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1771);
    match(HplsqlParser::T_EXIT);
    setState(1773);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 196, _ctx)) {
    case 1: {
      setState(1772);
      match(HplsqlParser::L_ID);
      break;
    }

    default:
      break;
    }
    setState(1777);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 197, _ctx)) {
    case 1: {
      setState(1775);
      match(HplsqlParser::T_WHEN);
      setState(1776);
      bool_expr(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Get_diag_stmtContext ------------------------------------------------------------------

HplsqlParser::Get_diag_stmtContext::Get_diag_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Get_diag_stmtContext::T_GET() {
  return getToken(HplsqlParser::T_GET, 0);
}

tree::TerminalNode* HplsqlParser::Get_diag_stmtContext::T_DIAGNOSTICS() {
  return getToken(HplsqlParser::T_DIAGNOSTICS, 0);
}

HplsqlParser::Get_diag_stmt_itemContext* HplsqlParser::Get_diag_stmtContext::get_diag_stmt_item() {
  return getRuleContext<HplsqlParser::Get_diag_stmt_itemContext>(0);
}


size_t HplsqlParser::Get_diag_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleGet_diag_stmt;
}

void HplsqlParser::Get_diag_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGet_diag_stmt(this);
}

void HplsqlParser::Get_diag_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGet_diag_stmt(this);
}


antlrcpp::Any HplsqlParser::Get_diag_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitGet_diag_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Get_diag_stmtContext* HplsqlParser::get_diag_stmt() {
  Get_diag_stmtContext *_localctx = _tracker.createInstance<Get_diag_stmtContext>(_ctx, getState());
  enterRule(_localctx, 188, HplsqlParser::RuleGet_diag_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1779);
    match(HplsqlParser::T_GET);
    setState(1780);
    match(HplsqlParser::T_DIAGNOSTICS);
    setState(1781);
    get_diag_stmt_item();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Get_diag_stmt_itemContext ------------------------------------------------------------------

HplsqlParser::Get_diag_stmt_itemContext::Get_diag_stmt_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Get_diag_stmt_exception_itemContext* HplsqlParser::Get_diag_stmt_itemContext::get_diag_stmt_exception_item() {
  return getRuleContext<HplsqlParser::Get_diag_stmt_exception_itemContext>(0);
}

HplsqlParser::Get_diag_stmt_rowcount_itemContext* HplsqlParser::Get_diag_stmt_itemContext::get_diag_stmt_rowcount_item() {
  return getRuleContext<HplsqlParser::Get_diag_stmt_rowcount_itemContext>(0);
}


size_t HplsqlParser::Get_diag_stmt_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleGet_diag_stmt_item;
}

void HplsqlParser::Get_diag_stmt_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGet_diag_stmt_item(this);
}

void HplsqlParser::Get_diag_stmt_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGet_diag_stmt_item(this);
}


antlrcpp::Any HplsqlParser::Get_diag_stmt_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitGet_diag_stmt_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Get_diag_stmt_itemContext* HplsqlParser::get_diag_stmt_item() {
  Get_diag_stmt_itemContext *_localctx = _tracker.createInstance<Get_diag_stmt_itemContext>(_ctx, getState());
  enterRule(_localctx, 190, HplsqlParser::RuleGet_diag_stmt_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1785);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 198, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1783);
      get_diag_stmt_exception_item();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1784);
      get_diag_stmt_rowcount_item();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Get_diag_stmt_exception_itemContext ------------------------------------------------------------------

HplsqlParser::Get_diag_stmt_exception_itemContext::Get_diag_stmt_exception_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Get_diag_stmt_exception_itemContext::T_EXCEPTION() {
  return getToken(HplsqlParser::T_EXCEPTION, 0);
}

tree::TerminalNode* HplsqlParser::Get_diag_stmt_exception_itemContext::L_INT() {
  return getToken(HplsqlParser::L_INT, 0);
}

HplsqlParser::IdentContext* HplsqlParser::Get_diag_stmt_exception_itemContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

tree::TerminalNode* HplsqlParser::Get_diag_stmt_exception_itemContext::T_EQUAL() {
  return getToken(HplsqlParser::T_EQUAL, 0);
}

tree::TerminalNode* HplsqlParser::Get_diag_stmt_exception_itemContext::T_MESSAGE_TEXT() {
  return getToken(HplsqlParser::T_MESSAGE_TEXT, 0);
}


size_t HplsqlParser::Get_diag_stmt_exception_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleGet_diag_stmt_exception_item;
}

void HplsqlParser::Get_diag_stmt_exception_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGet_diag_stmt_exception_item(this);
}

void HplsqlParser::Get_diag_stmt_exception_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGet_diag_stmt_exception_item(this);
}


antlrcpp::Any HplsqlParser::Get_diag_stmt_exception_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitGet_diag_stmt_exception_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Get_diag_stmt_exception_itemContext* HplsqlParser::get_diag_stmt_exception_item() {
  Get_diag_stmt_exception_itemContext *_localctx = _tracker.createInstance<Get_diag_stmt_exception_itemContext>(_ctx, getState());
  enterRule(_localctx, 192, HplsqlParser::RuleGet_diag_stmt_exception_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1787);
    match(HplsqlParser::T_EXCEPTION);
    setState(1788);
    match(HplsqlParser::L_INT);
    setState(1789);
    ident();
    setState(1790);
    match(HplsqlParser::T_EQUAL);
    setState(1791);
    match(HplsqlParser::T_MESSAGE_TEXT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Get_diag_stmt_rowcount_itemContext ------------------------------------------------------------------

HplsqlParser::Get_diag_stmt_rowcount_itemContext::Get_diag_stmt_rowcount_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::IdentContext* HplsqlParser::Get_diag_stmt_rowcount_itemContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

tree::TerminalNode* HplsqlParser::Get_diag_stmt_rowcount_itemContext::T_EQUAL() {
  return getToken(HplsqlParser::T_EQUAL, 0);
}

tree::TerminalNode* HplsqlParser::Get_diag_stmt_rowcount_itemContext::T_ROW_COUNT() {
  return getToken(HplsqlParser::T_ROW_COUNT, 0);
}


size_t HplsqlParser::Get_diag_stmt_rowcount_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleGet_diag_stmt_rowcount_item;
}

void HplsqlParser::Get_diag_stmt_rowcount_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGet_diag_stmt_rowcount_item(this);
}

void HplsqlParser::Get_diag_stmt_rowcount_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGet_diag_stmt_rowcount_item(this);
}


antlrcpp::Any HplsqlParser::Get_diag_stmt_rowcount_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitGet_diag_stmt_rowcount_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Get_diag_stmt_rowcount_itemContext* HplsqlParser::get_diag_stmt_rowcount_item() {
  Get_diag_stmt_rowcount_itemContext *_localctx = _tracker.createInstance<Get_diag_stmt_rowcount_itemContext>(_ctx, getState());
  enterRule(_localctx, 194, HplsqlParser::RuleGet_diag_stmt_rowcount_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1793);
    ident();
    setState(1794);
    match(HplsqlParser::T_EQUAL);
    setState(1795);
    match(HplsqlParser::T_ROW_COUNT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Grant_stmtContext ------------------------------------------------------------------

HplsqlParser::Grant_stmtContext::Grant_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Grant_stmtContext::T_GRANT() {
  return getToken(HplsqlParser::T_GRANT, 0);
}

std::vector<HplsqlParser::Grant_stmt_itemContext *> HplsqlParser::Grant_stmtContext::grant_stmt_item() {
  return getRuleContexts<HplsqlParser::Grant_stmt_itemContext>();
}

HplsqlParser::Grant_stmt_itemContext* HplsqlParser::Grant_stmtContext::grant_stmt_item(size_t i) {
  return getRuleContext<HplsqlParser::Grant_stmt_itemContext>(i);
}

tree::TerminalNode* HplsqlParser::Grant_stmtContext::T_TO() {
  return getToken(HplsqlParser::T_TO, 0);
}

tree::TerminalNode* HplsqlParser::Grant_stmtContext::T_ROLE() {
  return getToken(HplsqlParser::T_ROLE, 0);
}

HplsqlParser::IdentContext* HplsqlParser::Grant_stmtContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Grant_stmtContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Grant_stmtContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Grant_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleGrant_stmt;
}

void HplsqlParser::Grant_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrant_stmt(this);
}

void HplsqlParser::Grant_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrant_stmt(this);
}


antlrcpp::Any HplsqlParser::Grant_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitGrant_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Grant_stmtContext* HplsqlParser::grant_stmt() {
  Grant_stmtContext *_localctx = _tracker.createInstance<Grant_stmtContext>(_ctx, getState());
  enterRule(_localctx, 196, HplsqlParser::RuleGrant_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1797);
    match(HplsqlParser::T_GRANT);
    setState(1798);
    grant_stmt_item();
    setState(1803);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HplsqlParser::T_COMMA) {
      setState(1799);
      match(HplsqlParser::T_COMMA);
      setState(1800);
      grant_stmt_item();
      setState(1805);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1806);
    match(HplsqlParser::T_TO);
    setState(1807);
    match(HplsqlParser::T_ROLE);
    setState(1808);
    ident();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Grant_stmt_itemContext ------------------------------------------------------------------

HplsqlParser::Grant_stmt_itemContext::Grant_stmt_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Grant_stmt_itemContext::T_EXECUTE() {
  return getToken(HplsqlParser::T_EXECUTE, 0);
}

tree::TerminalNode* HplsqlParser::Grant_stmt_itemContext::T_ON() {
  return getToken(HplsqlParser::T_ON, 0);
}

tree::TerminalNode* HplsqlParser::Grant_stmt_itemContext::T_PROCEDURE() {
  return getToken(HplsqlParser::T_PROCEDURE, 0);
}

HplsqlParser::IdentContext* HplsqlParser::Grant_stmt_itemContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}


size_t HplsqlParser::Grant_stmt_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleGrant_stmt_item;
}

void HplsqlParser::Grant_stmt_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrant_stmt_item(this);
}

void HplsqlParser::Grant_stmt_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrant_stmt_item(this);
}


antlrcpp::Any HplsqlParser::Grant_stmt_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitGrant_stmt_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Grant_stmt_itemContext* HplsqlParser::grant_stmt_item() {
  Grant_stmt_itemContext *_localctx = _tracker.createInstance<Grant_stmt_itemContext>(_ctx, getState());
  enterRule(_localctx, 198, HplsqlParser::RuleGrant_stmt_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1810);
    match(HplsqlParser::T_EXECUTE);
    setState(1811);
    match(HplsqlParser::T_ON);
    setState(1812);
    match(HplsqlParser::T_PROCEDURE);
    setState(1813);
    ident();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Leave_stmtContext ------------------------------------------------------------------

HplsqlParser::Leave_stmtContext::Leave_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Leave_stmtContext::T_LEAVE() {
  return getToken(HplsqlParser::T_LEAVE, 0);
}

tree::TerminalNode* HplsqlParser::Leave_stmtContext::L_ID() {
  return getToken(HplsqlParser::L_ID, 0);
}


size_t HplsqlParser::Leave_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleLeave_stmt;
}

void HplsqlParser::Leave_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLeave_stmt(this);
}

void HplsqlParser::Leave_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLeave_stmt(this);
}


antlrcpp::Any HplsqlParser::Leave_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitLeave_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Leave_stmtContext* HplsqlParser::leave_stmt() {
  Leave_stmtContext *_localctx = _tracker.createInstance<Leave_stmtContext>(_ctx, getState());
  enterRule(_localctx, 200, HplsqlParser::RuleLeave_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1815);
    match(HplsqlParser::T_LEAVE);
    setState(1817);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 200, _ctx)) {
    case 1: {
      setState(1816);
      match(HplsqlParser::L_ID);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Map_object_stmtContext ------------------------------------------------------------------

HplsqlParser::Map_object_stmtContext::Map_object_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Map_object_stmtContext::T_MAP() {
  return getToken(HplsqlParser::T_MAP, 0);
}

tree::TerminalNode* HplsqlParser::Map_object_stmtContext::T_OBJECT() {
  return getToken(HplsqlParser::T_OBJECT, 0);
}

std::vector<HplsqlParser::ExprContext *> HplsqlParser::Map_object_stmtContext::expr() {
  return getRuleContexts<HplsqlParser::ExprContext>();
}

HplsqlParser::ExprContext* HplsqlParser::Map_object_stmtContext::expr(size_t i) {
  return getRuleContext<HplsqlParser::ExprContext>(i);
}

tree::TerminalNode* HplsqlParser::Map_object_stmtContext::T_TO() {
  return getToken(HplsqlParser::T_TO, 0);
}

tree::TerminalNode* HplsqlParser::Map_object_stmtContext::T_AT() {
  return getToken(HplsqlParser::T_AT, 0);
}


size_t HplsqlParser::Map_object_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleMap_object_stmt;
}

void HplsqlParser::Map_object_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMap_object_stmt(this);
}

void HplsqlParser::Map_object_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMap_object_stmt(this);
}


antlrcpp::Any HplsqlParser::Map_object_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitMap_object_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Map_object_stmtContext* HplsqlParser::map_object_stmt() {
  Map_object_stmtContext *_localctx = _tracker.createInstance<Map_object_stmtContext>(_ctx, getState());
  enterRule(_localctx, 202, HplsqlParser::RuleMap_object_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1819);
    match(HplsqlParser::T_MAP);
    setState(1820);
    match(HplsqlParser::T_OBJECT);
    setState(1821);
    expr(0);
    setState(1824);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 201, _ctx)) {
    case 1: {
      setState(1822);
      match(HplsqlParser::T_TO);
      setState(1823);
      expr(0);
      break;
    }

    default:
      break;
    }
    setState(1828);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 202, _ctx)) {
    case 1: {
      setState(1826);
      match(HplsqlParser::T_AT);
      setState(1827);
      expr(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Open_stmtContext ------------------------------------------------------------------

HplsqlParser::Open_stmtContext::Open_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Open_stmtContext::T_OPEN() {
  return getToken(HplsqlParser::T_OPEN, 0);
}

tree::TerminalNode* HplsqlParser::Open_stmtContext::L_ID() {
  return getToken(HplsqlParser::L_ID, 0);
}

tree::TerminalNode* HplsqlParser::Open_stmtContext::T_FOR() {
  return getToken(HplsqlParser::T_FOR, 0);
}

HplsqlParser::Select_stmtContext* HplsqlParser::Open_stmtContext::select_stmt() {
  return getRuleContext<HplsqlParser::Select_stmtContext>(0);
}

HplsqlParser::ExprContext* HplsqlParser::Open_stmtContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}


size_t HplsqlParser::Open_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleOpen_stmt;
}

void HplsqlParser::Open_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpen_stmt(this);
}

void HplsqlParser::Open_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpen_stmt(this);
}


antlrcpp::Any HplsqlParser::Open_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitOpen_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Open_stmtContext* HplsqlParser::open_stmt() {
  Open_stmtContext *_localctx = _tracker.createInstance<Open_stmtContext>(_ctx, getState());
  enterRule(_localctx, 204, HplsqlParser::RuleOpen_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1830);
    match(HplsqlParser::T_OPEN);
    setState(1831);
    match(HplsqlParser::L_ID);
    setState(1837);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 204, _ctx)) {
    case 1: {
      setState(1832);
      match(HplsqlParser::T_FOR);
      setState(1835);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 203, _ctx)) {
      case 1: {
        setState(1833);
        select_stmt();
        break;
      }

      case 2: {
        setState(1834);
        expr(0);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fetch_stmtContext ------------------------------------------------------------------

HplsqlParser::Fetch_stmtContext::Fetch_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Fetch_stmtContext::T_FETCH() {
  return getToken(HplsqlParser::T_FETCH, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Fetch_stmtContext::L_ID() {
  return getTokens(HplsqlParser::L_ID);
}

tree::TerminalNode* HplsqlParser::Fetch_stmtContext::L_ID(size_t i) {
  return getToken(HplsqlParser::L_ID, i);
}

tree::TerminalNode* HplsqlParser::Fetch_stmtContext::T_INTO() {
  return getToken(HplsqlParser::T_INTO, 0);
}

tree::TerminalNode* HplsqlParser::Fetch_stmtContext::T_FROM() {
  return getToken(HplsqlParser::T_FROM, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Fetch_stmtContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Fetch_stmtContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Fetch_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleFetch_stmt;
}

void HplsqlParser::Fetch_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFetch_stmt(this);
}

void HplsqlParser::Fetch_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFetch_stmt(this);
}


antlrcpp::Any HplsqlParser::Fetch_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitFetch_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Fetch_stmtContext* HplsqlParser::fetch_stmt() {
  Fetch_stmtContext *_localctx = _tracker.createInstance<Fetch_stmtContext>(_ctx, getState());
  enterRule(_localctx, 206, HplsqlParser::RuleFetch_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1839);
    match(HplsqlParser::T_FETCH);
    setState(1841);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_FROM) {
      setState(1840);
      match(HplsqlParser::T_FROM);
    }
    setState(1843);
    match(HplsqlParser::L_ID);
    setState(1844);
    match(HplsqlParser::T_INTO);
    setState(1845);
    match(HplsqlParser::L_ID);
    setState(1850);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 206, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1846);
        match(HplsqlParser::T_COMMA);
        setState(1847);
        match(HplsqlParser::L_ID); 
      }
      setState(1852);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 206, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Collect_stats_stmtContext ------------------------------------------------------------------

HplsqlParser::Collect_stats_stmtContext::Collect_stats_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Collect_stats_stmtContext::T_COLLECT() {
  return getToken(HplsqlParser::T_COLLECT, 0);
}

tree::TerminalNode* HplsqlParser::Collect_stats_stmtContext::T_ON() {
  return getToken(HplsqlParser::T_ON, 0);
}

HplsqlParser::Table_nameContext* HplsqlParser::Collect_stats_stmtContext::table_name() {
  return getRuleContext<HplsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* HplsqlParser::Collect_stats_stmtContext::T_STATISTICS() {
  return getToken(HplsqlParser::T_STATISTICS, 0);
}

tree::TerminalNode* HplsqlParser::Collect_stats_stmtContext::T_STATS() {
  return getToken(HplsqlParser::T_STATS, 0);
}

HplsqlParser::Collect_stats_clauseContext* HplsqlParser::Collect_stats_stmtContext::collect_stats_clause() {
  return getRuleContext<HplsqlParser::Collect_stats_clauseContext>(0);
}


size_t HplsqlParser::Collect_stats_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleCollect_stats_stmt;
}

void HplsqlParser::Collect_stats_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCollect_stats_stmt(this);
}

void HplsqlParser::Collect_stats_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCollect_stats_stmt(this);
}


antlrcpp::Any HplsqlParser::Collect_stats_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCollect_stats_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Collect_stats_stmtContext* HplsqlParser::collect_stats_stmt() {
  Collect_stats_stmtContext *_localctx = _tracker.createInstance<Collect_stats_stmtContext>(_ctx, getState());
  enterRule(_localctx, 208, HplsqlParser::RuleCollect_stats_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1853);
    match(HplsqlParser::T_COLLECT);
    setState(1854);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_STATS

    || _la == HplsqlParser::T_STATISTICS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1855);
    match(HplsqlParser::T_ON);
    setState(1856);
    table_name();
    setState(1858);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 207, _ctx)) {
    case 1: {
      setState(1857);
      collect_stats_clause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Collect_stats_clauseContext ------------------------------------------------------------------

HplsqlParser::Collect_stats_clauseContext::Collect_stats_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Collect_stats_clauseContext::T_COLUMN() {
  return getToken(HplsqlParser::T_COLUMN, 0);
}

tree::TerminalNode* HplsqlParser::Collect_stats_clauseContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

std::vector<HplsqlParser::IdentContext *> HplsqlParser::Collect_stats_clauseContext::ident() {
  return getRuleContexts<HplsqlParser::IdentContext>();
}

HplsqlParser::IdentContext* HplsqlParser::Collect_stats_clauseContext::ident(size_t i) {
  return getRuleContext<HplsqlParser::IdentContext>(i);
}

tree::TerminalNode* HplsqlParser::Collect_stats_clauseContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Collect_stats_clauseContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Collect_stats_clauseContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Collect_stats_clauseContext::getRuleIndex() const {
  return HplsqlParser::RuleCollect_stats_clause;
}

void HplsqlParser::Collect_stats_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCollect_stats_clause(this);
}

void HplsqlParser::Collect_stats_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCollect_stats_clause(this);
}


antlrcpp::Any HplsqlParser::Collect_stats_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCollect_stats_clause(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Collect_stats_clauseContext* HplsqlParser::collect_stats_clause() {
  Collect_stats_clauseContext *_localctx = _tracker.createInstance<Collect_stats_clauseContext>(_ctx, getState());
  enterRule(_localctx, 210, HplsqlParser::RuleCollect_stats_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1860);
    match(HplsqlParser::T_COLUMN);
    setState(1861);
    match(HplsqlParser::T_OPEN_P);
    setState(1862);
    ident();
    setState(1867);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HplsqlParser::T_COMMA) {
      setState(1863);
      match(HplsqlParser::T_COMMA);
      setState(1864);
      ident();
      setState(1869);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1870);
    match(HplsqlParser::T_CLOSE_P);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Close_stmtContext ------------------------------------------------------------------

HplsqlParser::Close_stmtContext::Close_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Close_stmtContext::T_CLOSE() {
  return getToken(HplsqlParser::T_CLOSE, 0);
}

tree::TerminalNode* HplsqlParser::Close_stmtContext::L_ID() {
  return getToken(HplsqlParser::L_ID, 0);
}


size_t HplsqlParser::Close_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleClose_stmt;
}

void HplsqlParser::Close_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClose_stmt(this);
}

void HplsqlParser::Close_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClose_stmt(this);
}


antlrcpp::Any HplsqlParser::Close_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitClose_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Close_stmtContext* HplsqlParser::close_stmt() {
  Close_stmtContext *_localctx = _tracker.createInstance<Close_stmtContext>(_ctx, getState());
  enterRule(_localctx, 212, HplsqlParser::RuleClose_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1872);
    match(HplsqlParser::T_CLOSE);
    setState(1873);
    match(HplsqlParser::L_ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmp_stmtContext ------------------------------------------------------------------

HplsqlParser::Cmp_stmtContext::Cmp_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Cmp_stmtContext::T_CMP() {
  return getToken(HplsqlParser::T_CMP, 0);
}

std::vector<HplsqlParser::Cmp_sourceContext *> HplsqlParser::Cmp_stmtContext::cmp_source() {
  return getRuleContexts<HplsqlParser::Cmp_sourceContext>();
}

HplsqlParser::Cmp_sourceContext* HplsqlParser::Cmp_stmtContext::cmp_source(size_t i) {
  return getRuleContext<HplsqlParser::Cmp_sourceContext>(i);
}

tree::TerminalNode* HplsqlParser::Cmp_stmtContext::T_COMMA() {
  return getToken(HplsqlParser::T_COMMA, 0);
}

tree::TerminalNode* HplsqlParser::Cmp_stmtContext::T_ROW_COUNT() {
  return getToken(HplsqlParser::T_ROW_COUNT, 0);
}

tree::TerminalNode* HplsqlParser::Cmp_stmtContext::T_SUM() {
  return getToken(HplsqlParser::T_SUM, 0);
}


size_t HplsqlParser::Cmp_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleCmp_stmt;
}

void HplsqlParser::Cmp_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmp_stmt(this);
}

void HplsqlParser::Cmp_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmp_stmt(this);
}


antlrcpp::Any HplsqlParser::Cmp_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCmp_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Cmp_stmtContext* HplsqlParser::cmp_stmt() {
  Cmp_stmtContext *_localctx = _tracker.createInstance<Cmp_stmtContext>(_ctx, getState());
  enterRule(_localctx, 214, HplsqlParser::RuleCmp_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1875);
    match(HplsqlParser::T_CMP);
    setState(1876);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_ROW_COUNT

    || _la == HplsqlParser::T_SUM)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1877);
    cmp_source();
    setState(1878);
    match(HplsqlParser::T_COMMA);
    setState(1879);
    cmp_source();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmp_sourceContext ------------------------------------------------------------------

HplsqlParser::Cmp_sourceContext::Cmp_sourceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Table_nameContext* HplsqlParser::Cmp_sourceContext::table_name() {
  return getRuleContext<HplsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* HplsqlParser::Cmp_sourceContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

HplsqlParser::Select_stmtContext* HplsqlParser::Cmp_sourceContext::select_stmt() {
  return getRuleContext<HplsqlParser::Select_stmtContext>(0);
}

tree::TerminalNode* HplsqlParser::Cmp_sourceContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

tree::TerminalNode* HplsqlParser::Cmp_sourceContext::T_AT() {
  return getToken(HplsqlParser::T_AT, 0);
}

HplsqlParser::IdentContext* HplsqlParser::Cmp_sourceContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

HplsqlParser::Where_clauseContext* HplsqlParser::Cmp_sourceContext::where_clause() {
  return getRuleContext<HplsqlParser::Where_clauseContext>(0);
}


size_t HplsqlParser::Cmp_sourceContext::getRuleIndex() const {
  return HplsqlParser::RuleCmp_source;
}

void HplsqlParser::Cmp_sourceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmp_source(this);
}

void HplsqlParser::Cmp_sourceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmp_source(this);
}


antlrcpp::Any HplsqlParser::Cmp_sourceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCmp_source(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Cmp_sourceContext* HplsqlParser::cmp_source() {
  Cmp_sourceContext *_localctx = _tracker.createInstance<Cmp_sourceContext>(_ctx, getState());
  enterRule(_localctx, 216, HplsqlParser::RuleCmp_source);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1889);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_ACTION:
      case HplsqlParser::T_ADD2:
      case HplsqlParser::T_ALL:
      case HplsqlParser::T_ALLOCATE:
      case HplsqlParser::T_ALTER:
      case HplsqlParser::T_AND:
      case HplsqlParser::T_ANSI_NULLS:
      case HplsqlParser::T_ANSI_PADDING:
      case HplsqlParser::T_AS:
      case HplsqlParser::T_ASC:
      case HplsqlParser::T_ASSOCIATE:
      case HplsqlParser::T_AT:
      case HplsqlParser::T_AUTO_INCREMENT:
      case HplsqlParser::T_AVG:
      case HplsqlParser::T_BATCHSIZE:
      case HplsqlParser::T_BEGIN:
      case HplsqlParser::T_BETWEEN:
      case HplsqlParser::T_BIGINT:
      case HplsqlParser::T_BINARY_DOUBLE:
      case HplsqlParser::T_BINARY_FLOAT:
      case HplsqlParser::T_BIT:
      case HplsqlParser::T_BODY:
      case HplsqlParser::T_BREAK:
      case HplsqlParser::T_BY:
      case HplsqlParser::T_BYTE:
      case HplsqlParser::T_CALL:
      case HplsqlParser::T_CALLER:
      case HplsqlParser::T_CASCADE:
      case HplsqlParser::T_CASE:
      case HplsqlParser::T_CASESPECIFIC:
      case HplsqlParser::T_CAST:
      case HplsqlParser::T_CHAR:
      case HplsqlParser::T_CHARACTER:
      case HplsqlParser::T_CHARSET:
      case HplsqlParser::T_CLIENT:
      case HplsqlParser::T_CLOSE:
      case HplsqlParser::T_CLUSTERED:
      case HplsqlParser::T_CMP:
      case HplsqlParser::T_COLLECT:
      case HplsqlParser::T_COLLECTION:
      case HplsqlParser::T_COLUMN:
      case HplsqlParser::T_COMMENT:
      case HplsqlParser::T_CONSTANT:
      case HplsqlParser::T_COMMIT:
      case HplsqlParser::T_COMPRESS:
      case HplsqlParser::T_CONCAT:
      case HplsqlParser::T_CONDITION:
      case HplsqlParser::T_CONSTRAINT:
      case HplsqlParser::T_CONTINUE:
      case HplsqlParser::T_COPY:
      case HplsqlParser::T_COUNT:
      case HplsqlParser::T_COUNT_BIG:
      case HplsqlParser::T_CREATE:
      case HplsqlParser::T_CREATION:
      case HplsqlParser::T_CREATOR:
      case HplsqlParser::T_CS:
      case HplsqlParser::T_CURRENT:
      case HplsqlParser::T_CURRENT_SCHEMA:
      case HplsqlParser::T_CURSOR:
      case HplsqlParser::T_DATABASE:
      case HplsqlParser::T_DATA:
      case HplsqlParser::T_DATE:
      case HplsqlParser::T_DATETIME:
      case HplsqlParser::T_DAY:
      case HplsqlParser::T_DAYS:
      case HplsqlParser::T_DEC:
      case HplsqlParser::T_DECIMAL:
      case HplsqlParser::T_DECLARE:
      case HplsqlParser::T_DEFAULT:
      case HplsqlParser::T_DEFERRED:
      case HplsqlParser::T_DEFINED:
      case HplsqlParser::T_DEFINER:
      case HplsqlParser::T_DEFINITION:
      case HplsqlParser::T_DELETE:
      case HplsqlParser::T_DELIMITED:
      case HplsqlParser::T_DELIMITER:
      case HplsqlParser::T_DESC:
      case HplsqlParser::T_DESCRIBE:
      case HplsqlParser::T_DIAGNOSTICS:
      case HplsqlParser::T_DIR:
      case HplsqlParser::T_DIRECTORY:
      case HplsqlParser::T_DISTINCT:
      case HplsqlParser::T_DISTRIBUTE:
      case HplsqlParser::T_DO:
      case HplsqlParser::T_DOUBLE:
      case HplsqlParser::T_DROP:
      case HplsqlParser::T_DYNAMIC:
      case HplsqlParser::T_ENABLE:
      case HplsqlParser::T_ENGINE:
      case HplsqlParser::T_ESCAPED:
      case HplsqlParser::T_EXCEPT:
      case HplsqlParser::T_EXEC:
      case HplsqlParser::T_EXECUTE:
      case HplsqlParser::T_EXCEPTION:
      case HplsqlParser::T_EXCLUSIVE:
      case HplsqlParser::T_EXISTS:
      case HplsqlParser::T_EXIT:
      case HplsqlParser::T_FALLBACK:
      case HplsqlParser::T_FALSE:
      case HplsqlParser::T_FETCH:
      case HplsqlParser::T_FIELDS:
      case HplsqlParser::T_FILE:
      case HplsqlParser::T_FILES:
      case HplsqlParser::T_FLOAT:
      case HplsqlParser::T_FOR:
      case HplsqlParser::T_FOREIGN:
      case HplsqlParser::T_FORMAT:
      case HplsqlParser::T_FOUND:
      case HplsqlParser::T_FROM:
      case HplsqlParser::T_FULL:
      case HplsqlParser::T_FUNCTION:
      case HplsqlParser::T_GET:
      case HplsqlParser::T_GLOBAL:
      case HplsqlParser::T_GO:
      case HplsqlParser::T_GRANT:
      case HplsqlParser::T_GROUP:
      case HplsqlParser::T_HANDLER:
      case HplsqlParser::T_HASH:
      case HplsqlParser::T_HAVING:
      case HplsqlParser::T_HDFS:
      case HplsqlParser::T_HIVE:
      case HplsqlParser::T_HOST:
      case HplsqlParser::T_IDENTITY:
      case HplsqlParser::T_IF:
      case HplsqlParser::T_IGNORE:
      case HplsqlParser::T_IMMEDIATE:
      case HplsqlParser::T_IN:
      case HplsqlParser::T_INCLUDE:
      case HplsqlParser::T_INDEX:
      case HplsqlParser::T_INITRANS:
      case HplsqlParser::T_INNER:
      case HplsqlParser::T_INOUT:
      case HplsqlParser::T_INSERT:
      case HplsqlParser::T_INT:
      case HplsqlParser::T_INT2:
      case HplsqlParser::T_INT4:
      case HplsqlParser::T_INT8:
      case HplsqlParser::T_INTEGER:
      case HplsqlParser::T_INTERSECT:
      case HplsqlParser::T_INTERVAL:
      case HplsqlParser::T_INTO:
      case HplsqlParser::T_INVOKER:
      case HplsqlParser::T_IS:
      case HplsqlParser::T_ISOPEN:
      case HplsqlParser::T_ITEMS:
      case HplsqlParser::T_JOIN:
      case HplsqlParser::T_KEEP:
      case HplsqlParser::T_KEY:
      case HplsqlParser::T_KEYS:
      case HplsqlParser::T_LANGUAGE:
      case HplsqlParser::T_LEAVE:
      case HplsqlParser::T_LEFT:
      case HplsqlParser::T_LIKE:
      case HplsqlParser::T_LIMIT:
      case HplsqlParser::T_LINES:
      case HplsqlParser::T_LOCAL:
      case HplsqlParser::T_LOCATION:
      case HplsqlParser::T_LOCATOR:
      case HplsqlParser::T_LOCATORS:
      case HplsqlParser::T_LOCKS:
      case HplsqlParser::T_LOG:
      case HplsqlParser::T_LOGGED:
      case HplsqlParser::T_LOGGING:
      case HplsqlParser::T_LOOP:
      case HplsqlParser::T_MAP:
      case HplsqlParser::T_MATCHED:
      case HplsqlParser::T_MAX:
      case HplsqlParser::T_MAXTRANS:
      case HplsqlParser::T_MERGE:
      case HplsqlParser::T_MESSAGE_TEXT:
      case HplsqlParser::T_MICROSECOND:
      case HplsqlParser::T_MICROSECONDS:
      case HplsqlParser::T_MIN:
      case HplsqlParser::T_MULTISET:
      case HplsqlParser::T_NCHAR:
      case HplsqlParser::T_NEW:
      case HplsqlParser::T_NVARCHAR:
      case HplsqlParser::T_NO:
      case HplsqlParser::T_NOCOUNT:
      case HplsqlParser::T_NOCOMPRESS:
      case HplsqlParser::T_NOLOGGING:
      case HplsqlParser::T_NONE:
      case HplsqlParser::T_NOT:
      case HplsqlParser::T_NOTFOUND:
      case HplsqlParser::T_NUMERIC:
      case HplsqlParser::T_NUMBER:
      case HplsqlParser::T_OBJECT:
      case HplsqlParser::T_OFF:
      case HplsqlParser::T_ON:
      case HplsqlParser::T_ONLY:
      case HplsqlParser::T_OPEN:
      case HplsqlParser::T_OR:
      case HplsqlParser::T_ORDER:
      case HplsqlParser::T_OUT:
      case HplsqlParser::T_OUTER:
      case HplsqlParser::T_OVER:
      case HplsqlParser::T_OVERWRITE:
      case HplsqlParser::T_OWNER:
      case HplsqlParser::T_PACKAGE:
      case HplsqlParser::T_PARTITION:
      case HplsqlParser::T_PCTFREE:
      case HplsqlParser::T_PCTUSED:
      case HplsqlParser::T_PRECISION:
      case HplsqlParser::T_PRESERVE:
      case HplsqlParser::T_PRIMARY:
      case HplsqlParser::T_PRINT:
      case HplsqlParser::T_PROC:
      case HplsqlParser::T_PROCEDURE:
      case HplsqlParser::T_QUALIFY:
      case HplsqlParser::T_QUERY_BAND:
      case HplsqlParser::T_QUIT:
      case HplsqlParser::T_QUOTED_IDENTIFIER:
      case HplsqlParser::T_RAISE:
      case HplsqlParser::T_REAL:
      case HplsqlParser::T_REFERENCES:
      case HplsqlParser::T_REGEXP:
      case HplsqlParser::T_REPLACE:
      case HplsqlParser::T_RESIGNAL:
      case HplsqlParser::T_RESTRICT:
      case HplsqlParser::T_RESULT:
      case HplsqlParser::T_RESULT_SET_LOCATOR:
      case HplsqlParser::T_RETURN:
      case HplsqlParser::T_RETURNS:
      case HplsqlParser::T_REVERSE:
      case HplsqlParser::T_RIGHT:
      case HplsqlParser::T_RLIKE:
      case HplsqlParser::T_ROLE:
      case HplsqlParser::T_ROLLBACK:
      case HplsqlParser::T_ROW:
      case HplsqlParser::T_ROWS:
      case HplsqlParser::T_ROW_COUNT:
      case HplsqlParser::T_RR:
      case HplsqlParser::T_RS:
      case HplsqlParser::T_PWD:
      case HplsqlParser::T_TRIM:
      case HplsqlParser::T_SCHEMA:
      case HplsqlParser::T_SECOND:
      case HplsqlParser::T_SECONDS:
      case HplsqlParser::T_SECURITY:
      case HplsqlParser::T_SEGMENT:
      case HplsqlParser::T_SEL:
      case HplsqlParser::T_SELECT:
      case HplsqlParser::T_SET:
      case HplsqlParser::T_SESSION:
      case HplsqlParser::T_SESSIONS:
      case HplsqlParser::T_SETS:
      case HplsqlParser::T_SHARE:
      case HplsqlParser::T_SIGNAL:
      case HplsqlParser::T_SIMPLE_DOUBLE:
      case HplsqlParser::T_SIMPLE_FLOAT:
      case HplsqlParser::T_SMALLDATETIME:
      case HplsqlParser::T_SMALLINT:
      case HplsqlParser::T_SQL:
      case HplsqlParser::T_SQLEXCEPTION:
      case HplsqlParser::T_SQLINSERT:
      case HplsqlParser::T_SQLSTATE:
      case HplsqlParser::T_SQLWARNING:
      case HplsqlParser::T_STATS:
      case HplsqlParser::T_STATISTICS:
      case HplsqlParser::T_STEP:
      case HplsqlParser::T_STORAGE:
      case HplsqlParser::T_STORED:
      case HplsqlParser::T_STRING:
      case HplsqlParser::T_SUBDIR:
      case HplsqlParser::T_SUBSTRING:
      case HplsqlParser::T_SUM:
      case HplsqlParser::T_SYS_REFCURSOR:
      case HplsqlParser::T_TABLE:
      case HplsqlParser::T_TABLESPACE:
      case HplsqlParser::T_TEMPORARY:
      case HplsqlParser::T_TERMINATED:
      case HplsqlParser::T_TEXTIMAGE_ON:
      case HplsqlParser::T_THEN:
      case HplsqlParser::T_TIMESTAMP:
      case HplsqlParser::T_TITLE:
      case HplsqlParser::T_TO:
      case HplsqlParser::T_TOP:
      case HplsqlParser::T_TRANSACTION:
      case HplsqlParser::T_TRUE:
      case HplsqlParser::T_TRUNCATE:
      case HplsqlParser::T_UNIQUE:
      case HplsqlParser::T_UPDATE:
      case HplsqlParser::T_UR:
      case HplsqlParser::T_USE:
      case HplsqlParser::T_USING:
      case HplsqlParser::T_VALUE:
      case HplsqlParser::T_VALUES:
      case HplsqlParser::T_VAR:
      case HplsqlParser::T_VARCHAR:
      case HplsqlParser::T_VARCHAR2:
      case HplsqlParser::T_VARYING:
      case HplsqlParser::T_VOLATILE:
      case HplsqlParser::T_WHILE:
      case HplsqlParser::T_WITH:
      case HplsqlParser::T_WITHOUT:
      case HplsqlParser::T_WORK:
      case HplsqlParser::T_XACT_ABORT:
      case HplsqlParser::T_XML:
      case HplsqlParser::T_YES:
      case HplsqlParser::T_ACTIVITY_COUNT:
      case HplsqlParser::T_CUME_DIST:
      case HplsqlParser::T_CURRENT_DATE:
      case HplsqlParser::T_CURRENT_TIMESTAMP:
      case HplsqlParser::T_CURRENT_USER:
      case HplsqlParser::T_DENSE_RANK:
      case HplsqlParser::T_FIRST_VALUE:
      case HplsqlParser::T_LAG:
      case HplsqlParser::T_LAST_VALUE:
      case HplsqlParser::T_LEAD:
      case HplsqlParser::T_PART_COUNT:
      case HplsqlParser::T_PART_LOC:
      case HplsqlParser::T_RANK:
      case HplsqlParser::T_ROW_NUMBER:
      case HplsqlParser::T_STDEV:
      case HplsqlParser::T_SYSDATE:
      case HplsqlParser::T_VARIANCE:
      case HplsqlParser::T_USER:
      case HplsqlParser::L_ID: {
        setState(1881);
        table_name();
        setState(1883);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 209, _ctx)) {
        case 1: {
          setState(1882);
          where_clause();
          break;
        }

        default:
          break;
        }
        break;
      }

      case HplsqlParser::T_OPEN_P: {
        setState(1885);
        match(HplsqlParser::T_OPEN_P);
        setState(1886);
        select_stmt();
        setState(1887);
        match(HplsqlParser::T_CLOSE_P);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1893);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 211, _ctx)) {
    case 1: {
      setState(1891);
      match(HplsqlParser::T_AT);
      setState(1892);
      ident();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Copy_from_local_stmtContext ------------------------------------------------------------------

HplsqlParser::Copy_from_local_stmtContext::Copy_from_local_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Copy_from_local_stmtContext::T_COPY() {
  return getToken(HplsqlParser::T_COPY, 0);
}

tree::TerminalNode* HplsqlParser::Copy_from_local_stmtContext::T_FROM() {
  return getToken(HplsqlParser::T_FROM, 0);
}

tree::TerminalNode* HplsqlParser::Copy_from_local_stmtContext::T_LOCAL() {
  return getToken(HplsqlParser::T_LOCAL, 0);
}

std::vector<HplsqlParser::Copy_sourceContext *> HplsqlParser::Copy_from_local_stmtContext::copy_source() {
  return getRuleContexts<HplsqlParser::Copy_sourceContext>();
}

HplsqlParser::Copy_sourceContext* HplsqlParser::Copy_from_local_stmtContext::copy_source(size_t i) {
  return getRuleContext<HplsqlParser::Copy_sourceContext>(i);
}

tree::TerminalNode* HplsqlParser::Copy_from_local_stmtContext::T_TO() {
  return getToken(HplsqlParser::T_TO, 0);
}

HplsqlParser::Copy_targetContext* HplsqlParser::Copy_from_local_stmtContext::copy_target() {
  return getRuleContext<HplsqlParser::Copy_targetContext>(0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Copy_from_local_stmtContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Copy_from_local_stmtContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}

std::vector<HplsqlParser::Copy_file_optionContext *> HplsqlParser::Copy_from_local_stmtContext::copy_file_option() {
  return getRuleContexts<HplsqlParser::Copy_file_optionContext>();
}

HplsqlParser::Copy_file_optionContext* HplsqlParser::Copy_from_local_stmtContext::copy_file_option(size_t i) {
  return getRuleContext<HplsqlParser::Copy_file_optionContext>(i);
}


size_t HplsqlParser::Copy_from_local_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleCopy_from_local_stmt;
}

void HplsqlParser::Copy_from_local_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCopy_from_local_stmt(this);
}

void HplsqlParser::Copy_from_local_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCopy_from_local_stmt(this);
}


antlrcpp::Any HplsqlParser::Copy_from_local_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCopy_from_local_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Copy_from_local_stmtContext* HplsqlParser::copy_from_local_stmt() {
  Copy_from_local_stmtContext *_localctx = _tracker.createInstance<Copy_from_local_stmtContext>(_ctx, getState());
  enterRule(_localctx, 218, HplsqlParser::RuleCopy_from_local_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1895);
    match(HplsqlParser::T_COPY);
    setState(1896);
    match(HplsqlParser::T_FROM);
    setState(1897);
    match(HplsqlParser::T_LOCAL);
    setState(1898);
    copy_source();
    setState(1903);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HplsqlParser::T_COMMA) {
      setState(1899);
      match(HplsqlParser::T_COMMA);
      setState(1900);
      copy_source();
      setState(1905);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1906);
    match(HplsqlParser::T_TO);
    setState(1907);
    copy_target();
    setState(1911);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 213, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1908);
        copy_file_option(); 
      }
      setState(1913);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 213, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Copy_stmtContext ------------------------------------------------------------------

HplsqlParser::Copy_stmtContext::Copy_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Copy_stmtContext::T_COPY() {
  return getToken(HplsqlParser::T_COPY, 0);
}

tree::TerminalNode* HplsqlParser::Copy_stmtContext::T_TO() {
  return getToken(HplsqlParser::T_TO, 0);
}

HplsqlParser::Copy_targetContext* HplsqlParser::Copy_stmtContext::copy_target() {
  return getRuleContext<HplsqlParser::Copy_targetContext>(0);
}

HplsqlParser::Table_nameContext* HplsqlParser::Copy_stmtContext::table_name() {
  return getRuleContext<HplsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* HplsqlParser::Copy_stmtContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

HplsqlParser::Select_stmtContext* HplsqlParser::Copy_stmtContext::select_stmt() {
  return getRuleContext<HplsqlParser::Select_stmtContext>(0);
}

tree::TerminalNode* HplsqlParser::Copy_stmtContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

tree::TerminalNode* HplsqlParser::Copy_stmtContext::T_HDFS() {
  return getToken(HplsqlParser::T_HDFS, 0);
}

std::vector<HplsqlParser::Copy_optionContext *> HplsqlParser::Copy_stmtContext::copy_option() {
  return getRuleContexts<HplsqlParser::Copy_optionContext>();
}

HplsqlParser::Copy_optionContext* HplsqlParser::Copy_stmtContext::copy_option(size_t i) {
  return getRuleContext<HplsqlParser::Copy_optionContext>(i);
}


size_t HplsqlParser::Copy_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleCopy_stmt;
}

void HplsqlParser::Copy_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCopy_stmt(this);
}

void HplsqlParser::Copy_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCopy_stmt(this);
}


antlrcpp::Any HplsqlParser::Copy_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCopy_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Copy_stmtContext* HplsqlParser::copy_stmt() {
  Copy_stmtContext *_localctx = _tracker.createInstance<Copy_stmtContext>(_ctx, getState());
  enterRule(_localctx, 220, HplsqlParser::RuleCopy_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1914);
    match(HplsqlParser::T_COPY);
    setState(1920);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_ACTION:
      case HplsqlParser::T_ADD2:
      case HplsqlParser::T_ALL:
      case HplsqlParser::T_ALLOCATE:
      case HplsqlParser::T_ALTER:
      case HplsqlParser::T_AND:
      case HplsqlParser::T_ANSI_NULLS:
      case HplsqlParser::T_ANSI_PADDING:
      case HplsqlParser::T_AS:
      case HplsqlParser::T_ASC:
      case HplsqlParser::T_ASSOCIATE:
      case HplsqlParser::T_AT:
      case HplsqlParser::T_AUTO_INCREMENT:
      case HplsqlParser::T_AVG:
      case HplsqlParser::T_BATCHSIZE:
      case HplsqlParser::T_BEGIN:
      case HplsqlParser::T_BETWEEN:
      case HplsqlParser::T_BIGINT:
      case HplsqlParser::T_BINARY_DOUBLE:
      case HplsqlParser::T_BINARY_FLOAT:
      case HplsqlParser::T_BIT:
      case HplsqlParser::T_BODY:
      case HplsqlParser::T_BREAK:
      case HplsqlParser::T_BY:
      case HplsqlParser::T_BYTE:
      case HplsqlParser::T_CALL:
      case HplsqlParser::T_CALLER:
      case HplsqlParser::T_CASCADE:
      case HplsqlParser::T_CASE:
      case HplsqlParser::T_CASESPECIFIC:
      case HplsqlParser::T_CAST:
      case HplsqlParser::T_CHAR:
      case HplsqlParser::T_CHARACTER:
      case HplsqlParser::T_CHARSET:
      case HplsqlParser::T_CLIENT:
      case HplsqlParser::T_CLOSE:
      case HplsqlParser::T_CLUSTERED:
      case HplsqlParser::T_CMP:
      case HplsqlParser::T_COLLECT:
      case HplsqlParser::T_COLLECTION:
      case HplsqlParser::T_COLUMN:
      case HplsqlParser::T_COMMENT:
      case HplsqlParser::T_CONSTANT:
      case HplsqlParser::T_COMMIT:
      case HplsqlParser::T_COMPRESS:
      case HplsqlParser::T_CONCAT:
      case HplsqlParser::T_CONDITION:
      case HplsqlParser::T_CONSTRAINT:
      case HplsqlParser::T_CONTINUE:
      case HplsqlParser::T_COPY:
      case HplsqlParser::T_COUNT:
      case HplsqlParser::T_COUNT_BIG:
      case HplsqlParser::T_CREATE:
      case HplsqlParser::T_CREATION:
      case HplsqlParser::T_CREATOR:
      case HplsqlParser::T_CS:
      case HplsqlParser::T_CURRENT:
      case HplsqlParser::T_CURRENT_SCHEMA:
      case HplsqlParser::T_CURSOR:
      case HplsqlParser::T_DATABASE:
      case HplsqlParser::T_DATA:
      case HplsqlParser::T_DATE:
      case HplsqlParser::T_DATETIME:
      case HplsqlParser::T_DAY:
      case HplsqlParser::T_DAYS:
      case HplsqlParser::T_DEC:
      case HplsqlParser::T_DECIMAL:
      case HplsqlParser::T_DECLARE:
      case HplsqlParser::T_DEFAULT:
      case HplsqlParser::T_DEFERRED:
      case HplsqlParser::T_DEFINED:
      case HplsqlParser::T_DEFINER:
      case HplsqlParser::T_DEFINITION:
      case HplsqlParser::T_DELETE:
      case HplsqlParser::T_DELIMITED:
      case HplsqlParser::T_DELIMITER:
      case HplsqlParser::T_DESC:
      case HplsqlParser::T_DESCRIBE:
      case HplsqlParser::T_DIAGNOSTICS:
      case HplsqlParser::T_DIR:
      case HplsqlParser::T_DIRECTORY:
      case HplsqlParser::T_DISTINCT:
      case HplsqlParser::T_DISTRIBUTE:
      case HplsqlParser::T_DO:
      case HplsqlParser::T_DOUBLE:
      case HplsqlParser::T_DROP:
      case HplsqlParser::T_DYNAMIC:
      case HplsqlParser::T_ENABLE:
      case HplsqlParser::T_ENGINE:
      case HplsqlParser::T_ESCAPED:
      case HplsqlParser::T_EXCEPT:
      case HplsqlParser::T_EXEC:
      case HplsqlParser::T_EXECUTE:
      case HplsqlParser::T_EXCEPTION:
      case HplsqlParser::T_EXCLUSIVE:
      case HplsqlParser::T_EXISTS:
      case HplsqlParser::T_EXIT:
      case HplsqlParser::T_FALLBACK:
      case HplsqlParser::T_FALSE:
      case HplsqlParser::T_FETCH:
      case HplsqlParser::T_FIELDS:
      case HplsqlParser::T_FILE:
      case HplsqlParser::T_FILES:
      case HplsqlParser::T_FLOAT:
      case HplsqlParser::T_FOR:
      case HplsqlParser::T_FOREIGN:
      case HplsqlParser::T_FORMAT:
      case HplsqlParser::T_FOUND:
      case HplsqlParser::T_FROM:
      case HplsqlParser::T_FULL:
      case HplsqlParser::T_FUNCTION:
      case HplsqlParser::T_GET:
      case HplsqlParser::T_GLOBAL:
      case HplsqlParser::T_GO:
      case HplsqlParser::T_GRANT:
      case HplsqlParser::T_GROUP:
      case HplsqlParser::T_HANDLER:
      case HplsqlParser::T_HASH:
      case HplsqlParser::T_HAVING:
      case HplsqlParser::T_HDFS:
      case HplsqlParser::T_HIVE:
      case HplsqlParser::T_HOST:
      case HplsqlParser::T_IDENTITY:
      case HplsqlParser::T_IF:
      case HplsqlParser::T_IGNORE:
      case HplsqlParser::T_IMMEDIATE:
      case HplsqlParser::T_IN:
      case HplsqlParser::T_INCLUDE:
      case HplsqlParser::T_INDEX:
      case HplsqlParser::T_INITRANS:
      case HplsqlParser::T_INNER:
      case HplsqlParser::T_INOUT:
      case HplsqlParser::T_INSERT:
      case HplsqlParser::T_INT:
      case HplsqlParser::T_INT2:
      case HplsqlParser::T_INT4:
      case HplsqlParser::T_INT8:
      case HplsqlParser::T_INTEGER:
      case HplsqlParser::T_INTERSECT:
      case HplsqlParser::T_INTERVAL:
      case HplsqlParser::T_INTO:
      case HplsqlParser::T_INVOKER:
      case HplsqlParser::T_IS:
      case HplsqlParser::T_ISOPEN:
      case HplsqlParser::T_ITEMS:
      case HplsqlParser::T_JOIN:
      case HplsqlParser::T_KEEP:
      case HplsqlParser::T_KEY:
      case HplsqlParser::T_KEYS:
      case HplsqlParser::T_LANGUAGE:
      case HplsqlParser::T_LEAVE:
      case HplsqlParser::T_LEFT:
      case HplsqlParser::T_LIKE:
      case HplsqlParser::T_LIMIT:
      case HplsqlParser::T_LINES:
      case HplsqlParser::T_LOCAL:
      case HplsqlParser::T_LOCATION:
      case HplsqlParser::T_LOCATOR:
      case HplsqlParser::T_LOCATORS:
      case HplsqlParser::T_LOCKS:
      case HplsqlParser::T_LOG:
      case HplsqlParser::T_LOGGED:
      case HplsqlParser::T_LOGGING:
      case HplsqlParser::T_LOOP:
      case HplsqlParser::T_MAP:
      case HplsqlParser::T_MATCHED:
      case HplsqlParser::T_MAX:
      case HplsqlParser::T_MAXTRANS:
      case HplsqlParser::T_MERGE:
      case HplsqlParser::T_MESSAGE_TEXT:
      case HplsqlParser::T_MICROSECOND:
      case HplsqlParser::T_MICROSECONDS:
      case HplsqlParser::T_MIN:
      case HplsqlParser::T_MULTISET:
      case HplsqlParser::T_NCHAR:
      case HplsqlParser::T_NEW:
      case HplsqlParser::T_NVARCHAR:
      case HplsqlParser::T_NO:
      case HplsqlParser::T_NOCOUNT:
      case HplsqlParser::T_NOCOMPRESS:
      case HplsqlParser::T_NOLOGGING:
      case HplsqlParser::T_NONE:
      case HplsqlParser::T_NOT:
      case HplsqlParser::T_NOTFOUND:
      case HplsqlParser::T_NUMERIC:
      case HplsqlParser::T_NUMBER:
      case HplsqlParser::T_OBJECT:
      case HplsqlParser::T_OFF:
      case HplsqlParser::T_ON:
      case HplsqlParser::T_ONLY:
      case HplsqlParser::T_OPEN:
      case HplsqlParser::T_OR:
      case HplsqlParser::T_ORDER:
      case HplsqlParser::T_OUT:
      case HplsqlParser::T_OUTER:
      case HplsqlParser::T_OVER:
      case HplsqlParser::T_OVERWRITE:
      case HplsqlParser::T_OWNER:
      case HplsqlParser::T_PACKAGE:
      case HplsqlParser::T_PARTITION:
      case HplsqlParser::T_PCTFREE:
      case HplsqlParser::T_PCTUSED:
      case HplsqlParser::T_PRECISION:
      case HplsqlParser::T_PRESERVE:
      case HplsqlParser::T_PRIMARY:
      case HplsqlParser::T_PRINT:
      case HplsqlParser::T_PROC:
      case HplsqlParser::T_PROCEDURE:
      case HplsqlParser::T_QUALIFY:
      case HplsqlParser::T_QUERY_BAND:
      case HplsqlParser::T_QUIT:
      case HplsqlParser::T_QUOTED_IDENTIFIER:
      case HplsqlParser::T_RAISE:
      case HplsqlParser::T_REAL:
      case HplsqlParser::T_REFERENCES:
      case HplsqlParser::T_REGEXP:
      case HplsqlParser::T_REPLACE:
      case HplsqlParser::T_RESIGNAL:
      case HplsqlParser::T_RESTRICT:
      case HplsqlParser::T_RESULT:
      case HplsqlParser::T_RESULT_SET_LOCATOR:
      case HplsqlParser::T_RETURN:
      case HplsqlParser::T_RETURNS:
      case HplsqlParser::T_REVERSE:
      case HplsqlParser::T_RIGHT:
      case HplsqlParser::T_RLIKE:
      case HplsqlParser::T_ROLE:
      case HplsqlParser::T_ROLLBACK:
      case HplsqlParser::T_ROW:
      case HplsqlParser::T_ROWS:
      case HplsqlParser::T_ROW_COUNT:
      case HplsqlParser::T_RR:
      case HplsqlParser::T_RS:
      case HplsqlParser::T_PWD:
      case HplsqlParser::T_TRIM:
      case HplsqlParser::T_SCHEMA:
      case HplsqlParser::T_SECOND:
      case HplsqlParser::T_SECONDS:
      case HplsqlParser::T_SECURITY:
      case HplsqlParser::T_SEGMENT:
      case HplsqlParser::T_SEL:
      case HplsqlParser::T_SELECT:
      case HplsqlParser::T_SET:
      case HplsqlParser::T_SESSION:
      case HplsqlParser::T_SESSIONS:
      case HplsqlParser::T_SETS:
      case HplsqlParser::T_SHARE:
      case HplsqlParser::T_SIGNAL:
      case HplsqlParser::T_SIMPLE_DOUBLE:
      case HplsqlParser::T_SIMPLE_FLOAT:
      case HplsqlParser::T_SMALLDATETIME:
      case HplsqlParser::T_SMALLINT:
      case HplsqlParser::T_SQL:
      case HplsqlParser::T_SQLEXCEPTION:
      case HplsqlParser::T_SQLINSERT:
      case HplsqlParser::T_SQLSTATE:
      case HplsqlParser::T_SQLWARNING:
      case HplsqlParser::T_STATS:
      case HplsqlParser::T_STATISTICS:
      case HplsqlParser::T_STEP:
      case HplsqlParser::T_STORAGE:
      case HplsqlParser::T_STORED:
      case HplsqlParser::T_STRING:
      case HplsqlParser::T_SUBDIR:
      case HplsqlParser::T_SUBSTRING:
      case HplsqlParser::T_SUM:
      case HplsqlParser::T_SYS_REFCURSOR:
      case HplsqlParser::T_TABLE:
      case HplsqlParser::T_TABLESPACE:
      case HplsqlParser::T_TEMPORARY:
      case HplsqlParser::T_TERMINATED:
      case HplsqlParser::T_TEXTIMAGE_ON:
      case HplsqlParser::T_THEN:
      case HplsqlParser::T_TIMESTAMP:
      case HplsqlParser::T_TITLE:
      case HplsqlParser::T_TO:
      case HplsqlParser::T_TOP:
      case HplsqlParser::T_TRANSACTION:
      case HplsqlParser::T_TRUE:
      case HplsqlParser::T_TRUNCATE:
      case HplsqlParser::T_UNIQUE:
      case HplsqlParser::T_UPDATE:
      case HplsqlParser::T_UR:
      case HplsqlParser::T_USE:
      case HplsqlParser::T_USING:
      case HplsqlParser::T_VALUE:
      case HplsqlParser::T_VALUES:
      case HplsqlParser::T_VAR:
      case HplsqlParser::T_VARCHAR:
      case HplsqlParser::T_VARCHAR2:
      case HplsqlParser::T_VARYING:
      case HplsqlParser::T_VOLATILE:
      case HplsqlParser::T_WHILE:
      case HplsqlParser::T_WITH:
      case HplsqlParser::T_WITHOUT:
      case HplsqlParser::T_WORK:
      case HplsqlParser::T_XACT_ABORT:
      case HplsqlParser::T_XML:
      case HplsqlParser::T_YES:
      case HplsqlParser::T_ACTIVITY_COUNT:
      case HplsqlParser::T_CUME_DIST:
      case HplsqlParser::T_CURRENT_DATE:
      case HplsqlParser::T_CURRENT_TIMESTAMP:
      case HplsqlParser::T_CURRENT_USER:
      case HplsqlParser::T_DENSE_RANK:
      case HplsqlParser::T_FIRST_VALUE:
      case HplsqlParser::T_LAG:
      case HplsqlParser::T_LAST_VALUE:
      case HplsqlParser::T_LEAD:
      case HplsqlParser::T_PART_COUNT:
      case HplsqlParser::T_PART_LOC:
      case HplsqlParser::T_RANK:
      case HplsqlParser::T_ROW_NUMBER:
      case HplsqlParser::T_STDEV:
      case HplsqlParser::T_SYSDATE:
      case HplsqlParser::T_VARIANCE:
      case HplsqlParser::T_USER:
      case HplsqlParser::L_ID: {
        setState(1915);
        table_name();
        break;
      }

      case HplsqlParser::T_OPEN_P: {
        setState(1916);
        match(HplsqlParser::T_OPEN_P);
        setState(1917);
        select_stmt();
        setState(1918);
        match(HplsqlParser::T_CLOSE_P);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1922);
    match(HplsqlParser::T_TO);
    setState(1924);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 215, _ctx)) {
    case 1: {
      setState(1923);
      match(HplsqlParser::T_HDFS);
      break;
    }

    default:
      break;
    }
    setState(1926);
    copy_target();
    setState(1930);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 216, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1927);
        copy_option(); 
      }
      setState(1932);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 216, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Copy_sourceContext ------------------------------------------------------------------

HplsqlParser::Copy_sourceContext::Copy_sourceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::File_nameContext* HplsqlParser::Copy_sourceContext::file_name() {
  return getRuleContext<HplsqlParser::File_nameContext>(0);
}

HplsqlParser::ExprContext* HplsqlParser::Copy_sourceContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}


size_t HplsqlParser::Copy_sourceContext::getRuleIndex() const {
  return HplsqlParser::RuleCopy_source;
}

void HplsqlParser::Copy_sourceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCopy_source(this);
}

void HplsqlParser::Copy_sourceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCopy_source(this);
}


antlrcpp::Any HplsqlParser::Copy_sourceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCopy_source(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Copy_sourceContext* HplsqlParser::copy_source() {
  Copy_sourceContext *_localctx = _tracker.createInstance<Copy_sourceContext>(_ctx, getState());
  enterRule(_localctx, 222, HplsqlParser::RuleCopy_source);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1935);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 217, _ctx)) {
    case 1: {
      setState(1933);
      file_name();
      break;
    }

    case 2: {
      setState(1934);
      expr(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Copy_targetContext ------------------------------------------------------------------

HplsqlParser::Copy_targetContext::Copy_targetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::File_nameContext* HplsqlParser::Copy_targetContext::file_name() {
  return getRuleContext<HplsqlParser::File_nameContext>(0);
}

HplsqlParser::ExprContext* HplsqlParser::Copy_targetContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}


size_t HplsqlParser::Copy_targetContext::getRuleIndex() const {
  return HplsqlParser::RuleCopy_target;
}

void HplsqlParser::Copy_targetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCopy_target(this);
}

void HplsqlParser::Copy_targetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCopy_target(this);
}


antlrcpp::Any HplsqlParser::Copy_targetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCopy_target(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Copy_targetContext* HplsqlParser::copy_target() {
  Copy_targetContext *_localctx = _tracker.createInstance<Copy_targetContext>(_ctx, getState());
  enterRule(_localctx, 224, HplsqlParser::RuleCopy_target);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1939);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 218, _ctx)) {
    case 1: {
      setState(1937);
      file_name();
      break;
    }

    case 2: {
      setState(1938);
      expr(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Copy_optionContext ------------------------------------------------------------------

HplsqlParser::Copy_optionContext::Copy_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Copy_optionContext::T_AT() {
  return getToken(HplsqlParser::T_AT, 0);
}

HplsqlParser::IdentContext* HplsqlParser::Copy_optionContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

tree::TerminalNode* HplsqlParser::Copy_optionContext::T_BATCHSIZE() {
  return getToken(HplsqlParser::T_BATCHSIZE, 0);
}

HplsqlParser::ExprContext* HplsqlParser::Copy_optionContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}

tree::TerminalNode* HplsqlParser::Copy_optionContext::T_DELIMITER() {
  return getToken(HplsqlParser::T_DELIMITER, 0);
}

tree::TerminalNode* HplsqlParser::Copy_optionContext::T_SQLINSERT() {
  return getToken(HplsqlParser::T_SQLINSERT, 0);
}


size_t HplsqlParser::Copy_optionContext::getRuleIndex() const {
  return HplsqlParser::RuleCopy_option;
}

void HplsqlParser::Copy_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCopy_option(this);
}

void HplsqlParser::Copy_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCopy_option(this);
}


antlrcpp::Any HplsqlParser::Copy_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCopy_option(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Copy_optionContext* HplsqlParser::copy_option() {
  Copy_optionContext *_localctx = _tracker.createInstance<Copy_optionContext>(_ctx, getState());
  enterRule(_localctx, 226, HplsqlParser::RuleCopy_option);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1949);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_AT: {
        enterOuterAlt(_localctx, 1);
        setState(1941);
        match(HplsqlParser::T_AT);
        setState(1942);
        ident();
        break;
      }

      case HplsqlParser::T_BATCHSIZE: {
        enterOuterAlt(_localctx, 2);
        setState(1943);
        match(HplsqlParser::T_BATCHSIZE);
        setState(1944);
        expr(0);
        break;
      }

      case HplsqlParser::T_DELIMITER: {
        enterOuterAlt(_localctx, 3);
        setState(1945);
        match(HplsqlParser::T_DELIMITER);
        setState(1946);
        expr(0);
        break;
      }

      case HplsqlParser::T_SQLINSERT: {
        enterOuterAlt(_localctx, 4);
        setState(1947);
        match(HplsqlParser::T_SQLINSERT);
        setState(1948);
        ident();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Copy_file_optionContext ------------------------------------------------------------------

HplsqlParser::Copy_file_optionContext::Copy_file_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Copy_file_optionContext::T_DELETE() {
  return getToken(HplsqlParser::T_DELETE, 0);
}

tree::TerminalNode* HplsqlParser::Copy_file_optionContext::T_IGNORE() {
  return getToken(HplsqlParser::T_IGNORE, 0);
}

tree::TerminalNode* HplsqlParser::Copy_file_optionContext::T_OVERWRITE() {
  return getToken(HplsqlParser::T_OVERWRITE, 0);
}


size_t HplsqlParser::Copy_file_optionContext::getRuleIndex() const {
  return HplsqlParser::RuleCopy_file_option;
}

void HplsqlParser::Copy_file_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCopy_file_option(this);
}

void HplsqlParser::Copy_file_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCopy_file_option(this);
}


antlrcpp::Any HplsqlParser::Copy_file_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCopy_file_option(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Copy_file_optionContext* HplsqlParser::copy_file_option() {
  Copy_file_optionContext *_localctx = _tracker.createInstance<Copy_file_optionContext>(_ctx, getState());
  enterRule(_localctx, 228, HplsqlParser::RuleCopy_file_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1951);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_DELETE

    || _la == HplsqlParser::T_IGNORE || _la == HplsqlParser::T_OVERWRITE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Commit_stmtContext ------------------------------------------------------------------

HplsqlParser::Commit_stmtContext::Commit_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Commit_stmtContext::T_COMMIT() {
  return getToken(HplsqlParser::T_COMMIT, 0);
}

tree::TerminalNode* HplsqlParser::Commit_stmtContext::T_WORK() {
  return getToken(HplsqlParser::T_WORK, 0);
}


size_t HplsqlParser::Commit_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleCommit_stmt;
}

void HplsqlParser::Commit_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommit_stmt(this);
}

void HplsqlParser::Commit_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommit_stmt(this);
}


antlrcpp::Any HplsqlParser::Commit_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCommit_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Commit_stmtContext* HplsqlParser::commit_stmt() {
  Commit_stmtContext *_localctx = _tracker.createInstance<Commit_stmtContext>(_ctx, getState());
  enterRule(_localctx, 230, HplsqlParser::RuleCommit_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1953);
    match(HplsqlParser::T_COMMIT);
    setState(1955);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 220, _ctx)) {
    case 1: {
      setState(1954);
      match(HplsqlParser::T_WORK);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_index_stmtContext ------------------------------------------------------------------

HplsqlParser::Create_index_stmtContext::Create_index_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Create_index_stmtContext::T_CREATE() {
  return getToken(HplsqlParser::T_CREATE, 0);
}

tree::TerminalNode* HplsqlParser::Create_index_stmtContext::T_INDEX() {
  return getToken(HplsqlParser::T_INDEX, 0);
}

HplsqlParser::IdentContext* HplsqlParser::Create_index_stmtContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_index_stmtContext::T_ON() {
  return getToken(HplsqlParser::T_ON, 0);
}

HplsqlParser::Table_nameContext* HplsqlParser::Create_index_stmtContext::table_name() {
  return getRuleContext<HplsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_index_stmtContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

std::vector<HplsqlParser::Create_index_colContext *> HplsqlParser::Create_index_stmtContext::create_index_col() {
  return getRuleContexts<HplsqlParser::Create_index_colContext>();
}

HplsqlParser::Create_index_colContext* HplsqlParser::Create_index_stmtContext::create_index_col(size_t i) {
  return getRuleContext<HplsqlParser::Create_index_colContext>(i);
}

tree::TerminalNode* HplsqlParser::Create_index_stmtContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

tree::TerminalNode* HplsqlParser::Create_index_stmtContext::T_UNIQUE() {
  return getToken(HplsqlParser::T_UNIQUE, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Create_index_stmtContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Create_index_stmtContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Create_index_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_index_stmt;
}

void HplsqlParser::Create_index_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_index_stmt(this);
}

void HplsqlParser::Create_index_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_index_stmt(this);
}


antlrcpp::Any HplsqlParser::Create_index_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_index_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_index_stmtContext* HplsqlParser::create_index_stmt() {
  Create_index_stmtContext *_localctx = _tracker.createInstance<Create_index_stmtContext>(_ctx, getState());
  enterRule(_localctx, 232, HplsqlParser::RuleCreate_index_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1957);
    match(HplsqlParser::T_CREATE);
    setState(1959);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_UNIQUE) {
      setState(1958);
      match(HplsqlParser::T_UNIQUE);
    }
    setState(1961);
    match(HplsqlParser::T_INDEX);
    setState(1962);
    ident();
    setState(1963);
    match(HplsqlParser::T_ON);
    setState(1964);
    table_name();
    setState(1965);
    match(HplsqlParser::T_OPEN_P);
    setState(1966);
    create_index_col();
    setState(1971);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HplsqlParser::T_COMMA) {
      setState(1967);
      match(HplsqlParser::T_COMMA);
      setState(1968);
      create_index_col();
      setState(1973);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1974);
    match(HplsqlParser::T_CLOSE_P);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_index_colContext ------------------------------------------------------------------

HplsqlParser::Create_index_colContext::Create_index_colContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::IdentContext* HplsqlParser::Create_index_colContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

tree::TerminalNode* HplsqlParser::Create_index_colContext::T_ASC() {
  return getToken(HplsqlParser::T_ASC, 0);
}

tree::TerminalNode* HplsqlParser::Create_index_colContext::T_DESC() {
  return getToken(HplsqlParser::T_DESC, 0);
}


size_t HplsqlParser::Create_index_colContext::getRuleIndex() const {
  return HplsqlParser::RuleCreate_index_col;
}

void HplsqlParser::Create_index_colContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_index_col(this);
}

void HplsqlParser::Create_index_colContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_index_col(this);
}


antlrcpp::Any HplsqlParser::Create_index_colContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCreate_index_col(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Create_index_colContext* HplsqlParser::create_index_col() {
  Create_index_colContext *_localctx = _tracker.createInstance<Create_index_colContext>(_ctx, getState());
  enterRule(_localctx, 234, HplsqlParser::RuleCreate_index_col);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1976);
    ident();
    setState(1978);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_ASC || _la == HplsqlParser::T_DESC) {
      setState(1977);
      _la = _input->LA(1);
      if (!(_la == HplsqlParser::T_ASC || _la == HplsqlParser::T_DESC)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_storage_clauseContext ------------------------------------------------------------------

HplsqlParser::Index_storage_clauseContext::Index_storage_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Index_mssql_storage_clauseContext* HplsqlParser::Index_storage_clauseContext::index_mssql_storage_clause() {
  return getRuleContext<HplsqlParser::Index_mssql_storage_clauseContext>(0);
}


size_t HplsqlParser::Index_storage_clauseContext::getRuleIndex() const {
  return HplsqlParser::RuleIndex_storage_clause;
}

void HplsqlParser::Index_storage_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex_storage_clause(this);
}

void HplsqlParser::Index_storage_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex_storage_clause(this);
}


antlrcpp::Any HplsqlParser::Index_storage_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitIndex_storage_clause(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Index_storage_clauseContext* HplsqlParser::index_storage_clause() {
  Index_storage_clauseContext *_localctx = _tracker.createInstance<Index_storage_clauseContext>(_ctx, getState());
  enterRule(_localctx, 236, HplsqlParser::RuleIndex_storage_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1980);
    index_mssql_storage_clause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_mssql_storage_clauseContext ------------------------------------------------------------------

HplsqlParser::Index_mssql_storage_clauseContext::Index_mssql_storage_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Index_mssql_storage_clauseContext::T_WITH() {
  return getToken(HplsqlParser::T_WITH, 0);
}

tree::TerminalNode* HplsqlParser::Index_mssql_storage_clauseContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

std::vector<HplsqlParser::IdentContext *> HplsqlParser::Index_mssql_storage_clauseContext::ident() {
  return getRuleContexts<HplsqlParser::IdentContext>();
}

HplsqlParser::IdentContext* HplsqlParser::Index_mssql_storage_clauseContext::ident(size_t i) {
  return getRuleContext<HplsqlParser::IdentContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Index_mssql_storage_clauseContext::T_EQUAL() {
  return getTokens(HplsqlParser::T_EQUAL);
}

tree::TerminalNode* HplsqlParser::Index_mssql_storage_clauseContext::T_EQUAL(size_t i) {
  return getToken(HplsqlParser::T_EQUAL, i);
}

tree::TerminalNode* HplsqlParser::Index_mssql_storage_clauseContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Index_mssql_storage_clauseContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Index_mssql_storage_clauseContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}

std::vector<HplsqlParser::Create_table_options_mssql_itemContext *> HplsqlParser::Index_mssql_storage_clauseContext::create_table_options_mssql_item() {
  return getRuleContexts<HplsqlParser::Create_table_options_mssql_itemContext>();
}

HplsqlParser::Create_table_options_mssql_itemContext* HplsqlParser::Index_mssql_storage_clauseContext::create_table_options_mssql_item(size_t i) {
  return getRuleContext<HplsqlParser::Create_table_options_mssql_itemContext>(i);
}


size_t HplsqlParser::Index_mssql_storage_clauseContext::getRuleIndex() const {
  return HplsqlParser::RuleIndex_mssql_storage_clause;
}

void HplsqlParser::Index_mssql_storage_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex_mssql_storage_clause(this);
}

void HplsqlParser::Index_mssql_storage_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex_mssql_storage_clause(this);
}


antlrcpp::Any HplsqlParser::Index_mssql_storage_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitIndex_mssql_storage_clause(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Index_mssql_storage_clauseContext* HplsqlParser::index_mssql_storage_clause() {
  Index_mssql_storage_clauseContext *_localctx = _tracker.createInstance<Index_mssql_storage_clauseContext>(_ctx, getState());
  enterRule(_localctx, 238, HplsqlParser::RuleIndex_mssql_storage_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1982);
    match(HplsqlParser::T_WITH);
    setState(1983);
    match(HplsqlParser::T_OPEN_P);
    setState(1984);
    ident();
    setState(1985);
    match(HplsqlParser::T_EQUAL);
    setState(1986);
    ident();
    setState(1994);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HplsqlParser::T_COMMA) {
      setState(1987);
      match(HplsqlParser::T_COMMA);
      setState(1988);
      ident();
      setState(1989);
      match(HplsqlParser::T_EQUAL);
      setState(1990);
      ident();
      setState(1996);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1997);
    match(HplsqlParser::T_CLOSE_P);
    setState(2001);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 225, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1998);
        create_table_options_mssql_item(); 
      }
      setState(2003);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 225, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Print_stmtContext ------------------------------------------------------------------

HplsqlParser::Print_stmtContext::Print_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Print_stmtContext::T_PRINT() {
  return getToken(HplsqlParser::T_PRINT, 0);
}

HplsqlParser::ExprContext* HplsqlParser::Print_stmtContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}

tree::TerminalNode* HplsqlParser::Print_stmtContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

tree::TerminalNode* HplsqlParser::Print_stmtContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}


size_t HplsqlParser::Print_stmtContext::getRuleIndex() const {
  return HplsqlParser::RulePrint_stmt;
}

void HplsqlParser::Print_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrint_stmt(this);
}

void HplsqlParser::Print_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrint_stmt(this);
}


antlrcpp::Any HplsqlParser::Print_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitPrint_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Print_stmtContext* HplsqlParser::print_stmt() {
  Print_stmtContext *_localctx = _tracker.createInstance<Print_stmtContext>(_ctx, getState());
  enterRule(_localctx, 240, HplsqlParser::RulePrint_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2011);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 226, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2004);
      match(HplsqlParser::T_PRINT);
      setState(2005);
      expr(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2006);
      match(HplsqlParser::T_PRINT);
      setState(2007);
      match(HplsqlParser::T_OPEN_P);
      setState(2008);
      expr(0);
      setState(2009);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Quit_stmtContext ------------------------------------------------------------------

HplsqlParser::Quit_stmtContext::Quit_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Quit_stmtContext::T_QUIT() {
  return getToken(HplsqlParser::T_QUIT, 0);
}

HplsqlParser::ExprContext* HplsqlParser::Quit_stmtContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}


size_t HplsqlParser::Quit_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleQuit_stmt;
}

void HplsqlParser::Quit_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuit_stmt(this);
}

void HplsqlParser::Quit_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuit_stmt(this);
}


antlrcpp::Any HplsqlParser::Quit_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitQuit_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Quit_stmtContext* HplsqlParser::quit_stmt() {
  Quit_stmtContext *_localctx = _tracker.createInstance<Quit_stmtContext>(_ctx, getState());
  enterRule(_localctx, 242, HplsqlParser::RuleQuit_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2014);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T__3) {
      setState(2013);
      match(HplsqlParser::T__3);
    }
    setState(2016);
    match(HplsqlParser::T_QUIT);
    setState(2018);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 228, _ctx)) {
    case 1: {
      setState(2017);
      expr(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Raise_stmtContext ------------------------------------------------------------------

HplsqlParser::Raise_stmtContext::Raise_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Raise_stmtContext::T_RAISE() {
  return getToken(HplsqlParser::T_RAISE, 0);
}


size_t HplsqlParser::Raise_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleRaise_stmt;
}

void HplsqlParser::Raise_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRaise_stmt(this);
}

void HplsqlParser::Raise_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRaise_stmt(this);
}


antlrcpp::Any HplsqlParser::Raise_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitRaise_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Raise_stmtContext* HplsqlParser::raise_stmt() {
  Raise_stmtContext *_localctx = _tracker.createInstance<Raise_stmtContext>(_ctx, getState());
  enterRule(_localctx, 244, HplsqlParser::RuleRaise_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2020);
    match(HplsqlParser::T_RAISE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Resignal_stmtContext ------------------------------------------------------------------

HplsqlParser::Resignal_stmtContext::Resignal_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Resignal_stmtContext::T_RESIGNAL() {
  return getToken(HplsqlParser::T_RESIGNAL, 0);
}

tree::TerminalNode* HplsqlParser::Resignal_stmtContext::T_SQLSTATE() {
  return getToken(HplsqlParser::T_SQLSTATE, 0);
}

std::vector<HplsqlParser::ExprContext *> HplsqlParser::Resignal_stmtContext::expr() {
  return getRuleContexts<HplsqlParser::ExprContext>();
}

HplsqlParser::ExprContext* HplsqlParser::Resignal_stmtContext::expr(size_t i) {
  return getRuleContext<HplsqlParser::ExprContext>(i);
}

tree::TerminalNode* HplsqlParser::Resignal_stmtContext::T_VALUE() {
  return getToken(HplsqlParser::T_VALUE, 0);
}

tree::TerminalNode* HplsqlParser::Resignal_stmtContext::T_SET() {
  return getToken(HplsqlParser::T_SET, 0);
}

tree::TerminalNode* HplsqlParser::Resignal_stmtContext::T_MESSAGE_TEXT() {
  return getToken(HplsqlParser::T_MESSAGE_TEXT, 0);
}

tree::TerminalNode* HplsqlParser::Resignal_stmtContext::T_EQUAL() {
  return getToken(HplsqlParser::T_EQUAL, 0);
}


size_t HplsqlParser::Resignal_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleResignal_stmt;
}

void HplsqlParser::Resignal_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResignal_stmt(this);
}

void HplsqlParser::Resignal_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResignal_stmt(this);
}


antlrcpp::Any HplsqlParser::Resignal_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitResignal_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Resignal_stmtContext* HplsqlParser::resignal_stmt() {
  Resignal_stmtContext *_localctx = _tracker.createInstance<Resignal_stmtContext>(_ctx, getState());
  enterRule(_localctx, 246, HplsqlParser::RuleResignal_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2022);
    match(HplsqlParser::T_RESIGNAL);
    setState(2034);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 231, _ctx)) {
    case 1: {
      setState(2023);
      match(HplsqlParser::T_SQLSTATE);
      setState(2025);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 229, _ctx)) {
      case 1: {
        setState(2024);
        match(HplsqlParser::T_VALUE);
        break;
      }

      default:
        break;
      }
      setState(2027);
      expr(0);
      setState(2032);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 230, _ctx)) {
      case 1: {
        setState(2028);
        match(HplsqlParser::T_SET);
        setState(2029);
        match(HplsqlParser::T_MESSAGE_TEXT);
        setState(2030);
        match(HplsqlParser::T_EQUAL);
        setState(2031);
        expr(0);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Return_stmtContext ------------------------------------------------------------------

HplsqlParser::Return_stmtContext::Return_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Return_stmtContext::T_RETURN() {
  return getToken(HplsqlParser::T_RETURN, 0);
}

HplsqlParser::ExprContext* HplsqlParser::Return_stmtContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}


size_t HplsqlParser::Return_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleReturn_stmt;
}

void HplsqlParser::Return_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturn_stmt(this);
}

void HplsqlParser::Return_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturn_stmt(this);
}


antlrcpp::Any HplsqlParser::Return_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitReturn_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Return_stmtContext* HplsqlParser::return_stmt() {
  Return_stmtContext *_localctx = _tracker.createInstance<Return_stmtContext>(_ctx, getState());
  enterRule(_localctx, 248, HplsqlParser::RuleReturn_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2036);
    match(HplsqlParser::T_RETURN);
    setState(2038);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 232, _ctx)) {
    case 1: {
      setState(2037);
      expr(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rollback_stmtContext ------------------------------------------------------------------

HplsqlParser::Rollback_stmtContext::Rollback_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Rollback_stmtContext::T_ROLLBACK() {
  return getToken(HplsqlParser::T_ROLLBACK, 0);
}

tree::TerminalNode* HplsqlParser::Rollback_stmtContext::T_WORK() {
  return getToken(HplsqlParser::T_WORK, 0);
}


size_t HplsqlParser::Rollback_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleRollback_stmt;
}

void HplsqlParser::Rollback_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRollback_stmt(this);
}

void HplsqlParser::Rollback_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRollback_stmt(this);
}


antlrcpp::Any HplsqlParser::Rollback_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitRollback_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Rollback_stmtContext* HplsqlParser::rollback_stmt() {
  Rollback_stmtContext *_localctx = _tracker.createInstance<Rollback_stmtContext>(_ctx, getState());
  enterRule(_localctx, 250, HplsqlParser::RuleRollback_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2040);
    match(HplsqlParser::T_ROLLBACK);
    setState(2042);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 233, _ctx)) {
    case 1: {
      setState(2041);
      match(HplsqlParser::T_WORK);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_session_optionContext ------------------------------------------------------------------

HplsqlParser::Set_session_optionContext::Set_session_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Set_current_schema_optionContext* HplsqlParser::Set_session_optionContext::set_current_schema_option() {
  return getRuleContext<HplsqlParser::Set_current_schema_optionContext>(0);
}

HplsqlParser::Set_mssql_session_optionContext* HplsqlParser::Set_session_optionContext::set_mssql_session_option() {
  return getRuleContext<HplsqlParser::Set_mssql_session_optionContext>(0);
}

HplsqlParser::Set_teradata_session_optionContext* HplsqlParser::Set_session_optionContext::set_teradata_session_option() {
  return getRuleContext<HplsqlParser::Set_teradata_session_optionContext>(0);
}


size_t HplsqlParser::Set_session_optionContext::getRuleIndex() const {
  return HplsqlParser::RuleSet_session_option;
}

void HplsqlParser::Set_session_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSet_session_option(this);
}

void HplsqlParser::Set_session_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSet_session_option(this);
}


antlrcpp::Any HplsqlParser::Set_session_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitSet_session_option(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Set_session_optionContext* HplsqlParser::set_session_option() {
  Set_session_optionContext *_localctx = _tracker.createInstance<Set_session_optionContext>(_ctx, getState());
  enterRule(_localctx, 252, HplsqlParser::RuleSet_session_option);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2047);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_CURRENT:
      case HplsqlParser::T_CURRENT_SCHEMA:
      case HplsqlParser::T_SCHEMA: {
        enterOuterAlt(_localctx, 1);
        setState(2044);
        set_current_schema_option();
        break;
      }

      case HplsqlParser::T_ANSI_NULLS:
      case HplsqlParser::T_ANSI_PADDING:
      case HplsqlParser::T_NOCOUNT:
      case HplsqlParser::T_QUOTED_IDENTIFIER:
      case HplsqlParser::T_XACT_ABORT: {
        enterOuterAlt(_localctx, 2);
        setState(2045);
        set_mssql_session_option();
        break;
      }

      case HplsqlParser::T_QUERY_BAND: {
        enterOuterAlt(_localctx, 3);
        setState(2046);
        set_teradata_session_option();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_current_schema_optionContext ------------------------------------------------------------------

HplsqlParser::Set_current_schema_optionContext::Set_current_schema_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::ExprContext* HplsqlParser::Set_current_schema_optionContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}

tree::TerminalNode* HplsqlParser::Set_current_schema_optionContext::T_CURRENT_SCHEMA() {
  return getToken(HplsqlParser::T_CURRENT_SCHEMA, 0);
}

tree::TerminalNode* HplsqlParser::Set_current_schema_optionContext::T_EQUAL() {
  return getToken(HplsqlParser::T_EQUAL, 0);
}

tree::TerminalNode* HplsqlParser::Set_current_schema_optionContext::T_SCHEMA() {
  return getToken(HplsqlParser::T_SCHEMA, 0);
}

tree::TerminalNode* HplsqlParser::Set_current_schema_optionContext::T_CURRENT() {
  return getToken(HplsqlParser::T_CURRENT, 0);
}


size_t HplsqlParser::Set_current_schema_optionContext::getRuleIndex() const {
  return HplsqlParser::RuleSet_current_schema_option;
}

void HplsqlParser::Set_current_schema_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSet_current_schema_option(this);
}

void HplsqlParser::Set_current_schema_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSet_current_schema_option(this);
}


antlrcpp::Any HplsqlParser::Set_current_schema_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitSet_current_schema_option(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Set_current_schema_optionContext* HplsqlParser::set_current_schema_option() {
  Set_current_schema_optionContext *_localctx = _tracker.createInstance<Set_current_schema_optionContext>(_ctx, getState());
  enterRule(_localctx, 254, HplsqlParser::RuleSet_current_schema_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2054);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_CURRENT:
      case HplsqlParser::T_SCHEMA: {
        setState(2050);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_CURRENT) {
          setState(2049);
          match(HplsqlParser::T_CURRENT);
        }
        setState(2052);
        match(HplsqlParser::T_SCHEMA);
        break;
      }

      case HplsqlParser::T_CURRENT_SCHEMA: {
        setState(2053);
        match(HplsqlParser::T_CURRENT_SCHEMA);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2057);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_EQUAL) {
      setState(2056);
      match(HplsqlParser::T_EQUAL);
    }
    setState(2059);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_mssql_session_optionContext ------------------------------------------------------------------

HplsqlParser::Set_mssql_session_optionContext::Set_mssql_session_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Set_mssql_session_optionContext::T_ANSI_NULLS() {
  return getToken(HplsqlParser::T_ANSI_NULLS, 0);
}

tree::TerminalNode* HplsqlParser::Set_mssql_session_optionContext::T_ANSI_PADDING() {
  return getToken(HplsqlParser::T_ANSI_PADDING, 0);
}

tree::TerminalNode* HplsqlParser::Set_mssql_session_optionContext::T_NOCOUNT() {
  return getToken(HplsqlParser::T_NOCOUNT, 0);
}

tree::TerminalNode* HplsqlParser::Set_mssql_session_optionContext::T_QUOTED_IDENTIFIER() {
  return getToken(HplsqlParser::T_QUOTED_IDENTIFIER, 0);
}

tree::TerminalNode* HplsqlParser::Set_mssql_session_optionContext::T_XACT_ABORT() {
  return getToken(HplsqlParser::T_XACT_ABORT, 0);
}

tree::TerminalNode* HplsqlParser::Set_mssql_session_optionContext::T_ON() {
  return getToken(HplsqlParser::T_ON, 0);
}

tree::TerminalNode* HplsqlParser::Set_mssql_session_optionContext::T_OFF() {
  return getToken(HplsqlParser::T_OFF, 0);
}


size_t HplsqlParser::Set_mssql_session_optionContext::getRuleIndex() const {
  return HplsqlParser::RuleSet_mssql_session_option;
}

void HplsqlParser::Set_mssql_session_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSet_mssql_session_option(this);
}

void HplsqlParser::Set_mssql_session_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSet_mssql_session_option(this);
}


antlrcpp::Any HplsqlParser::Set_mssql_session_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitSet_mssql_session_option(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Set_mssql_session_optionContext* HplsqlParser::set_mssql_session_option() {
  Set_mssql_session_optionContext *_localctx = _tracker.createInstance<Set_mssql_session_optionContext>(_ctx, getState());
  enterRule(_localctx, 256, HplsqlParser::RuleSet_mssql_session_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2061);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_ANSI_NULLS

    || _la == HplsqlParser::T_ANSI_PADDING || _la == HplsqlParser::T_NOCOUNT

    || _la == HplsqlParser::T_QUOTED_IDENTIFIER || _la == HplsqlParser::T_XACT_ABORT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2062);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_OFF

    || _la == HplsqlParser::T_ON)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_teradata_session_optionContext ------------------------------------------------------------------

HplsqlParser::Set_teradata_session_optionContext::Set_teradata_session_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Set_teradata_session_optionContext::T_QUERY_BAND() {
  return getToken(HplsqlParser::T_QUERY_BAND, 0);
}

tree::TerminalNode* HplsqlParser::Set_teradata_session_optionContext::T_EQUAL() {
  return getToken(HplsqlParser::T_EQUAL, 0);
}

tree::TerminalNode* HplsqlParser::Set_teradata_session_optionContext::T_FOR() {
  return getToken(HplsqlParser::T_FOR, 0);
}

tree::TerminalNode* HplsqlParser::Set_teradata_session_optionContext::T_TRANSACTION() {
  return getToken(HplsqlParser::T_TRANSACTION, 0);
}

tree::TerminalNode* HplsqlParser::Set_teradata_session_optionContext::T_SESSION() {
  return getToken(HplsqlParser::T_SESSION, 0);
}

HplsqlParser::ExprContext* HplsqlParser::Set_teradata_session_optionContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}

tree::TerminalNode* HplsqlParser::Set_teradata_session_optionContext::T_NONE() {
  return getToken(HplsqlParser::T_NONE, 0);
}

tree::TerminalNode* HplsqlParser::Set_teradata_session_optionContext::T_UPDATE() {
  return getToken(HplsqlParser::T_UPDATE, 0);
}


size_t HplsqlParser::Set_teradata_session_optionContext::getRuleIndex() const {
  return HplsqlParser::RuleSet_teradata_session_option;
}

void HplsqlParser::Set_teradata_session_optionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSet_teradata_session_option(this);
}

void HplsqlParser::Set_teradata_session_optionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSet_teradata_session_option(this);
}


antlrcpp::Any HplsqlParser::Set_teradata_session_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitSet_teradata_session_option(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Set_teradata_session_optionContext* HplsqlParser::set_teradata_session_option() {
  Set_teradata_session_optionContext *_localctx = _tracker.createInstance<Set_teradata_session_optionContext>(_ctx, getState());
  enterRule(_localctx, 258, HplsqlParser::RuleSet_teradata_session_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2064);
    match(HplsqlParser::T_QUERY_BAND);
    setState(2065);
    match(HplsqlParser::T_EQUAL);
    setState(2068);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 238, _ctx)) {
    case 1: {
      setState(2066);
      expr(0);
      break;
    }

    case 2: {
      setState(2067);
      match(HplsqlParser::T_NONE);
      break;
    }

    default:
      break;
    }
    setState(2071);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_UPDATE) {
      setState(2070);
      match(HplsqlParser::T_UPDATE);
    }
    setState(2073);
    match(HplsqlParser::T_FOR);
    setState(2074);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_SESSION

    || _la == HplsqlParser::T_TRANSACTION)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Signal_stmtContext ------------------------------------------------------------------

HplsqlParser::Signal_stmtContext::Signal_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Signal_stmtContext::T_SIGNAL() {
  return getToken(HplsqlParser::T_SIGNAL, 0);
}

HplsqlParser::IdentContext* HplsqlParser::Signal_stmtContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}


size_t HplsqlParser::Signal_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleSignal_stmt;
}

void HplsqlParser::Signal_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignal_stmt(this);
}

void HplsqlParser::Signal_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignal_stmt(this);
}


antlrcpp::Any HplsqlParser::Signal_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitSignal_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Signal_stmtContext* HplsqlParser::signal_stmt() {
  Signal_stmtContext *_localctx = _tracker.createInstance<Signal_stmtContext>(_ctx, getState());
  enterRule(_localctx, 260, HplsqlParser::RuleSignal_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2076);
    match(HplsqlParser::T_SIGNAL);
    setState(2077);
    ident();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Truncate_stmtContext ------------------------------------------------------------------

HplsqlParser::Truncate_stmtContext::Truncate_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Truncate_stmtContext::T_TRUNCATE() {
  return getToken(HplsqlParser::T_TRUNCATE, 0);
}

HplsqlParser::Table_nameContext* HplsqlParser::Truncate_stmtContext::table_name() {
  return getRuleContext<HplsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* HplsqlParser::Truncate_stmtContext::T_TABLE() {
  return getToken(HplsqlParser::T_TABLE, 0);
}


size_t HplsqlParser::Truncate_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleTruncate_stmt;
}

void HplsqlParser::Truncate_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTruncate_stmt(this);
}

void HplsqlParser::Truncate_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTruncate_stmt(this);
}


antlrcpp::Any HplsqlParser::Truncate_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitTruncate_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Truncate_stmtContext* HplsqlParser::truncate_stmt() {
  Truncate_stmtContext *_localctx = _tracker.createInstance<Truncate_stmtContext>(_ctx, getState());
  enterRule(_localctx, 262, HplsqlParser::RuleTruncate_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2079);
    match(HplsqlParser::T_TRUNCATE);
    setState(2081);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 240, _ctx)) {
    case 1: {
      setState(2080);
      match(HplsqlParser::T_TABLE);
      break;
    }

    default:
      break;
    }
    setState(2083);
    table_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Use_stmtContext ------------------------------------------------------------------

HplsqlParser::Use_stmtContext::Use_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Use_stmtContext::T_USE() {
  return getToken(HplsqlParser::T_USE, 0);
}

HplsqlParser::ExprContext* HplsqlParser::Use_stmtContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}


size_t HplsqlParser::Use_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleUse_stmt;
}

void HplsqlParser::Use_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUse_stmt(this);
}

void HplsqlParser::Use_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUse_stmt(this);
}


antlrcpp::Any HplsqlParser::Use_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitUse_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Use_stmtContext* HplsqlParser::use_stmt() {
  Use_stmtContext *_localctx = _tracker.createInstance<Use_stmtContext>(_ctx, getState());
  enterRule(_localctx, 264, HplsqlParser::RuleUse_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2085);
    match(HplsqlParser::T_USE);
    setState(2086);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Values_into_stmtContext ------------------------------------------------------------------

HplsqlParser::Values_into_stmtContext::Values_into_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Values_into_stmtContext::T_VALUES() {
  return getToken(HplsqlParser::T_VALUES, 0);
}

std::vector<HplsqlParser::ExprContext *> HplsqlParser::Values_into_stmtContext::expr() {
  return getRuleContexts<HplsqlParser::ExprContext>();
}

HplsqlParser::ExprContext* HplsqlParser::Values_into_stmtContext::expr(size_t i) {
  return getRuleContext<HplsqlParser::ExprContext>(i);
}

tree::TerminalNode* HplsqlParser::Values_into_stmtContext::T_INTO() {
  return getToken(HplsqlParser::T_INTO, 0);
}

std::vector<HplsqlParser::IdentContext *> HplsqlParser::Values_into_stmtContext::ident() {
  return getRuleContexts<HplsqlParser::IdentContext>();
}

HplsqlParser::IdentContext* HplsqlParser::Values_into_stmtContext::ident(size_t i) {
  return getRuleContext<HplsqlParser::IdentContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Values_into_stmtContext::T_OPEN_P() {
  return getTokens(HplsqlParser::T_OPEN_P);
}

tree::TerminalNode* HplsqlParser::Values_into_stmtContext::T_OPEN_P(size_t i) {
  return getToken(HplsqlParser::T_OPEN_P, i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Values_into_stmtContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Values_into_stmtContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Values_into_stmtContext::T_CLOSE_P() {
  return getTokens(HplsqlParser::T_CLOSE_P);
}

tree::TerminalNode* HplsqlParser::Values_into_stmtContext::T_CLOSE_P(size_t i) {
  return getToken(HplsqlParser::T_CLOSE_P, i);
}


size_t HplsqlParser::Values_into_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleValues_into_stmt;
}

void HplsqlParser::Values_into_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValues_into_stmt(this);
}

void HplsqlParser::Values_into_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValues_into_stmt(this);
}


antlrcpp::Any HplsqlParser::Values_into_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitValues_into_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Values_into_stmtContext* HplsqlParser::values_into_stmt() {
  Values_into_stmtContext *_localctx = _tracker.createInstance<Values_into_stmtContext>(_ctx, getState());
  enterRule(_localctx, 266, HplsqlParser::RuleValues_into_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2088);
    match(HplsqlParser::T_VALUES);
    setState(2090);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 241, _ctx)) {
    case 1: {
      setState(2089);
      match(HplsqlParser::T_OPEN_P);
      break;
    }

    default:
      break;
    }
    setState(2092);
    expr(0);
    setState(2097);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HplsqlParser::T_COMMA) {
      setState(2093);
      match(HplsqlParser::T_COMMA);
      setState(2094);
      expr(0);
      setState(2099);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2101);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_CLOSE_P) {
      setState(2100);
      match(HplsqlParser::T_CLOSE_P);
    }
    setState(2103);
    match(HplsqlParser::T_INTO);
    setState(2105);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_OPEN_P) {
      setState(2104);
      match(HplsqlParser::T_OPEN_P);
    }
    setState(2107);
    ident();
    setState(2112);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 245, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2108);
        match(HplsqlParser::T_COMMA);
        setState(2109);
        ident(); 
      }
      setState(2114);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 245, _ctx);
    }
    setState(2116);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 246, _ctx)) {
    case 1: {
      setState(2115);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- While_stmtContext ------------------------------------------------------------------

HplsqlParser::While_stmtContext::While_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> HplsqlParser::While_stmtContext::T_WHILE() {
  return getTokens(HplsqlParser::T_WHILE);
}

tree::TerminalNode* HplsqlParser::While_stmtContext::T_WHILE(size_t i) {
  return getToken(HplsqlParser::T_WHILE, i);
}

HplsqlParser::Bool_exprContext* HplsqlParser::While_stmtContext::bool_expr() {
  return getRuleContext<HplsqlParser::Bool_exprContext>(0);
}

HplsqlParser::BlockContext* HplsqlParser::While_stmtContext::block() {
  return getRuleContext<HplsqlParser::BlockContext>(0);
}

tree::TerminalNode* HplsqlParser::While_stmtContext::T_END() {
  return getToken(HplsqlParser::T_END, 0);
}

tree::TerminalNode* HplsqlParser::While_stmtContext::T_DO() {
  return getToken(HplsqlParser::T_DO, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::While_stmtContext::T_LOOP() {
  return getTokens(HplsqlParser::T_LOOP);
}

tree::TerminalNode* HplsqlParser::While_stmtContext::T_LOOP(size_t i) {
  return getToken(HplsqlParser::T_LOOP, i);
}

tree::TerminalNode* HplsqlParser::While_stmtContext::T_THEN() {
  return getToken(HplsqlParser::T_THEN, 0);
}

tree::TerminalNode* HplsqlParser::While_stmtContext::T_BEGIN() {
  return getToken(HplsqlParser::T_BEGIN, 0);
}


size_t HplsqlParser::While_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleWhile_stmt;
}

void HplsqlParser::While_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhile_stmt(this);
}

void HplsqlParser::While_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhile_stmt(this);
}


antlrcpp::Any HplsqlParser::While_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitWhile_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::While_stmtContext* HplsqlParser::while_stmt() {
  While_stmtContext *_localctx = _tracker.createInstance<While_stmtContext>(_ctx, getState());
  enterRule(_localctx, 268, HplsqlParser::RuleWhile_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2118);
    match(HplsqlParser::T_WHILE);
    setState(2119);
    bool_expr(0);
    setState(2120);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_BEGIN || _la == HplsqlParser::T_DO || _la == HplsqlParser::T_LOOP || _la == HplsqlParser::T_THEN)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2121);
    block();
    setState(2122);
    match(HplsqlParser::T_END);
    setState(2124);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 247, _ctx)) {
    case 1: {
      setState(2123);
      _la = _input->LA(1);
      if (!(_la == HplsqlParser::T_LOOP || _la == HplsqlParser::T_WHILE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- For_cursor_stmtContext ------------------------------------------------------------------

HplsqlParser::For_cursor_stmtContext::For_cursor_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::For_cursor_stmtContext::T_FOR() {
  return getToken(HplsqlParser::T_FOR, 0);
}

tree::TerminalNode* HplsqlParser::For_cursor_stmtContext::L_ID() {
  return getToken(HplsqlParser::L_ID, 0);
}

tree::TerminalNode* HplsqlParser::For_cursor_stmtContext::T_IN() {
  return getToken(HplsqlParser::T_IN, 0);
}

HplsqlParser::Select_stmtContext* HplsqlParser::For_cursor_stmtContext::select_stmt() {
  return getRuleContext<HplsqlParser::Select_stmtContext>(0);
}

std::vector<tree::TerminalNode *> HplsqlParser::For_cursor_stmtContext::T_LOOP() {
  return getTokens(HplsqlParser::T_LOOP);
}

tree::TerminalNode* HplsqlParser::For_cursor_stmtContext::T_LOOP(size_t i) {
  return getToken(HplsqlParser::T_LOOP, i);
}

HplsqlParser::BlockContext* HplsqlParser::For_cursor_stmtContext::block() {
  return getRuleContext<HplsqlParser::BlockContext>(0);
}

tree::TerminalNode* HplsqlParser::For_cursor_stmtContext::T_END() {
  return getToken(HplsqlParser::T_END, 0);
}

tree::TerminalNode* HplsqlParser::For_cursor_stmtContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

tree::TerminalNode* HplsqlParser::For_cursor_stmtContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}


size_t HplsqlParser::For_cursor_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleFor_cursor_stmt;
}

void HplsqlParser::For_cursor_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFor_cursor_stmt(this);
}

void HplsqlParser::For_cursor_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFor_cursor_stmt(this);
}


antlrcpp::Any HplsqlParser::For_cursor_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitFor_cursor_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::For_cursor_stmtContext* HplsqlParser::for_cursor_stmt() {
  For_cursor_stmtContext *_localctx = _tracker.createInstance<For_cursor_stmtContext>(_ctx, getState());
  enterRule(_localctx, 270, HplsqlParser::RuleFor_cursor_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2126);
    match(HplsqlParser::T_FOR);
    setState(2127);
    match(HplsqlParser::L_ID);
    setState(2128);
    match(HplsqlParser::T_IN);
    setState(2130);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 248, _ctx)) {
    case 1: {
      setState(2129);
      match(HplsqlParser::T_OPEN_P);
      break;
    }

    default:
      break;
    }
    setState(2132);
    select_stmt();
    setState(2134);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_CLOSE_P) {
      setState(2133);
      match(HplsqlParser::T_CLOSE_P);
    }
    setState(2136);
    match(HplsqlParser::T_LOOP);
    setState(2137);
    block();
    setState(2138);
    match(HplsqlParser::T_END);
    setState(2139);
    match(HplsqlParser::T_LOOP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- For_range_stmtContext ------------------------------------------------------------------

HplsqlParser::For_range_stmtContext::For_range_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::For_range_stmtContext::T_FOR() {
  return getToken(HplsqlParser::T_FOR, 0);
}

tree::TerminalNode* HplsqlParser::For_range_stmtContext::L_ID() {
  return getToken(HplsqlParser::L_ID, 0);
}

tree::TerminalNode* HplsqlParser::For_range_stmtContext::T_IN() {
  return getToken(HplsqlParser::T_IN, 0);
}

std::vector<HplsqlParser::ExprContext *> HplsqlParser::For_range_stmtContext::expr() {
  return getRuleContexts<HplsqlParser::ExprContext>();
}

HplsqlParser::ExprContext* HplsqlParser::For_range_stmtContext::expr(size_t i) {
  return getRuleContext<HplsqlParser::ExprContext>(i);
}

tree::TerminalNode* HplsqlParser::For_range_stmtContext::T_DOT2() {
  return getToken(HplsqlParser::T_DOT2, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::For_range_stmtContext::T_LOOP() {
  return getTokens(HplsqlParser::T_LOOP);
}

tree::TerminalNode* HplsqlParser::For_range_stmtContext::T_LOOP(size_t i) {
  return getToken(HplsqlParser::T_LOOP, i);
}

HplsqlParser::BlockContext* HplsqlParser::For_range_stmtContext::block() {
  return getRuleContext<HplsqlParser::BlockContext>(0);
}

tree::TerminalNode* HplsqlParser::For_range_stmtContext::T_END() {
  return getToken(HplsqlParser::T_END, 0);
}

tree::TerminalNode* HplsqlParser::For_range_stmtContext::T_REVERSE() {
  return getToken(HplsqlParser::T_REVERSE, 0);
}

tree::TerminalNode* HplsqlParser::For_range_stmtContext::T_BY() {
  return getToken(HplsqlParser::T_BY, 0);
}

tree::TerminalNode* HplsqlParser::For_range_stmtContext::T_STEP() {
  return getToken(HplsqlParser::T_STEP, 0);
}


size_t HplsqlParser::For_range_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleFor_range_stmt;
}

void HplsqlParser::For_range_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFor_range_stmt(this);
}

void HplsqlParser::For_range_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFor_range_stmt(this);
}


antlrcpp::Any HplsqlParser::For_range_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitFor_range_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::For_range_stmtContext* HplsqlParser::for_range_stmt() {
  For_range_stmtContext *_localctx = _tracker.createInstance<For_range_stmtContext>(_ctx, getState());
  enterRule(_localctx, 272, HplsqlParser::RuleFor_range_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2141);
    match(HplsqlParser::T_FOR);
    setState(2142);
    match(HplsqlParser::L_ID);
    setState(2143);
    match(HplsqlParser::T_IN);
    setState(2145);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 250, _ctx)) {
    case 1: {
      setState(2144);
      match(HplsqlParser::T_REVERSE);
      break;
    }

    default:
      break;
    }
    setState(2147);
    expr(0);
    setState(2148);
    match(HplsqlParser::T_DOT2);
    setState(2149);
    expr(0);
    setState(2152);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_BY || _la == HplsqlParser::T_STEP) {
      setState(2150);
      _la = _input->LA(1);
      if (!(_la == HplsqlParser::T_BY || _la == HplsqlParser::T_STEP)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2151);
      expr(0);
    }
    setState(2154);
    match(HplsqlParser::T_LOOP);
    setState(2155);
    block();
    setState(2156);
    match(HplsqlParser::T_END);
    setState(2157);
    match(HplsqlParser::T_LOOP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelContext ------------------------------------------------------------------

HplsqlParser::LabelContext::LabelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::LabelContext::L_LABEL() {
  return getToken(HplsqlParser::L_LABEL, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::LabelContext::T_LESS() {
  return getTokens(HplsqlParser::T_LESS);
}

tree::TerminalNode* HplsqlParser::LabelContext::T_LESS(size_t i) {
  return getToken(HplsqlParser::T_LESS, i);
}

tree::TerminalNode* HplsqlParser::LabelContext::L_ID() {
  return getToken(HplsqlParser::L_ID, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::LabelContext::T_GREATER() {
  return getTokens(HplsqlParser::T_GREATER);
}

tree::TerminalNode* HplsqlParser::LabelContext::T_GREATER(size_t i) {
  return getToken(HplsqlParser::T_GREATER, i);
}


size_t HplsqlParser::LabelContext::getRuleIndex() const {
  return HplsqlParser::RuleLabel;
}

void HplsqlParser::LabelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabel(this);
}

void HplsqlParser::LabelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabel(this);
}


antlrcpp::Any HplsqlParser::LabelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitLabel(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::LabelContext* HplsqlParser::label() {
  LabelContext *_localctx = _tracker.createInstance<LabelContext>(_ctx, getState());
  enterRule(_localctx, 274, HplsqlParser::RuleLabel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2165);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::L_LABEL: {
        enterOuterAlt(_localctx, 1);
        setState(2159);
        match(HplsqlParser::L_LABEL);
        break;
      }

      case HplsqlParser::T_LESS: {
        enterOuterAlt(_localctx, 2);
        setState(2160);
        match(HplsqlParser::T_LESS);
        setState(2161);
        match(HplsqlParser::T_LESS);
        setState(2162);
        match(HplsqlParser::L_ID);
        setState(2163);
        match(HplsqlParser::T_GREATER);
        setState(2164);
        match(HplsqlParser::T_GREATER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Using_clauseContext ------------------------------------------------------------------

HplsqlParser::Using_clauseContext::Using_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Using_clauseContext::T_USING() {
  return getToken(HplsqlParser::T_USING, 0);
}

std::vector<HplsqlParser::ExprContext *> HplsqlParser::Using_clauseContext::expr() {
  return getRuleContexts<HplsqlParser::ExprContext>();
}

HplsqlParser::ExprContext* HplsqlParser::Using_clauseContext::expr(size_t i) {
  return getRuleContext<HplsqlParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Using_clauseContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Using_clauseContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Using_clauseContext::getRuleIndex() const {
  return HplsqlParser::RuleUsing_clause;
}

void HplsqlParser::Using_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUsing_clause(this);
}

void HplsqlParser::Using_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUsing_clause(this);
}


antlrcpp::Any HplsqlParser::Using_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitUsing_clause(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Using_clauseContext* HplsqlParser::using_clause() {
  Using_clauseContext *_localctx = _tracker.createInstance<Using_clauseContext>(_ctx, getState());
  enterRule(_localctx, 276, HplsqlParser::RuleUsing_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2167);
    match(HplsqlParser::T_USING);
    setState(2168);
    expr(0);
    setState(2173);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 253, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2169);
        match(HplsqlParser::T_COMMA);
        setState(2170);
        expr(0); 
      }
      setState(2175);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 253, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_stmtContext ------------------------------------------------------------------

HplsqlParser::Select_stmtContext::Select_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Fullselect_stmtContext* HplsqlParser::Select_stmtContext::fullselect_stmt() {
  return getRuleContext<HplsqlParser::Fullselect_stmtContext>(0);
}

HplsqlParser::Cte_select_stmtContext* HplsqlParser::Select_stmtContext::cte_select_stmt() {
  return getRuleContext<HplsqlParser::Cte_select_stmtContext>(0);
}


size_t HplsqlParser::Select_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleSelect_stmt;
}

void HplsqlParser::Select_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_stmt(this);
}

void HplsqlParser::Select_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_stmt(this);
}


antlrcpp::Any HplsqlParser::Select_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitSelect_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Select_stmtContext* HplsqlParser::select_stmt() {
  Select_stmtContext *_localctx = _tracker.createInstance<Select_stmtContext>(_ctx, getState());
  enterRule(_localctx, 278, HplsqlParser::RuleSelect_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2177);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_WITH) {
      setState(2176);
      cte_select_stmt();
    }
    setState(2179);
    fullselect_stmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cte_select_stmtContext ------------------------------------------------------------------

HplsqlParser::Cte_select_stmtContext::Cte_select_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Cte_select_stmtContext::T_WITH() {
  return getToken(HplsqlParser::T_WITH, 0);
}

std::vector<HplsqlParser::Cte_select_stmt_itemContext *> HplsqlParser::Cte_select_stmtContext::cte_select_stmt_item() {
  return getRuleContexts<HplsqlParser::Cte_select_stmt_itemContext>();
}

HplsqlParser::Cte_select_stmt_itemContext* HplsqlParser::Cte_select_stmtContext::cte_select_stmt_item(size_t i) {
  return getRuleContext<HplsqlParser::Cte_select_stmt_itemContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Cte_select_stmtContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Cte_select_stmtContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Cte_select_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleCte_select_stmt;
}

void HplsqlParser::Cte_select_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCte_select_stmt(this);
}

void HplsqlParser::Cte_select_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCte_select_stmt(this);
}


antlrcpp::Any HplsqlParser::Cte_select_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCte_select_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Cte_select_stmtContext* HplsqlParser::cte_select_stmt() {
  Cte_select_stmtContext *_localctx = _tracker.createInstance<Cte_select_stmtContext>(_ctx, getState());
  enterRule(_localctx, 280, HplsqlParser::RuleCte_select_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2181);
    match(HplsqlParser::T_WITH);
    setState(2182);
    cte_select_stmt_item();
    setState(2187);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HplsqlParser::T_COMMA) {
      setState(2183);
      match(HplsqlParser::T_COMMA);
      setState(2184);
      cte_select_stmt_item();
      setState(2189);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cte_select_stmt_itemContext ------------------------------------------------------------------

HplsqlParser::Cte_select_stmt_itemContext::Cte_select_stmt_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::IdentContext* HplsqlParser::Cte_select_stmt_itemContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

tree::TerminalNode* HplsqlParser::Cte_select_stmt_itemContext::T_AS() {
  return getToken(HplsqlParser::T_AS, 0);
}

tree::TerminalNode* HplsqlParser::Cte_select_stmt_itemContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

HplsqlParser::Fullselect_stmtContext* HplsqlParser::Cte_select_stmt_itemContext::fullselect_stmt() {
  return getRuleContext<HplsqlParser::Fullselect_stmtContext>(0);
}

tree::TerminalNode* HplsqlParser::Cte_select_stmt_itemContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

HplsqlParser::Cte_select_colsContext* HplsqlParser::Cte_select_stmt_itemContext::cte_select_cols() {
  return getRuleContext<HplsqlParser::Cte_select_colsContext>(0);
}


size_t HplsqlParser::Cte_select_stmt_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleCte_select_stmt_item;
}

void HplsqlParser::Cte_select_stmt_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCte_select_stmt_item(this);
}

void HplsqlParser::Cte_select_stmt_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCte_select_stmt_item(this);
}


antlrcpp::Any HplsqlParser::Cte_select_stmt_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCte_select_stmt_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Cte_select_stmt_itemContext* HplsqlParser::cte_select_stmt_item() {
  Cte_select_stmt_itemContext *_localctx = _tracker.createInstance<Cte_select_stmt_itemContext>(_ctx, getState());
  enterRule(_localctx, 282, HplsqlParser::RuleCte_select_stmt_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2190);
    ident();
    setState(2192);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_OPEN_P) {
      setState(2191);
      cte_select_cols();
    }
    setState(2194);
    match(HplsqlParser::T_AS);
    setState(2195);
    match(HplsqlParser::T_OPEN_P);
    setState(2196);
    fullselect_stmt();
    setState(2197);
    match(HplsqlParser::T_CLOSE_P);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cte_select_colsContext ------------------------------------------------------------------

HplsqlParser::Cte_select_colsContext::Cte_select_colsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Cte_select_colsContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

std::vector<HplsqlParser::IdentContext *> HplsqlParser::Cte_select_colsContext::ident() {
  return getRuleContexts<HplsqlParser::IdentContext>();
}

HplsqlParser::IdentContext* HplsqlParser::Cte_select_colsContext::ident(size_t i) {
  return getRuleContext<HplsqlParser::IdentContext>(i);
}

tree::TerminalNode* HplsqlParser::Cte_select_colsContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Cte_select_colsContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Cte_select_colsContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Cte_select_colsContext::getRuleIndex() const {
  return HplsqlParser::RuleCte_select_cols;
}

void HplsqlParser::Cte_select_colsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCte_select_cols(this);
}

void HplsqlParser::Cte_select_colsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCte_select_cols(this);
}


antlrcpp::Any HplsqlParser::Cte_select_colsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitCte_select_cols(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Cte_select_colsContext* HplsqlParser::cte_select_cols() {
  Cte_select_colsContext *_localctx = _tracker.createInstance<Cte_select_colsContext>(_ctx, getState());
  enterRule(_localctx, 284, HplsqlParser::RuleCte_select_cols);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2199);
    match(HplsqlParser::T_OPEN_P);
    setState(2200);
    ident();
    setState(2205);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HplsqlParser::T_COMMA) {
      setState(2201);
      match(HplsqlParser::T_COMMA);
      setState(2202);
      ident();
      setState(2207);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2208);
    match(HplsqlParser::T_CLOSE_P);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fullselect_stmtContext ------------------------------------------------------------------

HplsqlParser::Fullselect_stmtContext::Fullselect_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HplsqlParser::Fullselect_stmt_itemContext *> HplsqlParser::Fullselect_stmtContext::fullselect_stmt_item() {
  return getRuleContexts<HplsqlParser::Fullselect_stmt_itemContext>();
}

HplsqlParser::Fullselect_stmt_itemContext* HplsqlParser::Fullselect_stmtContext::fullselect_stmt_item(size_t i) {
  return getRuleContext<HplsqlParser::Fullselect_stmt_itemContext>(i);
}

std::vector<HplsqlParser::Fullselect_set_clauseContext *> HplsqlParser::Fullselect_stmtContext::fullselect_set_clause() {
  return getRuleContexts<HplsqlParser::Fullselect_set_clauseContext>();
}

HplsqlParser::Fullselect_set_clauseContext* HplsqlParser::Fullselect_stmtContext::fullselect_set_clause(size_t i) {
  return getRuleContext<HplsqlParser::Fullselect_set_clauseContext>(i);
}


size_t HplsqlParser::Fullselect_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleFullselect_stmt;
}

void HplsqlParser::Fullselect_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFullselect_stmt(this);
}

void HplsqlParser::Fullselect_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFullselect_stmt(this);
}


antlrcpp::Any HplsqlParser::Fullselect_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitFullselect_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Fullselect_stmtContext* HplsqlParser::fullselect_stmt() {
  Fullselect_stmtContext *_localctx = _tracker.createInstance<Fullselect_stmtContext>(_ctx, getState());
  enterRule(_localctx, 286, HplsqlParser::RuleFullselect_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2210);
    fullselect_stmt_item();
    setState(2216);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 258, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2211);
        fullselect_set_clause();
        setState(2212);
        fullselect_stmt_item(); 
      }
      setState(2218);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 258, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fullselect_stmt_itemContext ------------------------------------------------------------------

HplsqlParser::Fullselect_stmt_itemContext::Fullselect_stmt_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Subselect_stmtContext* HplsqlParser::Fullselect_stmt_itemContext::subselect_stmt() {
  return getRuleContext<HplsqlParser::Subselect_stmtContext>(0);
}

tree::TerminalNode* HplsqlParser::Fullselect_stmt_itemContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

HplsqlParser::Fullselect_stmtContext* HplsqlParser::Fullselect_stmt_itemContext::fullselect_stmt() {
  return getRuleContext<HplsqlParser::Fullselect_stmtContext>(0);
}

tree::TerminalNode* HplsqlParser::Fullselect_stmt_itemContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}


size_t HplsqlParser::Fullselect_stmt_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleFullselect_stmt_item;
}

void HplsqlParser::Fullselect_stmt_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFullselect_stmt_item(this);
}

void HplsqlParser::Fullselect_stmt_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFullselect_stmt_item(this);
}


antlrcpp::Any HplsqlParser::Fullselect_stmt_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitFullselect_stmt_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Fullselect_stmt_itemContext* HplsqlParser::fullselect_stmt_item() {
  Fullselect_stmt_itemContext *_localctx = _tracker.createInstance<Fullselect_stmt_itemContext>(_ctx, getState());
  enterRule(_localctx, 288, HplsqlParser::RuleFullselect_stmt_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2224);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_SEL:
      case HplsqlParser::T_SELECT: {
        enterOuterAlt(_localctx, 1);
        setState(2219);
        subselect_stmt();
        break;
      }

      case HplsqlParser::T_OPEN_P: {
        enterOuterAlt(_localctx, 2);
        setState(2220);
        match(HplsqlParser::T_OPEN_P);
        setState(2221);
        fullselect_stmt();
        setState(2222);
        match(HplsqlParser::T_CLOSE_P);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fullselect_set_clauseContext ------------------------------------------------------------------

HplsqlParser::Fullselect_set_clauseContext::Fullselect_set_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Fullselect_set_clauseContext::T_UNION() {
  return getToken(HplsqlParser::T_UNION, 0);
}

tree::TerminalNode* HplsqlParser::Fullselect_set_clauseContext::T_ALL() {
  return getToken(HplsqlParser::T_ALL, 0);
}

tree::TerminalNode* HplsqlParser::Fullselect_set_clauseContext::T_EXCEPT() {
  return getToken(HplsqlParser::T_EXCEPT, 0);
}

tree::TerminalNode* HplsqlParser::Fullselect_set_clauseContext::T_INTERSECT() {
  return getToken(HplsqlParser::T_INTERSECT, 0);
}


size_t HplsqlParser::Fullselect_set_clauseContext::getRuleIndex() const {
  return HplsqlParser::RuleFullselect_set_clause;
}

void HplsqlParser::Fullselect_set_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFullselect_set_clause(this);
}

void HplsqlParser::Fullselect_set_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFullselect_set_clause(this);
}


antlrcpp::Any HplsqlParser::Fullselect_set_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitFullselect_set_clause(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Fullselect_set_clauseContext* HplsqlParser::fullselect_set_clause() {
  Fullselect_set_clauseContext *_localctx = _tracker.createInstance<Fullselect_set_clauseContext>(_ctx, getState());
  enterRule(_localctx, 290, HplsqlParser::RuleFullselect_set_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2238);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_UNION: {
        enterOuterAlt(_localctx, 1);
        setState(2226);
        match(HplsqlParser::T_UNION);
        setState(2228);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_ALL) {
          setState(2227);
          match(HplsqlParser::T_ALL);
        }
        break;
      }

      case HplsqlParser::T_EXCEPT: {
        enterOuterAlt(_localctx, 2);
        setState(2230);
        match(HplsqlParser::T_EXCEPT);
        setState(2232);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_ALL) {
          setState(2231);
          match(HplsqlParser::T_ALL);
        }
        break;
      }

      case HplsqlParser::T_INTERSECT: {
        enterOuterAlt(_localctx, 3);
        setState(2234);
        match(HplsqlParser::T_INTERSECT);
        setState(2236);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_ALL) {
          setState(2235);
          match(HplsqlParser::T_ALL);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Subselect_stmtContext ------------------------------------------------------------------

HplsqlParser::Subselect_stmtContext::Subselect_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Select_listContext* HplsqlParser::Subselect_stmtContext::select_list() {
  return getRuleContext<HplsqlParser::Select_listContext>(0);
}

tree::TerminalNode* HplsqlParser::Subselect_stmtContext::T_SELECT() {
  return getToken(HplsqlParser::T_SELECT, 0);
}

tree::TerminalNode* HplsqlParser::Subselect_stmtContext::T_SEL() {
  return getToken(HplsqlParser::T_SEL, 0);
}

HplsqlParser::Into_clauseContext* HplsqlParser::Subselect_stmtContext::into_clause() {
  return getRuleContext<HplsqlParser::Into_clauseContext>(0);
}

HplsqlParser::From_clauseContext* HplsqlParser::Subselect_stmtContext::from_clause() {
  return getRuleContext<HplsqlParser::From_clauseContext>(0);
}

HplsqlParser::Where_clauseContext* HplsqlParser::Subselect_stmtContext::where_clause() {
  return getRuleContext<HplsqlParser::Where_clauseContext>(0);
}

HplsqlParser::Group_by_clauseContext* HplsqlParser::Subselect_stmtContext::group_by_clause() {
  return getRuleContext<HplsqlParser::Group_by_clauseContext>(0);
}

HplsqlParser::Having_clauseContext* HplsqlParser::Subselect_stmtContext::having_clause() {
  return getRuleContext<HplsqlParser::Having_clauseContext>(0);
}

HplsqlParser::Qualify_clauseContext* HplsqlParser::Subselect_stmtContext::qualify_clause() {
  return getRuleContext<HplsqlParser::Qualify_clauseContext>(0);
}

HplsqlParser::Order_by_clauseContext* HplsqlParser::Subselect_stmtContext::order_by_clause() {
  return getRuleContext<HplsqlParser::Order_by_clauseContext>(0);
}

HplsqlParser::Select_optionsContext* HplsqlParser::Subselect_stmtContext::select_options() {
  return getRuleContext<HplsqlParser::Select_optionsContext>(0);
}


size_t HplsqlParser::Subselect_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleSubselect_stmt;
}

void HplsqlParser::Subselect_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubselect_stmt(this);
}

void HplsqlParser::Subselect_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubselect_stmt(this);
}


antlrcpp::Any HplsqlParser::Subselect_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitSubselect_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Subselect_stmtContext* HplsqlParser::subselect_stmt() {
  Subselect_stmtContext *_localctx = _tracker.createInstance<Subselect_stmtContext>(_ctx, getState());
  enterRule(_localctx, 292, HplsqlParser::RuleSubselect_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2240);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_SEL

    || _la == HplsqlParser::T_SELECT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2241);
    select_list();
    setState(2243);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 264, _ctx)) {
    case 1: {
      setState(2242);
      into_clause();
      break;
    }

    default:
      break;
    }
    setState(2246);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 265, _ctx)) {
    case 1: {
      setState(2245);
      from_clause();
      break;
    }

    default:
      break;
    }
    setState(2249);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 266, _ctx)) {
    case 1: {
      setState(2248);
      where_clause();
      break;
    }

    default:
      break;
    }
    setState(2252);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 267, _ctx)) {
    case 1: {
      setState(2251);
      group_by_clause();
      break;
    }

    default:
      break;
    }
    setState(2256);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 268, _ctx)) {
    case 1: {
      setState(2254);
      having_clause();
      break;
    }

    case 2: {
      setState(2255);
      qualify_clause();
      break;
    }

    default:
      break;
    }
    setState(2259);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 269, _ctx)) {
    case 1: {
      setState(2258);
      order_by_clause();
      break;
    }

    default:
      break;
    }
    setState(2262);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 270, _ctx)) {
    case 1: {
      setState(2261);
      select_options();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_listContext ------------------------------------------------------------------

HplsqlParser::Select_listContext::Select_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HplsqlParser::Select_list_itemContext *> HplsqlParser::Select_listContext::select_list_item() {
  return getRuleContexts<HplsqlParser::Select_list_itemContext>();
}

HplsqlParser::Select_list_itemContext* HplsqlParser::Select_listContext::select_list_item(size_t i) {
  return getRuleContext<HplsqlParser::Select_list_itemContext>(i);
}

HplsqlParser::Select_list_setContext* HplsqlParser::Select_listContext::select_list_set() {
  return getRuleContext<HplsqlParser::Select_list_setContext>(0);
}

HplsqlParser::Select_list_limitContext* HplsqlParser::Select_listContext::select_list_limit() {
  return getRuleContext<HplsqlParser::Select_list_limitContext>(0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Select_listContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Select_listContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Select_listContext::getRuleIndex() const {
  return HplsqlParser::RuleSelect_list;
}

void HplsqlParser::Select_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_list(this);
}

void HplsqlParser::Select_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_list(this);
}


antlrcpp::Any HplsqlParser::Select_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitSelect_list(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Select_listContext* HplsqlParser::select_list() {
  Select_listContext *_localctx = _tracker.createInstance<Select_listContext>(_ctx, getState());
  enterRule(_localctx, 294, HplsqlParser::RuleSelect_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2265);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 271, _ctx)) {
    case 1: {
      setState(2264);
      select_list_set();
      break;
    }

    default:
      break;
    }
    setState(2268);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 272, _ctx)) {
    case 1: {
      setState(2267);
      select_list_limit();
      break;
    }

    default:
      break;
    }
    setState(2270);
    select_list_item();
    setState(2275);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 273, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2271);
        match(HplsqlParser::T_COMMA);
        setState(2272);
        select_list_item(); 
      }
      setState(2277);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 273, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_list_setContext ------------------------------------------------------------------

HplsqlParser::Select_list_setContext::Select_list_setContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Select_list_setContext::T_ALL() {
  return getToken(HplsqlParser::T_ALL, 0);
}

tree::TerminalNode* HplsqlParser::Select_list_setContext::T_DISTINCT() {
  return getToken(HplsqlParser::T_DISTINCT, 0);
}


size_t HplsqlParser::Select_list_setContext::getRuleIndex() const {
  return HplsqlParser::RuleSelect_list_set;
}

void HplsqlParser::Select_list_setContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_list_set(this);
}

void HplsqlParser::Select_list_setContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_list_set(this);
}


antlrcpp::Any HplsqlParser::Select_list_setContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitSelect_list_set(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Select_list_setContext* HplsqlParser::select_list_set() {
  Select_list_setContext *_localctx = _tracker.createInstance<Select_list_setContext>(_ctx, getState());
  enterRule(_localctx, 296, HplsqlParser::RuleSelect_list_set);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2278);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_ALL || _la == HplsqlParser::T_DISTINCT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_list_limitContext ------------------------------------------------------------------

HplsqlParser::Select_list_limitContext::Select_list_limitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Select_list_limitContext::T_TOP() {
  return getToken(HplsqlParser::T_TOP, 0);
}

HplsqlParser::ExprContext* HplsqlParser::Select_list_limitContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}


size_t HplsqlParser::Select_list_limitContext::getRuleIndex() const {
  return HplsqlParser::RuleSelect_list_limit;
}

void HplsqlParser::Select_list_limitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_list_limit(this);
}

void HplsqlParser::Select_list_limitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_list_limit(this);
}


antlrcpp::Any HplsqlParser::Select_list_limitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitSelect_list_limit(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Select_list_limitContext* HplsqlParser::select_list_limit() {
  Select_list_limitContext *_localctx = _tracker.createInstance<Select_list_limitContext>(_ctx, getState());
  enterRule(_localctx, 298, HplsqlParser::RuleSelect_list_limit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2280);
    match(HplsqlParser::T_TOP);
    setState(2281);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_list_itemContext ------------------------------------------------------------------

HplsqlParser::Select_list_itemContext::Select_list_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::ExprContext* HplsqlParser::Select_list_itemContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}

HplsqlParser::Select_list_asteriskContext* HplsqlParser::Select_list_itemContext::select_list_asterisk() {
  return getRuleContext<HplsqlParser::Select_list_asteriskContext>(0);
}

HplsqlParser::IdentContext* HplsqlParser::Select_list_itemContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

tree::TerminalNode* HplsqlParser::Select_list_itemContext::T_EQUAL() {
  return getToken(HplsqlParser::T_EQUAL, 0);
}

HplsqlParser::Select_list_aliasContext* HplsqlParser::Select_list_itemContext::select_list_alias() {
  return getRuleContext<HplsqlParser::Select_list_aliasContext>(0);
}


size_t HplsqlParser::Select_list_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleSelect_list_item;
}

void HplsqlParser::Select_list_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_list_item(this);
}

void HplsqlParser::Select_list_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_list_item(this);
}


antlrcpp::Any HplsqlParser::Select_list_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitSelect_list_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Select_list_itemContext* HplsqlParser::select_list_item() {
  Select_list_itemContext *_localctx = _tracker.createInstance<Select_list_itemContext>(_ctx, getState());
  enterRule(_localctx, 300, HplsqlParser::RuleSelect_list_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2293);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 276, _ctx)) {
    case 1: {
      setState(2286);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 274, _ctx)) {
      case 1: {
        setState(2283);
        ident();
        setState(2284);
        match(HplsqlParser::T_EQUAL);
        break;
      }

      default:
        break;
      }
      setState(2288);
      expr(0);
      setState(2290);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 275, _ctx)) {
      case 1: {
        setState(2289);
        select_list_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      setState(2292);
      select_list_asterisk();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_list_aliasContext ------------------------------------------------------------------

HplsqlParser::Select_list_aliasContext::Select_list_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::IdentContext* HplsqlParser::Select_list_aliasContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

tree::TerminalNode* HplsqlParser::Select_list_aliasContext::T_AS() {
  return getToken(HplsqlParser::T_AS, 0);
}

tree::TerminalNode* HplsqlParser::Select_list_aliasContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

tree::TerminalNode* HplsqlParser::Select_list_aliasContext::T_TITLE() {
  return getToken(HplsqlParser::T_TITLE, 0);
}

tree::TerminalNode* HplsqlParser::Select_list_aliasContext::L_S_STRING() {
  return getToken(HplsqlParser::L_S_STRING, 0);
}

tree::TerminalNode* HplsqlParser::Select_list_aliasContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}


size_t HplsqlParser::Select_list_aliasContext::getRuleIndex() const {
  return HplsqlParser::RuleSelect_list_alias;
}

void HplsqlParser::Select_list_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_list_alias(this);
}

void HplsqlParser::Select_list_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_list_alias(this);
}


antlrcpp::Any HplsqlParser::Select_list_aliasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitSelect_list_alias(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Select_list_aliasContext* HplsqlParser::select_list_alias() {
  Select_list_aliasContext *_localctx = _tracker.createInstance<Select_list_aliasContext>(_ctx, getState());
  enterRule(_localctx, 302, HplsqlParser::RuleSelect_list_alias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2304);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 278, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2295);

      if (!(strcasecmp(_input->LT(1)->getText().data(), "INTO") && strcasecmp(_input->LT(1)->getText().data(), "FROM"))) throw FailedPredicateException(this, "strcasecmp(_input->LT(1)->getText().data(), \"INTO\") && strcasecmp(_input->LT(1)->getText().data(), \"FROM\")");
      setState(2297);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 277, _ctx)) {
      case 1: {
        setState(2296);
        match(HplsqlParser::T_AS);
        break;
      }

      default:
        break;
      }
      setState(2299);
      ident();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2300);
      match(HplsqlParser::T_OPEN_P);
      setState(2301);
      match(HplsqlParser::T_TITLE);
      setState(2302);
      match(HplsqlParser::L_S_STRING);
      setState(2303);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_list_asteriskContext ------------------------------------------------------------------

HplsqlParser::Select_list_asteriskContext::Select_list_asteriskContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Select_list_asteriskContext::T_MUL() {
  return getToken(HplsqlParser::T_MUL, 0);
}

tree::TerminalNode* HplsqlParser::Select_list_asteriskContext::L_ID() {
  return getToken(HplsqlParser::L_ID, 0);
}


size_t HplsqlParser::Select_list_asteriskContext::getRuleIndex() const {
  return HplsqlParser::RuleSelect_list_asterisk;
}

void HplsqlParser::Select_list_asteriskContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_list_asterisk(this);
}

void HplsqlParser::Select_list_asteriskContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_list_asterisk(this);
}


antlrcpp::Any HplsqlParser::Select_list_asteriskContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitSelect_list_asterisk(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Select_list_asteriskContext* HplsqlParser::select_list_asterisk() {
  Select_list_asteriskContext *_localctx = _tracker.createInstance<Select_list_asteriskContext>(_ctx, getState());
  enterRule(_localctx, 304, HplsqlParser::RuleSelect_list_asterisk);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2308);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::L_ID) {
      setState(2306);
      match(HplsqlParser::L_ID);
      setState(2307);
      match(HplsqlParser::T__3);
    }
    setState(2310);
    match(HplsqlParser::T_MUL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Into_clauseContext ------------------------------------------------------------------

HplsqlParser::Into_clauseContext::Into_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Into_clauseContext::T_INTO() {
  return getToken(HplsqlParser::T_INTO, 0);
}

std::vector<HplsqlParser::IdentContext *> HplsqlParser::Into_clauseContext::ident() {
  return getRuleContexts<HplsqlParser::IdentContext>();
}

HplsqlParser::IdentContext* HplsqlParser::Into_clauseContext::ident(size_t i) {
  return getRuleContext<HplsqlParser::IdentContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Into_clauseContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Into_clauseContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Into_clauseContext::getRuleIndex() const {
  return HplsqlParser::RuleInto_clause;
}

void HplsqlParser::Into_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInto_clause(this);
}

void HplsqlParser::Into_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInto_clause(this);
}


antlrcpp::Any HplsqlParser::Into_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitInto_clause(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Into_clauseContext* HplsqlParser::into_clause() {
  Into_clauseContext *_localctx = _tracker.createInstance<Into_clauseContext>(_ctx, getState());
  enterRule(_localctx, 306, HplsqlParser::RuleInto_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2312);
    match(HplsqlParser::T_INTO);
    setState(2313);
    ident();
    setState(2318);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 280, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2314);
        match(HplsqlParser::T_COMMA);
        setState(2315);
        ident(); 
      }
      setState(2320);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 280, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- From_clauseContext ------------------------------------------------------------------

HplsqlParser::From_clauseContext::From_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::From_clauseContext::T_FROM() {
  return getToken(HplsqlParser::T_FROM, 0);
}

HplsqlParser::From_table_clauseContext* HplsqlParser::From_clauseContext::from_table_clause() {
  return getRuleContext<HplsqlParser::From_table_clauseContext>(0);
}

std::vector<HplsqlParser::From_join_clauseContext *> HplsqlParser::From_clauseContext::from_join_clause() {
  return getRuleContexts<HplsqlParser::From_join_clauseContext>();
}

HplsqlParser::From_join_clauseContext* HplsqlParser::From_clauseContext::from_join_clause(size_t i) {
  return getRuleContext<HplsqlParser::From_join_clauseContext>(i);
}


size_t HplsqlParser::From_clauseContext::getRuleIndex() const {
  return HplsqlParser::RuleFrom_clause;
}

void HplsqlParser::From_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrom_clause(this);
}

void HplsqlParser::From_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrom_clause(this);
}


antlrcpp::Any HplsqlParser::From_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitFrom_clause(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::From_clauseContext* HplsqlParser::from_clause() {
  From_clauseContext *_localctx = _tracker.createInstance<From_clauseContext>(_ctx, getState());
  enterRule(_localctx, 308, HplsqlParser::RuleFrom_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2321);
    match(HplsqlParser::T_FROM);
    setState(2322);
    from_table_clause();
    setState(2326);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 281, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2323);
        from_join_clause(); 
      }
      setState(2328);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 281, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- From_table_clauseContext ------------------------------------------------------------------

HplsqlParser::From_table_clauseContext::From_table_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::From_table_name_clauseContext* HplsqlParser::From_table_clauseContext::from_table_name_clause() {
  return getRuleContext<HplsqlParser::From_table_name_clauseContext>(0);
}

HplsqlParser::From_subselect_clauseContext* HplsqlParser::From_table_clauseContext::from_subselect_clause() {
  return getRuleContext<HplsqlParser::From_subselect_clauseContext>(0);
}

HplsqlParser::From_table_values_clauseContext* HplsqlParser::From_table_clauseContext::from_table_values_clause() {
  return getRuleContext<HplsqlParser::From_table_values_clauseContext>(0);
}


size_t HplsqlParser::From_table_clauseContext::getRuleIndex() const {
  return HplsqlParser::RuleFrom_table_clause;
}

void HplsqlParser::From_table_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrom_table_clause(this);
}

void HplsqlParser::From_table_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrom_table_clause(this);
}


antlrcpp::Any HplsqlParser::From_table_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitFrom_table_clause(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::From_table_clauseContext* HplsqlParser::from_table_clause() {
  From_table_clauseContext *_localctx = _tracker.createInstance<From_table_clauseContext>(_ctx, getState());
  enterRule(_localctx, 310, HplsqlParser::RuleFrom_table_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2332);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 282, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2329);
      from_table_name_clause();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2330);
      from_subselect_clause();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2331);
      from_table_values_clause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- From_table_name_clauseContext ------------------------------------------------------------------

HplsqlParser::From_table_name_clauseContext::From_table_name_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Table_nameContext* HplsqlParser::From_table_name_clauseContext::table_name() {
  return getRuleContext<HplsqlParser::Table_nameContext>(0);
}

HplsqlParser::From_alias_clauseContext* HplsqlParser::From_table_name_clauseContext::from_alias_clause() {
  return getRuleContext<HplsqlParser::From_alias_clauseContext>(0);
}


size_t HplsqlParser::From_table_name_clauseContext::getRuleIndex() const {
  return HplsqlParser::RuleFrom_table_name_clause;
}

void HplsqlParser::From_table_name_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrom_table_name_clause(this);
}

void HplsqlParser::From_table_name_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrom_table_name_clause(this);
}


antlrcpp::Any HplsqlParser::From_table_name_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitFrom_table_name_clause(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::From_table_name_clauseContext* HplsqlParser::from_table_name_clause() {
  From_table_name_clauseContext *_localctx = _tracker.createInstance<From_table_name_clauseContext>(_ctx, getState());
  enterRule(_localctx, 312, HplsqlParser::RuleFrom_table_name_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2334);
    table_name();
    setState(2336);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 283, _ctx)) {
    case 1: {
      setState(2335);
      from_alias_clause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- From_subselect_clauseContext ------------------------------------------------------------------

HplsqlParser::From_subselect_clauseContext::From_subselect_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::From_subselect_clauseContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

HplsqlParser::Select_stmtContext* HplsqlParser::From_subselect_clauseContext::select_stmt() {
  return getRuleContext<HplsqlParser::Select_stmtContext>(0);
}

tree::TerminalNode* HplsqlParser::From_subselect_clauseContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

HplsqlParser::From_alias_clauseContext* HplsqlParser::From_subselect_clauseContext::from_alias_clause() {
  return getRuleContext<HplsqlParser::From_alias_clauseContext>(0);
}


size_t HplsqlParser::From_subselect_clauseContext::getRuleIndex() const {
  return HplsqlParser::RuleFrom_subselect_clause;
}

void HplsqlParser::From_subselect_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrom_subselect_clause(this);
}

void HplsqlParser::From_subselect_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrom_subselect_clause(this);
}


antlrcpp::Any HplsqlParser::From_subselect_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitFrom_subselect_clause(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::From_subselect_clauseContext* HplsqlParser::from_subselect_clause() {
  From_subselect_clauseContext *_localctx = _tracker.createInstance<From_subselect_clauseContext>(_ctx, getState());
  enterRule(_localctx, 314, HplsqlParser::RuleFrom_subselect_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2338);
    match(HplsqlParser::T_OPEN_P);
    setState(2339);
    select_stmt();
    setState(2340);
    match(HplsqlParser::T_CLOSE_P);
    setState(2342);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 284, _ctx)) {
    case 1: {
      setState(2341);
      from_alias_clause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- From_join_clauseContext ------------------------------------------------------------------

HplsqlParser::From_join_clauseContext::From_join_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::From_join_clauseContext::T_COMMA() {
  return getToken(HplsqlParser::T_COMMA, 0);
}

HplsqlParser::From_table_clauseContext* HplsqlParser::From_join_clauseContext::from_table_clause() {
  return getRuleContext<HplsqlParser::From_table_clauseContext>(0);
}

HplsqlParser::From_join_type_clauseContext* HplsqlParser::From_join_clauseContext::from_join_type_clause() {
  return getRuleContext<HplsqlParser::From_join_type_clauseContext>(0);
}

tree::TerminalNode* HplsqlParser::From_join_clauseContext::T_ON() {
  return getToken(HplsqlParser::T_ON, 0);
}

HplsqlParser::Bool_exprContext* HplsqlParser::From_join_clauseContext::bool_expr() {
  return getRuleContext<HplsqlParser::Bool_exprContext>(0);
}


size_t HplsqlParser::From_join_clauseContext::getRuleIndex() const {
  return HplsqlParser::RuleFrom_join_clause;
}

void HplsqlParser::From_join_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrom_join_clause(this);
}

void HplsqlParser::From_join_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrom_join_clause(this);
}


antlrcpp::Any HplsqlParser::From_join_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitFrom_join_clause(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::From_join_clauseContext* HplsqlParser::from_join_clause() {
  From_join_clauseContext *_localctx = _tracker.createInstance<From_join_clauseContext>(_ctx, getState());
  enterRule(_localctx, 316, HplsqlParser::RuleFrom_join_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2351);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_COMMA: {
        enterOuterAlt(_localctx, 1);
        setState(2344);
        match(HplsqlParser::T_COMMA);
        setState(2345);
        from_table_clause();
        break;
      }

      case HplsqlParser::T_FULL:
      case HplsqlParser::T_INNER:
      case HplsqlParser::T_JOIN:
      case HplsqlParser::T_LEFT:
      case HplsqlParser::T_RIGHT: {
        enterOuterAlt(_localctx, 2);
        setState(2346);
        from_join_type_clause();
        setState(2347);
        from_table_clause();
        setState(2348);
        match(HplsqlParser::T_ON);
        setState(2349);
        bool_expr(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- From_join_type_clauseContext ------------------------------------------------------------------

HplsqlParser::From_join_type_clauseContext::From_join_type_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::From_join_type_clauseContext::T_JOIN() {
  return getToken(HplsqlParser::T_JOIN, 0);
}

tree::TerminalNode* HplsqlParser::From_join_type_clauseContext::T_INNER() {
  return getToken(HplsqlParser::T_INNER, 0);
}

tree::TerminalNode* HplsqlParser::From_join_type_clauseContext::T_LEFT() {
  return getToken(HplsqlParser::T_LEFT, 0);
}

tree::TerminalNode* HplsqlParser::From_join_type_clauseContext::T_RIGHT() {
  return getToken(HplsqlParser::T_RIGHT, 0);
}

tree::TerminalNode* HplsqlParser::From_join_type_clauseContext::T_FULL() {
  return getToken(HplsqlParser::T_FULL, 0);
}

tree::TerminalNode* HplsqlParser::From_join_type_clauseContext::T_OUTER() {
  return getToken(HplsqlParser::T_OUTER, 0);
}


size_t HplsqlParser::From_join_type_clauseContext::getRuleIndex() const {
  return HplsqlParser::RuleFrom_join_type_clause;
}

void HplsqlParser::From_join_type_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrom_join_type_clause(this);
}

void HplsqlParser::From_join_type_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrom_join_type_clause(this);
}


antlrcpp::Any HplsqlParser::From_join_type_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitFrom_join_type_clause(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::From_join_type_clauseContext* HplsqlParser::from_join_type_clause() {
  From_join_type_clauseContext *_localctx = _tracker.createInstance<From_join_type_clauseContext>(_ctx, getState());
  enterRule(_localctx, 318, HplsqlParser::RuleFrom_join_type_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2362);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_INNER:
      case HplsqlParser::T_JOIN: {
        enterOuterAlt(_localctx, 1);
        setState(2354);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_INNER) {
          setState(2353);
          match(HplsqlParser::T_INNER);
        }
        setState(2356);
        match(HplsqlParser::T_JOIN);
        break;
      }

      case HplsqlParser::T_FULL:
      case HplsqlParser::T_LEFT:
      case HplsqlParser::T_RIGHT: {
        enterOuterAlt(_localctx, 2);
        setState(2357);
        _la = _input->LA(1);
        if (!(_la == HplsqlParser::T_FULL

        || _la == HplsqlParser::T_LEFT || _la == HplsqlParser::T_RIGHT)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2359);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_OUTER) {
          setState(2358);
          match(HplsqlParser::T_OUTER);
        }
        setState(2361);
        match(HplsqlParser::T_JOIN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- From_table_values_clauseContext ------------------------------------------------------------------

HplsqlParser::From_table_values_clauseContext::From_table_values_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::From_table_values_clauseContext::T_TABLE() {
  return getToken(HplsqlParser::T_TABLE, 0);
}

tree::TerminalNode* HplsqlParser::From_table_values_clauseContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

tree::TerminalNode* HplsqlParser::From_table_values_clauseContext::T_VALUES() {
  return getToken(HplsqlParser::T_VALUES, 0);
}

std::vector<HplsqlParser::From_table_values_rowContext *> HplsqlParser::From_table_values_clauseContext::from_table_values_row() {
  return getRuleContexts<HplsqlParser::From_table_values_rowContext>();
}

HplsqlParser::From_table_values_rowContext* HplsqlParser::From_table_values_clauseContext::from_table_values_row(size_t i) {
  return getRuleContext<HplsqlParser::From_table_values_rowContext>(i);
}

tree::TerminalNode* HplsqlParser::From_table_values_clauseContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::From_table_values_clauseContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::From_table_values_clauseContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}

HplsqlParser::From_alias_clauseContext* HplsqlParser::From_table_values_clauseContext::from_alias_clause() {
  return getRuleContext<HplsqlParser::From_alias_clauseContext>(0);
}


size_t HplsqlParser::From_table_values_clauseContext::getRuleIndex() const {
  return HplsqlParser::RuleFrom_table_values_clause;
}

void HplsqlParser::From_table_values_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrom_table_values_clause(this);
}

void HplsqlParser::From_table_values_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrom_table_values_clause(this);
}


antlrcpp::Any HplsqlParser::From_table_values_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitFrom_table_values_clause(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::From_table_values_clauseContext* HplsqlParser::from_table_values_clause() {
  From_table_values_clauseContext *_localctx = _tracker.createInstance<From_table_values_clauseContext>(_ctx, getState());
  enterRule(_localctx, 320, HplsqlParser::RuleFrom_table_values_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2364);
    match(HplsqlParser::T_TABLE);
    setState(2365);
    match(HplsqlParser::T_OPEN_P);
    setState(2366);
    match(HplsqlParser::T_VALUES);
    setState(2367);
    from_table_values_row();
    setState(2372);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HplsqlParser::T_COMMA) {
      setState(2368);
      match(HplsqlParser::T_COMMA);
      setState(2369);
      from_table_values_row();
      setState(2374);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2375);
    match(HplsqlParser::T_CLOSE_P);
    setState(2377);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 290, _ctx)) {
    case 1: {
      setState(2376);
      from_alias_clause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- From_table_values_rowContext ------------------------------------------------------------------

HplsqlParser::From_table_values_rowContext::From_table_values_rowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HplsqlParser::ExprContext *> HplsqlParser::From_table_values_rowContext::expr() {
  return getRuleContexts<HplsqlParser::ExprContext>();
}

HplsqlParser::ExprContext* HplsqlParser::From_table_values_rowContext::expr(size_t i) {
  return getRuleContext<HplsqlParser::ExprContext>(i);
}

tree::TerminalNode* HplsqlParser::From_table_values_rowContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

tree::TerminalNode* HplsqlParser::From_table_values_rowContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::From_table_values_rowContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::From_table_values_rowContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::From_table_values_rowContext::getRuleIndex() const {
  return HplsqlParser::RuleFrom_table_values_row;
}

void HplsqlParser::From_table_values_rowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrom_table_values_row(this);
}

void HplsqlParser::From_table_values_rowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrom_table_values_row(this);
}


antlrcpp::Any HplsqlParser::From_table_values_rowContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitFrom_table_values_row(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::From_table_values_rowContext* HplsqlParser::from_table_values_row() {
  From_table_values_rowContext *_localctx = _tracker.createInstance<From_table_values_rowContext>(_ctx, getState());
  enterRule(_localctx, 322, HplsqlParser::RuleFrom_table_values_row);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2391);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 292, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2379);
      expr(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2380);
      match(HplsqlParser::T_OPEN_P);
      setState(2381);
      expr(0);
      setState(2386);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == HplsqlParser::T_COMMA) {
        setState(2382);
        match(HplsqlParser::T_COMMA);
        setState(2383);
        expr(0);
        setState(2388);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2389);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- From_alias_clauseContext ------------------------------------------------------------------

HplsqlParser::From_alias_clauseContext::From_alias_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::IdentContext* HplsqlParser::From_alias_clauseContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

tree::TerminalNode* HplsqlParser::From_alias_clauseContext::T_AS() {
  return getToken(HplsqlParser::T_AS, 0);
}

tree::TerminalNode* HplsqlParser::From_alias_clauseContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::From_alias_clauseContext::L_ID() {
  return getTokens(HplsqlParser::L_ID);
}

tree::TerminalNode* HplsqlParser::From_alias_clauseContext::L_ID(size_t i) {
  return getToken(HplsqlParser::L_ID, i);
}

tree::TerminalNode* HplsqlParser::From_alias_clauseContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::From_alias_clauseContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::From_alias_clauseContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::From_alias_clauseContext::getRuleIndex() const {
  return HplsqlParser::RuleFrom_alias_clause;
}

void HplsqlParser::From_alias_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrom_alias_clause(this);
}

void HplsqlParser::From_alias_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrom_alias_clause(this);
}


antlrcpp::Any HplsqlParser::From_alias_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitFrom_alias_clause(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::From_alias_clauseContext* HplsqlParser::from_alias_clause() {
  From_alias_clauseContext *_localctx = _tracker.createInstance<From_alias_clauseContext>(_ctx, getState());
  enterRule(_localctx, 324, HplsqlParser::RuleFrom_alias_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2393);

    if (!(strcasecmp(_input->LT(1)->getText().data(), "EXEC") &&
            strcasecmp(_input->LT(1)->getText().data(), "EXECUTE") && 
            strcasecmp(_input->LT(1)->getText().data(), "INNER") &&
            strcasecmp(_input->LT(1)->getText().data(), "LEFT") &&
            strcasecmp(_input->LT(1)->getText().data(), "GROUP") &&
            strcasecmp(_input->LT(1)->getText().data(), "ORDER") &&
            strcasecmp(_input->LT(1)->getText().data(), "LIMIT") &&
            strcasecmp(_input->LT(1)->getText().data(), "WITH"))) throw FailedPredicateException(this, "strcasecmp(_input->LT(1)->getText().data(), \"EXEC\") &&\n        strcasecmp(_input->LT(1)->getText().data(), \"EXECUTE\") && \n        strcasecmp(_input->LT(1)->getText().data(), \"INNER\") &&\n        strcasecmp(_input->LT(1)->getText().data(), \"LEFT\") &&\n        strcasecmp(_input->LT(1)->getText().data(), \"GROUP\") &&\n        strcasecmp(_input->LT(1)->getText().data(), \"ORDER\") &&\n        strcasecmp(_input->LT(1)->getText().data(), \"LIMIT\") &&\n        strcasecmp(_input->LT(1)->getText().data(), \"WITH\")");
    setState(2395);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 293, _ctx)) {
    case 1: {
      setState(2394);
      match(HplsqlParser::T_AS);
      break;
    }

    default:
      break;
    }
    setState(2397);
    ident();
    setState(2408);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 295, _ctx)) {
    case 1: {
      setState(2398);
      match(HplsqlParser::T_OPEN_P);
      setState(2399);
      match(HplsqlParser::L_ID);
      setState(2404);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == HplsqlParser::T_COMMA) {
        setState(2400);
        match(HplsqlParser::T_COMMA);
        setState(2401);
        match(HplsqlParser::L_ID);
        setState(2406);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2407);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_nameContext ------------------------------------------------------------------

HplsqlParser::Table_nameContext::Table_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::IdentContext* HplsqlParser::Table_nameContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}


size_t HplsqlParser::Table_nameContext::getRuleIndex() const {
  return HplsqlParser::RuleTable_name;
}

void HplsqlParser::Table_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_name(this);
}

void HplsqlParser::Table_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_name(this);
}


antlrcpp::Any HplsqlParser::Table_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitTable_name(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Table_nameContext* HplsqlParser::table_name() {
  Table_nameContext *_localctx = _tracker.createInstance<Table_nameContext>(_ctx, getState());
  enterRule(_localctx, 326, HplsqlParser::RuleTable_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2410);
    ident();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Where_clauseContext ------------------------------------------------------------------

HplsqlParser::Where_clauseContext::Where_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Where_clauseContext::T_WHERE() {
  return getToken(HplsqlParser::T_WHERE, 0);
}

HplsqlParser::Bool_exprContext* HplsqlParser::Where_clauseContext::bool_expr() {
  return getRuleContext<HplsqlParser::Bool_exprContext>(0);
}


size_t HplsqlParser::Where_clauseContext::getRuleIndex() const {
  return HplsqlParser::RuleWhere_clause;
}

void HplsqlParser::Where_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhere_clause(this);
}

void HplsqlParser::Where_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhere_clause(this);
}


antlrcpp::Any HplsqlParser::Where_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitWhere_clause(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Where_clauseContext* HplsqlParser::where_clause() {
  Where_clauseContext *_localctx = _tracker.createInstance<Where_clauseContext>(_ctx, getState());
  enterRule(_localctx, 328, HplsqlParser::RuleWhere_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2412);
    match(HplsqlParser::T_WHERE);
    setState(2413);
    bool_expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Group_by_clauseContext ------------------------------------------------------------------

HplsqlParser::Group_by_clauseContext::Group_by_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Group_by_clauseContext::T_GROUP() {
  return getToken(HplsqlParser::T_GROUP, 0);
}

tree::TerminalNode* HplsqlParser::Group_by_clauseContext::T_BY() {
  return getToken(HplsqlParser::T_BY, 0);
}

std::vector<HplsqlParser::ExprContext *> HplsqlParser::Group_by_clauseContext::expr() {
  return getRuleContexts<HplsqlParser::ExprContext>();
}

HplsqlParser::ExprContext* HplsqlParser::Group_by_clauseContext::expr(size_t i) {
  return getRuleContext<HplsqlParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Group_by_clauseContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Group_by_clauseContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Group_by_clauseContext::getRuleIndex() const {
  return HplsqlParser::RuleGroup_by_clause;
}

void HplsqlParser::Group_by_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroup_by_clause(this);
}

void HplsqlParser::Group_by_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroup_by_clause(this);
}


antlrcpp::Any HplsqlParser::Group_by_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitGroup_by_clause(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Group_by_clauseContext* HplsqlParser::group_by_clause() {
  Group_by_clauseContext *_localctx = _tracker.createInstance<Group_by_clauseContext>(_ctx, getState());
  enterRule(_localctx, 330, HplsqlParser::RuleGroup_by_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2415);
    match(HplsqlParser::T_GROUP);
    setState(2416);
    match(HplsqlParser::T_BY);
    setState(2417);
    expr(0);
    setState(2422);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 296, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2418);
        match(HplsqlParser::T_COMMA);
        setState(2419);
        expr(0); 
      }
      setState(2424);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 296, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Having_clauseContext ------------------------------------------------------------------

HplsqlParser::Having_clauseContext::Having_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Having_clauseContext::T_HAVING() {
  return getToken(HplsqlParser::T_HAVING, 0);
}

HplsqlParser::Bool_exprContext* HplsqlParser::Having_clauseContext::bool_expr() {
  return getRuleContext<HplsqlParser::Bool_exprContext>(0);
}


size_t HplsqlParser::Having_clauseContext::getRuleIndex() const {
  return HplsqlParser::RuleHaving_clause;
}

void HplsqlParser::Having_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHaving_clause(this);
}

void HplsqlParser::Having_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHaving_clause(this);
}


antlrcpp::Any HplsqlParser::Having_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitHaving_clause(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Having_clauseContext* HplsqlParser::having_clause() {
  Having_clauseContext *_localctx = _tracker.createInstance<Having_clauseContext>(_ctx, getState());
  enterRule(_localctx, 332, HplsqlParser::RuleHaving_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2425);
    match(HplsqlParser::T_HAVING);
    setState(2426);
    bool_expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Qualify_clauseContext ------------------------------------------------------------------

HplsqlParser::Qualify_clauseContext::Qualify_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Qualify_clauseContext::T_QUALIFY() {
  return getToken(HplsqlParser::T_QUALIFY, 0);
}

HplsqlParser::Bool_exprContext* HplsqlParser::Qualify_clauseContext::bool_expr() {
  return getRuleContext<HplsqlParser::Bool_exprContext>(0);
}


size_t HplsqlParser::Qualify_clauseContext::getRuleIndex() const {
  return HplsqlParser::RuleQualify_clause;
}

void HplsqlParser::Qualify_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualify_clause(this);
}

void HplsqlParser::Qualify_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualify_clause(this);
}


antlrcpp::Any HplsqlParser::Qualify_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitQualify_clause(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Qualify_clauseContext* HplsqlParser::qualify_clause() {
  Qualify_clauseContext *_localctx = _tracker.createInstance<Qualify_clauseContext>(_ctx, getState());
  enterRule(_localctx, 334, HplsqlParser::RuleQualify_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2428);
    match(HplsqlParser::T_QUALIFY);
    setState(2429);
    bool_expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Order_by_clauseContext ------------------------------------------------------------------

HplsqlParser::Order_by_clauseContext::Order_by_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Order_by_clauseContext::T_ORDER() {
  return getToken(HplsqlParser::T_ORDER, 0);
}

tree::TerminalNode* HplsqlParser::Order_by_clauseContext::T_BY() {
  return getToken(HplsqlParser::T_BY, 0);
}

std::vector<HplsqlParser::ExprContext *> HplsqlParser::Order_by_clauseContext::expr() {
  return getRuleContexts<HplsqlParser::ExprContext>();
}

HplsqlParser::ExprContext* HplsqlParser::Order_by_clauseContext::expr(size_t i) {
  return getRuleContext<HplsqlParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Order_by_clauseContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Order_by_clauseContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Order_by_clauseContext::T_ASC() {
  return getTokens(HplsqlParser::T_ASC);
}

tree::TerminalNode* HplsqlParser::Order_by_clauseContext::T_ASC(size_t i) {
  return getToken(HplsqlParser::T_ASC, i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Order_by_clauseContext::T_DESC() {
  return getTokens(HplsqlParser::T_DESC);
}

tree::TerminalNode* HplsqlParser::Order_by_clauseContext::T_DESC(size_t i) {
  return getToken(HplsqlParser::T_DESC, i);
}


size_t HplsqlParser::Order_by_clauseContext::getRuleIndex() const {
  return HplsqlParser::RuleOrder_by_clause;
}

void HplsqlParser::Order_by_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrder_by_clause(this);
}

void HplsqlParser::Order_by_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrder_by_clause(this);
}


antlrcpp::Any HplsqlParser::Order_by_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitOrder_by_clause(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Order_by_clauseContext* HplsqlParser::order_by_clause() {
  Order_by_clauseContext *_localctx = _tracker.createInstance<Order_by_clauseContext>(_ctx, getState());
  enterRule(_localctx, 336, HplsqlParser::RuleOrder_by_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2431);
    match(HplsqlParser::T_ORDER);
    setState(2432);
    match(HplsqlParser::T_BY);
    setState(2433);
    expr(0);
    setState(2435);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 297, _ctx)) {
    case 1: {
      setState(2434);
      _la = _input->LA(1);
      if (!(_la == HplsqlParser::T_ASC || _la == HplsqlParser::T_DESC)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
    setState(2444);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 299, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2437);
        match(HplsqlParser::T_COMMA);
        setState(2438);
        expr(0);
        setState(2440);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 298, _ctx)) {
        case 1: {
          setState(2439);
          _la = _input->LA(1);
          if (!(_la == HplsqlParser::T_ASC || _la == HplsqlParser::T_DESC)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        default:
          break;
        } 
      }
      setState(2446);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 299, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_optionsContext ------------------------------------------------------------------

HplsqlParser::Select_optionsContext::Select_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HplsqlParser::Select_options_itemContext *> HplsqlParser::Select_optionsContext::select_options_item() {
  return getRuleContexts<HplsqlParser::Select_options_itemContext>();
}

HplsqlParser::Select_options_itemContext* HplsqlParser::Select_optionsContext::select_options_item(size_t i) {
  return getRuleContext<HplsqlParser::Select_options_itemContext>(i);
}


size_t HplsqlParser::Select_optionsContext::getRuleIndex() const {
  return HplsqlParser::RuleSelect_options;
}

void HplsqlParser::Select_optionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_options(this);
}

void HplsqlParser::Select_optionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_options(this);
}


antlrcpp::Any HplsqlParser::Select_optionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitSelect_options(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Select_optionsContext* HplsqlParser::select_options() {
  Select_optionsContext *_localctx = _tracker.createInstance<Select_optionsContext>(_ctx, getState());
  enterRule(_localctx, 338, HplsqlParser::RuleSelect_options);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2448); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(2447);
              select_options_item();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(2450); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 300, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_options_itemContext ------------------------------------------------------------------

HplsqlParser::Select_options_itemContext::Select_options_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Select_options_itemContext::T_LIMIT() {
  return getToken(HplsqlParser::T_LIMIT, 0);
}

HplsqlParser::ExprContext* HplsqlParser::Select_options_itemContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}

tree::TerminalNode* HplsqlParser::Select_options_itemContext::T_WITH() {
  return getToken(HplsqlParser::T_WITH, 0);
}

tree::TerminalNode* HplsqlParser::Select_options_itemContext::T_RR() {
  return getToken(HplsqlParser::T_RR, 0);
}

tree::TerminalNode* HplsqlParser::Select_options_itemContext::T_RS() {
  return getToken(HplsqlParser::T_RS, 0);
}

tree::TerminalNode* HplsqlParser::Select_options_itemContext::T_CS() {
  return getToken(HplsqlParser::T_CS, 0);
}

tree::TerminalNode* HplsqlParser::Select_options_itemContext::T_UR() {
  return getToken(HplsqlParser::T_UR, 0);
}

tree::TerminalNode* HplsqlParser::Select_options_itemContext::T_USE() {
  return getToken(HplsqlParser::T_USE, 0);
}

tree::TerminalNode* HplsqlParser::Select_options_itemContext::T_AND() {
  return getToken(HplsqlParser::T_AND, 0);
}

tree::TerminalNode* HplsqlParser::Select_options_itemContext::T_KEEP() {
  return getToken(HplsqlParser::T_KEEP, 0);
}

tree::TerminalNode* HplsqlParser::Select_options_itemContext::T_LOCKS() {
  return getToken(HplsqlParser::T_LOCKS, 0);
}

tree::TerminalNode* HplsqlParser::Select_options_itemContext::T_EXCLUSIVE() {
  return getToken(HplsqlParser::T_EXCLUSIVE, 0);
}

tree::TerminalNode* HplsqlParser::Select_options_itemContext::T_UPDATE() {
  return getToken(HplsqlParser::T_UPDATE, 0);
}

tree::TerminalNode* HplsqlParser::Select_options_itemContext::T_SHARE() {
  return getToken(HplsqlParser::T_SHARE, 0);
}


size_t HplsqlParser::Select_options_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleSelect_options_item;
}

void HplsqlParser::Select_options_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_options_item(this);
}

void HplsqlParser::Select_options_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_options_item(this);
}


antlrcpp::Any HplsqlParser::Select_options_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitSelect_options_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Select_options_itemContext* HplsqlParser::select_options_item() {
  Select_options_itemContext *_localctx = _tracker.createInstance<Select_options_itemContext>(_ctx, getState());
  enterRule(_localctx, 340, HplsqlParser::RuleSelect_options_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2463);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_LIMIT: {
        enterOuterAlt(_localctx, 1);
        setState(2452);
        match(HplsqlParser::T_LIMIT);
        setState(2453);
        expr(0);
        break;
      }

      case HplsqlParser::T_WITH: {
        enterOuterAlt(_localctx, 2);
        setState(2454);
        match(HplsqlParser::T_WITH);
        setState(2455);
        _la = _input->LA(1);
        if (!(_la == HplsqlParser::T_CS || ((((_la - 245) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 245)) & ((1ULL << (HplsqlParser::T_RR - 245))
          | (1ULL << (HplsqlParser::T_RS - 245))
          | (1ULL << (HplsqlParser::T_UR - 245)))) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2461);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 301, _ctx)) {
        case 1: {
          setState(2456);
          match(HplsqlParser::T_USE);
          setState(2457);
          match(HplsqlParser::T_AND);
          setState(2458);
          match(HplsqlParser::T_KEEP);
          setState(2459);
          _la = _input->LA(1);
          if (!(_la == HplsqlParser::T_EXCLUSIVE || _la == HplsqlParser::T_SHARE

          || _la == HplsqlParser::T_UPDATE)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(2460);
          match(HplsqlParser::T_LOCKS);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Update_stmtContext ------------------------------------------------------------------

HplsqlParser::Update_stmtContext::Update_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Update_stmtContext::T_UPDATE() {
  return getToken(HplsqlParser::T_UPDATE, 0);
}

HplsqlParser::Update_tableContext* HplsqlParser::Update_stmtContext::update_table() {
  return getRuleContext<HplsqlParser::Update_tableContext>(0);
}

tree::TerminalNode* HplsqlParser::Update_stmtContext::T_SET() {
  return getToken(HplsqlParser::T_SET, 0);
}

HplsqlParser::Update_assignmentContext* HplsqlParser::Update_stmtContext::update_assignment() {
  return getRuleContext<HplsqlParser::Update_assignmentContext>(0);
}

HplsqlParser::Where_clauseContext* HplsqlParser::Update_stmtContext::where_clause() {
  return getRuleContext<HplsqlParser::Where_clauseContext>(0);
}

HplsqlParser::Update_upsertContext* HplsqlParser::Update_stmtContext::update_upsert() {
  return getRuleContext<HplsqlParser::Update_upsertContext>(0);
}


size_t HplsqlParser::Update_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleUpdate_stmt;
}

void HplsqlParser::Update_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdate_stmt(this);
}

void HplsqlParser::Update_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdate_stmt(this);
}


antlrcpp::Any HplsqlParser::Update_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitUpdate_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Update_stmtContext* HplsqlParser::update_stmt() {
  Update_stmtContext *_localctx = _tracker.createInstance<Update_stmtContext>(_ctx, getState());
  enterRule(_localctx, 342, HplsqlParser::RuleUpdate_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2465);
    match(HplsqlParser::T_UPDATE);
    setState(2466);
    update_table();
    setState(2467);
    match(HplsqlParser::T_SET);
    setState(2468);
    update_assignment();
    setState(2470);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 303, _ctx)) {
    case 1: {
      setState(2469);
      where_clause();
      break;
    }

    default:
      break;
    }
    setState(2473);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 304, _ctx)) {
    case 1: {
      setState(2472);
      update_upsert();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Update_assignmentContext ------------------------------------------------------------------

HplsqlParser::Update_assignmentContext::Update_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HplsqlParser::Assignment_stmt_itemContext *> HplsqlParser::Update_assignmentContext::assignment_stmt_item() {
  return getRuleContexts<HplsqlParser::Assignment_stmt_itemContext>();
}

HplsqlParser::Assignment_stmt_itemContext* HplsqlParser::Update_assignmentContext::assignment_stmt_item(size_t i) {
  return getRuleContext<HplsqlParser::Assignment_stmt_itemContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Update_assignmentContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Update_assignmentContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Update_assignmentContext::getRuleIndex() const {
  return HplsqlParser::RuleUpdate_assignment;
}

void HplsqlParser::Update_assignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdate_assignment(this);
}

void HplsqlParser::Update_assignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdate_assignment(this);
}


antlrcpp::Any HplsqlParser::Update_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitUpdate_assignment(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Update_assignmentContext* HplsqlParser::update_assignment() {
  Update_assignmentContext *_localctx = _tracker.createInstance<Update_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 344, HplsqlParser::RuleUpdate_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2475);
    assignment_stmt_item();
    setState(2480);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 305, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2476);
        match(HplsqlParser::T_COMMA);
        setState(2477);
        assignment_stmt_item(); 
      }
      setState(2482);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 305, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Update_tableContext ------------------------------------------------------------------

HplsqlParser::Update_tableContext::Update_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Table_nameContext* HplsqlParser::Update_tableContext::table_name() {
  return getRuleContext<HplsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* HplsqlParser::Update_tableContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

HplsqlParser::Select_stmtContext* HplsqlParser::Update_tableContext::select_stmt() {
  return getRuleContext<HplsqlParser::Select_stmtContext>(0);
}

tree::TerminalNode* HplsqlParser::Update_tableContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

HplsqlParser::IdentContext* HplsqlParser::Update_tableContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

HplsqlParser::From_clauseContext* HplsqlParser::Update_tableContext::from_clause() {
  return getRuleContext<HplsqlParser::From_clauseContext>(0);
}

tree::TerminalNode* HplsqlParser::Update_tableContext::T_AS() {
  return getToken(HplsqlParser::T_AS, 0);
}


size_t HplsqlParser::Update_tableContext::getRuleIndex() const {
  return HplsqlParser::RuleUpdate_table;
}

void HplsqlParser::Update_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdate_table(this);
}

void HplsqlParser::Update_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdate_table(this);
}


antlrcpp::Any HplsqlParser::Update_tableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitUpdate_table(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Update_tableContext* HplsqlParser::update_table() {
  Update_tableContext *_localctx = _tracker.createInstance<Update_tableContext>(_ctx, getState());
  enterRule(_localctx, 346, HplsqlParser::RuleUpdate_table);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2491);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_ACTION:
      case HplsqlParser::T_ADD2:
      case HplsqlParser::T_ALL:
      case HplsqlParser::T_ALLOCATE:
      case HplsqlParser::T_ALTER:
      case HplsqlParser::T_AND:
      case HplsqlParser::T_ANSI_NULLS:
      case HplsqlParser::T_ANSI_PADDING:
      case HplsqlParser::T_AS:
      case HplsqlParser::T_ASC:
      case HplsqlParser::T_ASSOCIATE:
      case HplsqlParser::T_AT:
      case HplsqlParser::T_AUTO_INCREMENT:
      case HplsqlParser::T_AVG:
      case HplsqlParser::T_BATCHSIZE:
      case HplsqlParser::T_BEGIN:
      case HplsqlParser::T_BETWEEN:
      case HplsqlParser::T_BIGINT:
      case HplsqlParser::T_BINARY_DOUBLE:
      case HplsqlParser::T_BINARY_FLOAT:
      case HplsqlParser::T_BIT:
      case HplsqlParser::T_BODY:
      case HplsqlParser::T_BREAK:
      case HplsqlParser::T_BY:
      case HplsqlParser::T_BYTE:
      case HplsqlParser::T_CALL:
      case HplsqlParser::T_CALLER:
      case HplsqlParser::T_CASCADE:
      case HplsqlParser::T_CASE:
      case HplsqlParser::T_CASESPECIFIC:
      case HplsqlParser::T_CAST:
      case HplsqlParser::T_CHAR:
      case HplsqlParser::T_CHARACTER:
      case HplsqlParser::T_CHARSET:
      case HplsqlParser::T_CLIENT:
      case HplsqlParser::T_CLOSE:
      case HplsqlParser::T_CLUSTERED:
      case HplsqlParser::T_CMP:
      case HplsqlParser::T_COLLECT:
      case HplsqlParser::T_COLLECTION:
      case HplsqlParser::T_COLUMN:
      case HplsqlParser::T_COMMENT:
      case HplsqlParser::T_CONSTANT:
      case HplsqlParser::T_COMMIT:
      case HplsqlParser::T_COMPRESS:
      case HplsqlParser::T_CONCAT:
      case HplsqlParser::T_CONDITION:
      case HplsqlParser::T_CONSTRAINT:
      case HplsqlParser::T_CONTINUE:
      case HplsqlParser::T_COPY:
      case HplsqlParser::T_COUNT:
      case HplsqlParser::T_COUNT_BIG:
      case HplsqlParser::T_CREATE:
      case HplsqlParser::T_CREATION:
      case HplsqlParser::T_CREATOR:
      case HplsqlParser::T_CS:
      case HplsqlParser::T_CURRENT:
      case HplsqlParser::T_CURRENT_SCHEMA:
      case HplsqlParser::T_CURSOR:
      case HplsqlParser::T_DATABASE:
      case HplsqlParser::T_DATA:
      case HplsqlParser::T_DATE:
      case HplsqlParser::T_DATETIME:
      case HplsqlParser::T_DAY:
      case HplsqlParser::T_DAYS:
      case HplsqlParser::T_DEC:
      case HplsqlParser::T_DECIMAL:
      case HplsqlParser::T_DECLARE:
      case HplsqlParser::T_DEFAULT:
      case HplsqlParser::T_DEFERRED:
      case HplsqlParser::T_DEFINED:
      case HplsqlParser::T_DEFINER:
      case HplsqlParser::T_DEFINITION:
      case HplsqlParser::T_DELETE:
      case HplsqlParser::T_DELIMITED:
      case HplsqlParser::T_DELIMITER:
      case HplsqlParser::T_DESC:
      case HplsqlParser::T_DESCRIBE:
      case HplsqlParser::T_DIAGNOSTICS:
      case HplsqlParser::T_DIR:
      case HplsqlParser::T_DIRECTORY:
      case HplsqlParser::T_DISTINCT:
      case HplsqlParser::T_DISTRIBUTE:
      case HplsqlParser::T_DO:
      case HplsqlParser::T_DOUBLE:
      case HplsqlParser::T_DROP:
      case HplsqlParser::T_DYNAMIC:
      case HplsqlParser::T_ENABLE:
      case HplsqlParser::T_ENGINE:
      case HplsqlParser::T_ESCAPED:
      case HplsqlParser::T_EXCEPT:
      case HplsqlParser::T_EXEC:
      case HplsqlParser::T_EXECUTE:
      case HplsqlParser::T_EXCEPTION:
      case HplsqlParser::T_EXCLUSIVE:
      case HplsqlParser::T_EXISTS:
      case HplsqlParser::T_EXIT:
      case HplsqlParser::T_FALLBACK:
      case HplsqlParser::T_FALSE:
      case HplsqlParser::T_FETCH:
      case HplsqlParser::T_FIELDS:
      case HplsqlParser::T_FILE:
      case HplsqlParser::T_FILES:
      case HplsqlParser::T_FLOAT:
      case HplsqlParser::T_FOR:
      case HplsqlParser::T_FOREIGN:
      case HplsqlParser::T_FORMAT:
      case HplsqlParser::T_FOUND:
      case HplsqlParser::T_FROM:
      case HplsqlParser::T_FULL:
      case HplsqlParser::T_FUNCTION:
      case HplsqlParser::T_GET:
      case HplsqlParser::T_GLOBAL:
      case HplsqlParser::T_GO:
      case HplsqlParser::T_GRANT:
      case HplsqlParser::T_GROUP:
      case HplsqlParser::T_HANDLER:
      case HplsqlParser::T_HASH:
      case HplsqlParser::T_HAVING:
      case HplsqlParser::T_HDFS:
      case HplsqlParser::T_HIVE:
      case HplsqlParser::T_HOST:
      case HplsqlParser::T_IDENTITY:
      case HplsqlParser::T_IF:
      case HplsqlParser::T_IGNORE:
      case HplsqlParser::T_IMMEDIATE:
      case HplsqlParser::T_IN:
      case HplsqlParser::T_INCLUDE:
      case HplsqlParser::T_INDEX:
      case HplsqlParser::T_INITRANS:
      case HplsqlParser::T_INNER:
      case HplsqlParser::T_INOUT:
      case HplsqlParser::T_INSERT:
      case HplsqlParser::T_INT:
      case HplsqlParser::T_INT2:
      case HplsqlParser::T_INT4:
      case HplsqlParser::T_INT8:
      case HplsqlParser::T_INTEGER:
      case HplsqlParser::T_INTERSECT:
      case HplsqlParser::T_INTERVAL:
      case HplsqlParser::T_INTO:
      case HplsqlParser::T_INVOKER:
      case HplsqlParser::T_IS:
      case HplsqlParser::T_ISOPEN:
      case HplsqlParser::T_ITEMS:
      case HplsqlParser::T_JOIN:
      case HplsqlParser::T_KEEP:
      case HplsqlParser::T_KEY:
      case HplsqlParser::T_KEYS:
      case HplsqlParser::T_LANGUAGE:
      case HplsqlParser::T_LEAVE:
      case HplsqlParser::T_LEFT:
      case HplsqlParser::T_LIKE:
      case HplsqlParser::T_LIMIT:
      case HplsqlParser::T_LINES:
      case HplsqlParser::T_LOCAL:
      case HplsqlParser::T_LOCATION:
      case HplsqlParser::T_LOCATOR:
      case HplsqlParser::T_LOCATORS:
      case HplsqlParser::T_LOCKS:
      case HplsqlParser::T_LOG:
      case HplsqlParser::T_LOGGED:
      case HplsqlParser::T_LOGGING:
      case HplsqlParser::T_LOOP:
      case HplsqlParser::T_MAP:
      case HplsqlParser::T_MATCHED:
      case HplsqlParser::T_MAX:
      case HplsqlParser::T_MAXTRANS:
      case HplsqlParser::T_MERGE:
      case HplsqlParser::T_MESSAGE_TEXT:
      case HplsqlParser::T_MICROSECOND:
      case HplsqlParser::T_MICROSECONDS:
      case HplsqlParser::T_MIN:
      case HplsqlParser::T_MULTISET:
      case HplsqlParser::T_NCHAR:
      case HplsqlParser::T_NEW:
      case HplsqlParser::T_NVARCHAR:
      case HplsqlParser::T_NO:
      case HplsqlParser::T_NOCOUNT:
      case HplsqlParser::T_NOCOMPRESS:
      case HplsqlParser::T_NOLOGGING:
      case HplsqlParser::T_NONE:
      case HplsqlParser::T_NOT:
      case HplsqlParser::T_NOTFOUND:
      case HplsqlParser::T_NUMERIC:
      case HplsqlParser::T_NUMBER:
      case HplsqlParser::T_OBJECT:
      case HplsqlParser::T_OFF:
      case HplsqlParser::T_ON:
      case HplsqlParser::T_ONLY:
      case HplsqlParser::T_OPEN:
      case HplsqlParser::T_OR:
      case HplsqlParser::T_ORDER:
      case HplsqlParser::T_OUT:
      case HplsqlParser::T_OUTER:
      case HplsqlParser::T_OVER:
      case HplsqlParser::T_OVERWRITE:
      case HplsqlParser::T_OWNER:
      case HplsqlParser::T_PACKAGE:
      case HplsqlParser::T_PARTITION:
      case HplsqlParser::T_PCTFREE:
      case HplsqlParser::T_PCTUSED:
      case HplsqlParser::T_PRECISION:
      case HplsqlParser::T_PRESERVE:
      case HplsqlParser::T_PRIMARY:
      case HplsqlParser::T_PRINT:
      case HplsqlParser::T_PROC:
      case HplsqlParser::T_PROCEDURE:
      case HplsqlParser::T_QUALIFY:
      case HplsqlParser::T_QUERY_BAND:
      case HplsqlParser::T_QUIT:
      case HplsqlParser::T_QUOTED_IDENTIFIER:
      case HplsqlParser::T_RAISE:
      case HplsqlParser::T_REAL:
      case HplsqlParser::T_REFERENCES:
      case HplsqlParser::T_REGEXP:
      case HplsqlParser::T_REPLACE:
      case HplsqlParser::T_RESIGNAL:
      case HplsqlParser::T_RESTRICT:
      case HplsqlParser::T_RESULT:
      case HplsqlParser::T_RESULT_SET_LOCATOR:
      case HplsqlParser::T_RETURN:
      case HplsqlParser::T_RETURNS:
      case HplsqlParser::T_REVERSE:
      case HplsqlParser::T_RIGHT:
      case HplsqlParser::T_RLIKE:
      case HplsqlParser::T_ROLE:
      case HplsqlParser::T_ROLLBACK:
      case HplsqlParser::T_ROW:
      case HplsqlParser::T_ROWS:
      case HplsqlParser::T_ROW_COUNT:
      case HplsqlParser::T_RR:
      case HplsqlParser::T_RS:
      case HplsqlParser::T_PWD:
      case HplsqlParser::T_TRIM:
      case HplsqlParser::T_SCHEMA:
      case HplsqlParser::T_SECOND:
      case HplsqlParser::T_SECONDS:
      case HplsqlParser::T_SECURITY:
      case HplsqlParser::T_SEGMENT:
      case HplsqlParser::T_SEL:
      case HplsqlParser::T_SELECT:
      case HplsqlParser::T_SET:
      case HplsqlParser::T_SESSION:
      case HplsqlParser::T_SESSIONS:
      case HplsqlParser::T_SETS:
      case HplsqlParser::T_SHARE:
      case HplsqlParser::T_SIGNAL:
      case HplsqlParser::T_SIMPLE_DOUBLE:
      case HplsqlParser::T_SIMPLE_FLOAT:
      case HplsqlParser::T_SMALLDATETIME:
      case HplsqlParser::T_SMALLINT:
      case HplsqlParser::T_SQL:
      case HplsqlParser::T_SQLEXCEPTION:
      case HplsqlParser::T_SQLINSERT:
      case HplsqlParser::T_SQLSTATE:
      case HplsqlParser::T_SQLWARNING:
      case HplsqlParser::T_STATS:
      case HplsqlParser::T_STATISTICS:
      case HplsqlParser::T_STEP:
      case HplsqlParser::T_STORAGE:
      case HplsqlParser::T_STORED:
      case HplsqlParser::T_STRING:
      case HplsqlParser::T_SUBDIR:
      case HplsqlParser::T_SUBSTRING:
      case HplsqlParser::T_SUM:
      case HplsqlParser::T_SYS_REFCURSOR:
      case HplsqlParser::T_TABLE:
      case HplsqlParser::T_TABLESPACE:
      case HplsqlParser::T_TEMPORARY:
      case HplsqlParser::T_TERMINATED:
      case HplsqlParser::T_TEXTIMAGE_ON:
      case HplsqlParser::T_THEN:
      case HplsqlParser::T_TIMESTAMP:
      case HplsqlParser::T_TITLE:
      case HplsqlParser::T_TO:
      case HplsqlParser::T_TOP:
      case HplsqlParser::T_TRANSACTION:
      case HplsqlParser::T_TRUE:
      case HplsqlParser::T_TRUNCATE:
      case HplsqlParser::T_UNIQUE:
      case HplsqlParser::T_UPDATE:
      case HplsqlParser::T_UR:
      case HplsqlParser::T_USE:
      case HplsqlParser::T_USING:
      case HplsqlParser::T_VALUE:
      case HplsqlParser::T_VALUES:
      case HplsqlParser::T_VAR:
      case HplsqlParser::T_VARCHAR:
      case HplsqlParser::T_VARCHAR2:
      case HplsqlParser::T_VARYING:
      case HplsqlParser::T_VOLATILE:
      case HplsqlParser::T_WHILE:
      case HplsqlParser::T_WITH:
      case HplsqlParser::T_WITHOUT:
      case HplsqlParser::T_WORK:
      case HplsqlParser::T_XACT_ABORT:
      case HplsqlParser::T_XML:
      case HplsqlParser::T_YES:
      case HplsqlParser::T_ACTIVITY_COUNT:
      case HplsqlParser::T_CUME_DIST:
      case HplsqlParser::T_CURRENT_DATE:
      case HplsqlParser::T_CURRENT_TIMESTAMP:
      case HplsqlParser::T_CURRENT_USER:
      case HplsqlParser::T_DENSE_RANK:
      case HplsqlParser::T_FIRST_VALUE:
      case HplsqlParser::T_LAG:
      case HplsqlParser::T_LAST_VALUE:
      case HplsqlParser::T_LEAD:
      case HplsqlParser::T_PART_COUNT:
      case HplsqlParser::T_PART_LOC:
      case HplsqlParser::T_RANK:
      case HplsqlParser::T_ROW_NUMBER:
      case HplsqlParser::T_STDEV:
      case HplsqlParser::T_SYSDATE:
      case HplsqlParser::T_VARIANCE:
      case HplsqlParser::T_USER:
      case HplsqlParser::L_ID: {
        setState(2483);
        table_name();
        setState(2485);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 306, _ctx)) {
        case 1: {
          setState(2484);
          from_clause();
          break;
        }

        default:
          break;
        }
        break;
      }

      case HplsqlParser::T_OPEN_P: {
        setState(2487);
        match(HplsqlParser::T_OPEN_P);
        setState(2488);
        select_stmt();
        setState(2489);
        match(HplsqlParser::T_CLOSE_P);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2497);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 309, _ctx)) {
    case 1: {
      setState(2494);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 308, _ctx)) {
      case 1: {
        setState(2493);
        match(HplsqlParser::T_AS);
        break;
      }

      default:
        break;
      }
      setState(2496);
      ident();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Update_upsertContext ------------------------------------------------------------------

HplsqlParser::Update_upsertContext::Update_upsertContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Update_upsertContext::T_ELSE() {
  return getToken(HplsqlParser::T_ELSE, 0);
}

HplsqlParser::Insert_stmtContext* HplsqlParser::Update_upsertContext::insert_stmt() {
  return getRuleContext<HplsqlParser::Insert_stmtContext>(0);
}


size_t HplsqlParser::Update_upsertContext::getRuleIndex() const {
  return HplsqlParser::RuleUpdate_upsert;
}

void HplsqlParser::Update_upsertContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdate_upsert(this);
}

void HplsqlParser::Update_upsertContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdate_upsert(this);
}


antlrcpp::Any HplsqlParser::Update_upsertContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitUpdate_upsert(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Update_upsertContext* HplsqlParser::update_upsert() {
  Update_upsertContext *_localctx = _tracker.createInstance<Update_upsertContext>(_ctx, getState());
  enterRule(_localctx, 348, HplsqlParser::RuleUpdate_upsert);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2499);
    match(HplsqlParser::T_ELSE);
    setState(2500);
    insert_stmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Merge_stmtContext ------------------------------------------------------------------

HplsqlParser::Merge_stmtContext::Merge_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Merge_stmtContext::T_MERGE() {
  return getToken(HplsqlParser::T_MERGE, 0);
}

tree::TerminalNode* HplsqlParser::Merge_stmtContext::T_INTO() {
  return getToken(HplsqlParser::T_INTO, 0);
}

std::vector<HplsqlParser::Merge_tableContext *> HplsqlParser::Merge_stmtContext::merge_table() {
  return getRuleContexts<HplsqlParser::Merge_tableContext>();
}

HplsqlParser::Merge_tableContext* HplsqlParser::Merge_stmtContext::merge_table(size_t i) {
  return getRuleContext<HplsqlParser::Merge_tableContext>(i);
}

tree::TerminalNode* HplsqlParser::Merge_stmtContext::T_USING() {
  return getToken(HplsqlParser::T_USING, 0);
}

tree::TerminalNode* HplsqlParser::Merge_stmtContext::T_ON() {
  return getToken(HplsqlParser::T_ON, 0);
}

HplsqlParser::Bool_exprContext* HplsqlParser::Merge_stmtContext::bool_expr() {
  return getRuleContext<HplsqlParser::Bool_exprContext>(0);
}

std::vector<HplsqlParser::Merge_conditionContext *> HplsqlParser::Merge_stmtContext::merge_condition() {
  return getRuleContexts<HplsqlParser::Merge_conditionContext>();
}

HplsqlParser::Merge_conditionContext* HplsqlParser::Merge_stmtContext::merge_condition(size_t i) {
  return getRuleContext<HplsqlParser::Merge_conditionContext>(i);
}


size_t HplsqlParser::Merge_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleMerge_stmt;
}

void HplsqlParser::Merge_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMerge_stmt(this);
}

void HplsqlParser::Merge_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMerge_stmt(this);
}


antlrcpp::Any HplsqlParser::Merge_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitMerge_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Merge_stmtContext* HplsqlParser::merge_stmt() {
  Merge_stmtContext *_localctx = _tracker.createInstance<Merge_stmtContext>(_ctx, getState());
  enterRule(_localctx, 350, HplsqlParser::RuleMerge_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2502);
    match(HplsqlParser::T_MERGE);
    setState(2503);
    match(HplsqlParser::T_INTO);
    setState(2504);
    merge_table();
    setState(2505);
    match(HplsqlParser::T_USING);
    setState(2506);
    merge_table();
    setState(2507);
    match(HplsqlParser::T_ON);
    setState(2508);
    bool_expr(0);
    setState(2510); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(2509);
              merge_condition();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(2512); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 310, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Merge_tableContext ------------------------------------------------------------------

HplsqlParser::Merge_tableContext::Merge_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Table_nameContext* HplsqlParser::Merge_tableContext::table_name() {
  return getRuleContext<HplsqlParser::Table_nameContext>(0);
}

HplsqlParser::IdentContext* HplsqlParser::Merge_tableContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

tree::TerminalNode* HplsqlParser::Merge_tableContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

HplsqlParser::Select_stmtContext* HplsqlParser::Merge_tableContext::select_stmt() {
  return getRuleContext<HplsqlParser::Select_stmtContext>(0);
}

tree::TerminalNode* HplsqlParser::Merge_tableContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

tree::TerminalNode* HplsqlParser::Merge_tableContext::T_AS() {
  return getToken(HplsqlParser::T_AS, 0);
}


size_t HplsqlParser::Merge_tableContext::getRuleIndex() const {
  return HplsqlParser::RuleMerge_table;
}

void HplsqlParser::Merge_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMerge_table(this);
}

void HplsqlParser::Merge_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMerge_table(this);
}


antlrcpp::Any HplsqlParser::Merge_tableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitMerge_table(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Merge_tableContext* HplsqlParser::merge_table() {
  Merge_tableContext *_localctx = _tracker.createInstance<Merge_tableContext>(_ctx, getState());
  enterRule(_localctx, 352, HplsqlParser::RuleMerge_table);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2519);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_ACTION:
      case HplsqlParser::T_ADD2:
      case HplsqlParser::T_ALL:
      case HplsqlParser::T_ALLOCATE:
      case HplsqlParser::T_ALTER:
      case HplsqlParser::T_AND:
      case HplsqlParser::T_ANSI_NULLS:
      case HplsqlParser::T_ANSI_PADDING:
      case HplsqlParser::T_AS:
      case HplsqlParser::T_ASC:
      case HplsqlParser::T_ASSOCIATE:
      case HplsqlParser::T_AT:
      case HplsqlParser::T_AUTO_INCREMENT:
      case HplsqlParser::T_AVG:
      case HplsqlParser::T_BATCHSIZE:
      case HplsqlParser::T_BEGIN:
      case HplsqlParser::T_BETWEEN:
      case HplsqlParser::T_BIGINT:
      case HplsqlParser::T_BINARY_DOUBLE:
      case HplsqlParser::T_BINARY_FLOAT:
      case HplsqlParser::T_BIT:
      case HplsqlParser::T_BODY:
      case HplsqlParser::T_BREAK:
      case HplsqlParser::T_BY:
      case HplsqlParser::T_BYTE:
      case HplsqlParser::T_CALL:
      case HplsqlParser::T_CALLER:
      case HplsqlParser::T_CASCADE:
      case HplsqlParser::T_CASE:
      case HplsqlParser::T_CASESPECIFIC:
      case HplsqlParser::T_CAST:
      case HplsqlParser::T_CHAR:
      case HplsqlParser::T_CHARACTER:
      case HplsqlParser::T_CHARSET:
      case HplsqlParser::T_CLIENT:
      case HplsqlParser::T_CLOSE:
      case HplsqlParser::T_CLUSTERED:
      case HplsqlParser::T_CMP:
      case HplsqlParser::T_COLLECT:
      case HplsqlParser::T_COLLECTION:
      case HplsqlParser::T_COLUMN:
      case HplsqlParser::T_COMMENT:
      case HplsqlParser::T_CONSTANT:
      case HplsqlParser::T_COMMIT:
      case HplsqlParser::T_COMPRESS:
      case HplsqlParser::T_CONCAT:
      case HplsqlParser::T_CONDITION:
      case HplsqlParser::T_CONSTRAINT:
      case HplsqlParser::T_CONTINUE:
      case HplsqlParser::T_COPY:
      case HplsqlParser::T_COUNT:
      case HplsqlParser::T_COUNT_BIG:
      case HplsqlParser::T_CREATE:
      case HplsqlParser::T_CREATION:
      case HplsqlParser::T_CREATOR:
      case HplsqlParser::T_CS:
      case HplsqlParser::T_CURRENT:
      case HplsqlParser::T_CURRENT_SCHEMA:
      case HplsqlParser::T_CURSOR:
      case HplsqlParser::T_DATABASE:
      case HplsqlParser::T_DATA:
      case HplsqlParser::T_DATE:
      case HplsqlParser::T_DATETIME:
      case HplsqlParser::T_DAY:
      case HplsqlParser::T_DAYS:
      case HplsqlParser::T_DEC:
      case HplsqlParser::T_DECIMAL:
      case HplsqlParser::T_DECLARE:
      case HplsqlParser::T_DEFAULT:
      case HplsqlParser::T_DEFERRED:
      case HplsqlParser::T_DEFINED:
      case HplsqlParser::T_DEFINER:
      case HplsqlParser::T_DEFINITION:
      case HplsqlParser::T_DELETE:
      case HplsqlParser::T_DELIMITED:
      case HplsqlParser::T_DELIMITER:
      case HplsqlParser::T_DESC:
      case HplsqlParser::T_DESCRIBE:
      case HplsqlParser::T_DIAGNOSTICS:
      case HplsqlParser::T_DIR:
      case HplsqlParser::T_DIRECTORY:
      case HplsqlParser::T_DISTINCT:
      case HplsqlParser::T_DISTRIBUTE:
      case HplsqlParser::T_DO:
      case HplsqlParser::T_DOUBLE:
      case HplsqlParser::T_DROP:
      case HplsqlParser::T_DYNAMIC:
      case HplsqlParser::T_ENABLE:
      case HplsqlParser::T_ENGINE:
      case HplsqlParser::T_ESCAPED:
      case HplsqlParser::T_EXCEPT:
      case HplsqlParser::T_EXEC:
      case HplsqlParser::T_EXECUTE:
      case HplsqlParser::T_EXCEPTION:
      case HplsqlParser::T_EXCLUSIVE:
      case HplsqlParser::T_EXISTS:
      case HplsqlParser::T_EXIT:
      case HplsqlParser::T_FALLBACK:
      case HplsqlParser::T_FALSE:
      case HplsqlParser::T_FETCH:
      case HplsqlParser::T_FIELDS:
      case HplsqlParser::T_FILE:
      case HplsqlParser::T_FILES:
      case HplsqlParser::T_FLOAT:
      case HplsqlParser::T_FOR:
      case HplsqlParser::T_FOREIGN:
      case HplsqlParser::T_FORMAT:
      case HplsqlParser::T_FOUND:
      case HplsqlParser::T_FROM:
      case HplsqlParser::T_FULL:
      case HplsqlParser::T_FUNCTION:
      case HplsqlParser::T_GET:
      case HplsqlParser::T_GLOBAL:
      case HplsqlParser::T_GO:
      case HplsqlParser::T_GRANT:
      case HplsqlParser::T_GROUP:
      case HplsqlParser::T_HANDLER:
      case HplsqlParser::T_HASH:
      case HplsqlParser::T_HAVING:
      case HplsqlParser::T_HDFS:
      case HplsqlParser::T_HIVE:
      case HplsqlParser::T_HOST:
      case HplsqlParser::T_IDENTITY:
      case HplsqlParser::T_IF:
      case HplsqlParser::T_IGNORE:
      case HplsqlParser::T_IMMEDIATE:
      case HplsqlParser::T_IN:
      case HplsqlParser::T_INCLUDE:
      case HplsqlParser::T_INDEX:
      case HplsqlParser::T_INITRANS:
      case HplsqlParser::T_INNER:
      case HplsqlParser::T_INOUT:
      case HplsqlParser::T_INSERT:
      case HplsqlParser::T_INT:
      case HplsqlParser::T_INT2:
      case HplsqlParser::T_INT4:
      case HplsqlParser::T_INT8:
      case HplsqlParser::T_INTEGER:
      case HplsqlParser::T_INTERSECT:
      case HplsqlParser::T_INTERVAL:
      case HplsqlParser::T_INTO:
      case HplsqlParser::T_INVOKER:
      case HplsqlParser::T_IS:
      case HplsqlParser::T_ISOPEN:
      case HplsqlParser::T_ITEMS:
      case HplsqlParser::T_JOIN:
      case HplsqlParser::T_KEEP:
      case HplsqlParser::T_KEY:
      case HplsqlParser::T_KEYS:
      case HplsqlParser::T_LANGUAGE:
      case HplsqlParser::T_LEAVE:
      case HplsqlParser::T_LEFT:
      case HplsqlParser::T_LIKE:
      case HplsqlParser::T_LIMIT:
      case HplsqlParser::T_LINES:
      case HplsqlParser::T_LOCAL:
      case HplsqlParser::T_LOCATION:
      case HplsqlParser::T_LOCATOR:
      case HplsqlParser::T_LOCATORS:
      case HplsqlParser::T_LOCKS:
      case HplsqlParser::T_LOG:
      case HplsqlParser::T_LOGGED:
      case HplsqlParser::T_LOGGING:
      case HplsqlParser::T_LOOP:
      case HplsqlParser::T_MAP:
      case HplsqlParser::T_MATCHED:
      case HplsqlParser::T_MAX:
      case HplsqlParser::T_MAXTRANS:
      case HplsqlParser::T_MERGE:
      case HplsqlParser::T_MESSAGE_TEXT:
      case HplsqlParser::T_MICROSECOND:
      case HplsqlParser::T_MICROSECONDS:
      case HplsqlParser::T_MIN:
      case HplsqlParser::T_MULTISET:
      case HplsqlParser::T_NCHAR:
      case HplsqlParser::T_NEW:
      case HplsqlParser::T_NVARCHAR:
      case HplsqlParser::T_NO:
      case HplsqlParser::T_NOCOUNT:
      case HplsqlParser::T_NOCOMPRESS:
      case HplsqlParser::T_NOLOGGING:
      case HplsqlParser::T_NONE:
      case HplsqlParser::T_NOT:
      case HplsqlParser::T_NOTFOUND:
      case HplsqlParser::T_NUMERIC:
      case HplsqlParser::T_NUMBER:
      case HplsqlParser::T_OBJECT:
      case HplsqlParser::T_OFF:
      case HplsqlParser::T_ON:
      case HplsqlParser::T_ONLY:
      case HplsqlParser::T_OPEN:
      case HplsqlParser::T_OR:
      case HplsqlParser::T_ORDER:
      case HplsqlParser::T_OUT:
      case HplsqlParser::T_OUTER:
      case HplsqlParser::T_OVER:
      case HplsqlParser::T_OVERWRITE:
      case HplsqlParser::T_OWNER:
      case HplsqlParser::T_PACKAGE:
      case HplsqlParser::T_PARTITION:
      case HplsqlParser::T_PCTFREE:
      case HplsqlParser::T_PCTUSED:
      case HplsqlParser::T_PRECISION:
      case HplsqlParser::T_PRESERVE:
      case HplsqlParser::T_PRIMARY:
      case HplsqlParser::T_PRINT:
      case HplsqlParser::T_PROC:
      case HplsqlParser::T_PROCEDURE:
      case HplsqlParser::T_QUALIFY:
      case HplsqlParser::T_QUERY_BAND:
      case HplsqlParser::T_QUIT:
      case HplsqlParser::T_QUOTED_IDENTIFIER:
      case HplsqlParser::T_RAISE:
      case HplsqlParser::T_REAL:
      case HplsqlParser::T_REFERENCES:
      case HplsqlParser::T_REGEXP:
      case HplsqlParser::T_REPLACE:
      case HplsqlParser::T_RESIGNAL:
      case HplsqlParser::T_RESTRICT:
      case HplsqlParser::T_RESULT:
      case HplsqlParser::T_RESULT_SET_LOCATOR:
      case HplsqlParser::T_RETURN:
      case HplsqlParser::T_RETURNS:
      case HplsqlParser::T_REVERSE:
      case HplsqlParser::T_RIGHT:
      case HplsqlParser::T_RLIKE:
      case HplsqlParser::T_ROLE:
      case HplsqlParser::T_ROLLBACK:
      case HplsqlParser::T_ROW:
      case HplsqlParser::T_ROWS:
      case HplsqlParser::T_ROW_COUNT:
      case HplsqlParser::T_RR:
      case HplsqlParser::T_RS:
      case HplsqlParser::T_PWD:
      case HplsqlParser::T_TRIM:
      case HplsqlParser::T_SCHEMA:
      case HplsqlParser::T_SECOND:
      case HplsqlParser::T_SECONDS:
      case HplsqlParser::T_SECURITY:
      case HplsqlParser::T_SEGMENT:
      case HplsqlParser::T_SEL:
      case HplsqlParser::T_SELECT:
      case HplsqlParser::T_SET:
      case HplsqlParser::T_SESSION:
      case HplsqlParser::T_SESSIONS:
      case HplsqlParser::T_SETS:
      case HplsqlParser::T_SHARE:
      case HplsqlParser::T_SIGNAL:
      case HplsqlParser::T_SIMPLE_DOUBLE:
      case HplsqlParser::T_SIMPLE_FLOAT:
      case HplsqlParser::T_SMALLDATETIME:
      case HplsqlParser::T_SMALLINT:
      case HplsqlParser::T_SQL:
      case HplsqlParser::T_SQLEXCEPTION:
      case HplsqlParser::T_SQLINSERT:
      case HplsqlParser::T_SQLSTATE:
      case HplsqlParser::T_SQLWARNING:
      case HplsqlParser::T_STATS:
      case HplsqlParser::T_STATISTICS:
      case HplsqlParser::T_STEP:
      case HplsqlParser::T_STORAGE:
      case HplsqlParser::T_STORED:
      case HplsqlParser::T_STRING:
      case HplsqlParser::T_SUBDIR:
      case HplsqlParser::T_SUBSTRING:
      case HplsqlParser::T_SUM:
      case HplsqlParser::T_SYS_REFCURSOR:
      case HplsqlParser::T_TABLE:
      case HplsqlParser::T_TABLESPACE:
      case HplsqlParser::T_TEMPORARY:
      case HplsqlParser::T_TERMINATED:
      case HplsqlParser::T_TEXTIMAGE_ON:
      case HplsqlParser::T_THEN:
      case HplsqlParser::T_TIMESTAMP:
      case HplsqlParser::T_TITLE:
      case HplsqlParser::T_TO:
      case HplsqlParser::T_TOP:
      case HplsqlParser::T_TRANSACTION:
      case HplsqlParser::T_TRUE:
      case HplsqlParser::T_TRUNCATE:
      case HplsqlParser::T_UNIQUE:
      case HplsqlParser::T_UPDATE:
      case HplsqlParser::T_UR:
      case HplsqlParser::T_USE:
      case HplsqlParser::T_USING:
      case HplsqlParser::T_VALUE:
      case HplsqlParser::T_VALUES:
      case HplsqlParser::T_VAR:
      case HplsqlParser::T_VARCHAR:
      case HplsqlParser::T_VARCHAR2:
      case HplsqlParser::T_VARYING:
      case HplsqlParser::T_VOLATILE:
      case HplsqlParser::T_WHILE:
      case HplsqlParser::T_WITH:
      case HplsqlParser::T_WITHOUT:
      case HplsqlParser::T_WORK:
      case HplsqlParser::T_XACT_ABORT:
      case HplsqlParser::T_XML:
      case HplsqlParser::T_YES:
      case HplsqlParser::T_ACTIVITY_COUNT:
      case HplsqlParser::T_CUME_DIST:
      case HplsqlParser::T_CURRENT_DATE:
      case HplsqlParser::T_CURRENT_TIMESTAMP:
      case HplsqlParser::T_CURRENT_USER:
      case HplsqlParser::T_DENSE_RANK:
      case HplsqlParser::T_FIRST_VALUE:
      case HplsqlParser::T_LAG:
      case HplsqlParser::T_LAST_VALUE:
      case HplsqlParser::T_LEAD:
      case HplsqlParser::T_PART_COUNT:
      case HplsqlParser::T_PART_LOC:
      case HplsqlParser::T_RANK:
      case HplsqlParser::T_ROW_NUMBER:
      case HplsqlParser::T_STDEV:
      case HplsqlParser::T_SYSDATE:
      case HplsqlParser::T_VARIANCE:
      case HplsqlParser::T_USER:
      case HplsqlParser::L_ID: {
        setState(2514);
        table_name();
        break;
      }

      case HplsqlParser::T_OPEN_P: {
        setState(2515);
        match(HplsqlParser::T_OPEN_P);
        setState(2516);
        select_stmt();
        setState(2517);
        match(HplsqlParser::T_CLOSE_P);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2525);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 313, _ctx)) {
    case 1: {
      setState(2522);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 312, _ctx)) {
      case 1: {
        setState(2521);
        match(HplsqlParser::T_AS);
        break;
      }

      default:
        break;
      }
      setState(2524);
      ident();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Merge_conditionContext ------------------------------------------------------------------

HplsqlParser::Merge_conditionContext::Merge_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Merge_conditionContext::T_WHEN() {
  return getToken(HplsqlParser::T_WHEN, 0);
}

tree::TerminalNode* HplsqlParser::Merge_conditionContext::T_MATCHED() {
  return getToken(HplsqlParser::T_MATCHED, 0);
}

tree::TerminalNode* HplsqlParser::Merge_conditionContext::T_THEN() {
  return getToken(HplsqlParser::T_THEN, 0);
}

HplsqlParser::Merge_actionContext* HplsqlParser::Merge_conditionContext::merge_action() {
  return getRuleContext<HplsqlParser::Merge_actionContext>(0);
}

tree::TerminalNode* HplsqlParser::Merge_conditionContext::T_NOT() {
  return getToken(HplsqlParser::T_NOT, 0);
}

tree::TerminalNode* HplsqlParser::Merge_conditionContext::T_AND() {
  return getToken(HplsqlParser::T_AND, 0);
}

HplsqlParser::Bool_exprContext* HplsqlParser::Merge_conditionContext::bool_expr() {
  return getRuleContext<HplsqlParser::Bool_exprContext>(0);
}

tree::TerminalNode* HplsqlParser::Merge_conditionContext::T_ELSE() {
  return getToken(HplsqlParser::T_ELSE, 0);
}

tree::TerminalNode* HplsqlParser::Merge_conditionContext::T_IGNORE() {
  return getToken(HplsqlParser::T_IGNORE, 0);
}


size_t HplsqlParser::Merge_conditionContext::getRuleIndex() const {
  return HplsqlParser::RuleMerge_condition;
}

void HplsqlParser::Merge_conditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMerge_condition(this);
}

void HplsqlParser::Merge_conditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMerge_condition(this);
}


antlrcpp::Any HplsqlParser::Merge_conditionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitMerge_condition(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Merge_conditionContext* HplsqlParser::merge_condition() {
  Merge_conditionContext *_localctx = _tracker.createInstance<Merge_conditionContext>(_ctx, getState());
  enterRule(_localctx, 354, HplsqlParser::RuleMerge_condition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2540);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_WHEN: {
        enterOuterAlt(_localctx, 1);
        setState(2527);
        match(HplsqlParser::T_WHEN);
        setState(2529);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_NOT) {
          setState(2528);
          match(HplsqlParser::T_NOT);
        }
        setState(2531);
        match(HplsqlParser::T_MATCHED);
        setState(2534);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_AND) {
          setState(2532);
          match(HplsqlParser::T_AND);
          setState(2533);
          bool_expr(0);
        }
        setState(2536);
        match(HplsqlParser::T_THEN);
        setState(2537);
        merge_action();
        break;
      }

      case HplsqlParser::T_ELSE: {
        enterOuterAlt(_localctx, 2);
        setState(2538);
        match(HplsqlParser::T_ELSE);
        setState(2539);
        match(HplsqlParser::T_IGNORE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Merge_actionContext ------------------------------------------------------------------

HplsqlParser::Merge_actionContext::Merge_actionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Merge_actionContext::T_INSERT() {
  return getToken(HplsqlParser::T_INSERT, 0);
}

tree::TerminalNode* HplsqlParser::Merge_actionContext::T_VALUES() {
  return getToken(HplsqlParser::T_VALUES, 0);
}

HplsqlParser::Insert_stmt_rowContext* HplsqlParser::Merge_actionContext::insert_stmt_row() {
  return getRuleContext<HplsqlParser::Insert_stmt_rowContext>(0);
}

HplsqlParser::Insert_stmt_colsContext* HplsqlParser::Merge_actionContext::insert_stmt_cols() {
  return getRuleContext<HplsqlParser::Insert_stmt_colsContext>(0);
}

tree::TerminalNode* HplsqlParser::Merge_actionContext::T_UPDATE() {
  return getToken(HplsqlParser::T_UPDATE, 0);
}

tree::TerminalNode* HplsqlParser::Merge_actionContext::T_SET() {
  return getToken(HplsqlParser::T_SET, 0);
}

std::vector<HplsqlParser::Assignment_stmt_itemContext *> HplsqlParser::Merge_actionContext::assignment_stmt_item() {
  return getRuleContexts<HplsqlParser::Assignment_stmt_itemContext>();
}

HplsqlParser::Assignment_stmt_itemContext* HplsqlParser::Merge_actionContext::assignment_stmt_item(size_t i) {
  return getRuleContext<HplsqlParser::Assignment_stmt_itemContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Merge_actionContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Merge_actionContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}

HplsqlParser::Where_clauseContext* HplsqlParser::Merge_actionContext::where_clause() {
  return getRuleContext<HplsqlParser::Where_clauseContext>(0);
}

tree::TerminalNode* HplsqlParser::Merge_actionContext::T_DELETE() {
  return getToken(HplsqlParser::T_DELETE, 0);
}


size_t HplsqlParser::Merge_actionContext::getRuleIndex() const {
  return HplsqlParser::RuleMerge_action;
}

void HplsqlParser::Merge_actionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMerge_action(this);
}

void HplsqlParser::Merge_actionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMerge_action(this);
}


antlrcpp::Any HplsqlParser::Merge_actionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitMerge_action(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Merge_actionContext* HplsqlParser::merge_action() {
  Merge_actionContext *_localctx = _tracker.createInstance<Merge_actionContext>(_ctx, getState());
  enterRule(_localctx, 356, HplsqlParser::RuleMerge_action);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(2562);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_INSERT: {
        enterOuterAlt(_localctx, 1);
        setState(2542);
        match(HplsqlParser::T_INSERT);
        setState(2544);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_OPEN_P) {
          setState(2543);
          insert_stmt_cols();
        }
        setState(2546);
        match(HplsqlParser::T_VALUES);
        setState(2547);
        insert_stmt_row();
        break;
      }

      case HplsqlParser::T_UPDATE: {
        enterOuterAlt(_localctx, 2);
        setState(2548);
        match(HplsqlParser::T_UPDATE);
        setState(2549);
        match(HplsqlParser::T_SET);
        setState(2550);
        assignment_stmt_item();
        setState(2555);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 318, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2551);
            match(HplsqlParser::T_COMMA);
            setState(2552);
            assignment_stmt_item(); 
          }
          setState(2557);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 318, _ctx);
        }
        setState(2559);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 319, _ctx)) {
        case 1: {
          setState(2558);
          where_clause();
          break;
        }

        default:
          break;
        }
        break;
      }

      case HplsqlParser::T_DELETE: {
        enterOuterAlt(_localctx, 3);
        setState(2561);
        match(HplsqlParser::T_DELETE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delete_stmtContext ------------------------------------------------------------------

HplsqlParser::Delete_stmtContext::Delete_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Delete_stmtContext::T_DELETE() {
  return getToken(HplsqlParser::T_DELETE, 0);
}

HplsqlParser::Table_nameContext* HplsqlParser::Delete_stmtContext::table_name() {
  return getRuleContext<HplsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* HplsqlParser::Delete_stmtContext::T_FROM() {
  return getToken(HplsqlParser::T_FROM, 0);
}

HplsqlParser::Delete_aliasContext* HplsqlParser::Delete_stmtContext::delete_alias() {
  return getRuleContext<HplsqlParser::Delete_aliasContext>(0);
}

HplsqlParser::Where_clauseContext* HplsqlParser::Delete_stmtContext::where_clause() {
  return getRuleContext<HplsqlParser::Where_clauseContext>(0);
}

tree::TerminalNode* HplsqlParser::Delete_stmtContext::T_ALL() {
  return getToken(HplsqlParser::T_ALL, 0);
}


size_t HplsqlParser::Delete_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleDelete_stmt;
}

void HplsqlParser::Delete_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelete_stmt(this);
}

void HplsqlParser::Delete_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelete_stmt(this);
}


antlrcpp::Any HplsqlParser::Delete_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitDelete_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Delete_stmtContext* HplsqlParser::delete_stmt() {
  Delete_stmtContext *_localctx = _tracker.createInstance<Delete_stmtContext>(_ctx, getState());
  enterRule(_localctx, 358, HplsqlParser::RuleDelete_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2564);
    match(HplsqlParser::T_DELETE);
    setState(2566);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 321, _ctx)) {
    case 1: {
      setState(2565);
      match(HplsqlParser::T_FROM);
      break;
    }

    default:
      break;
    }
    setState(2568);
    table_name();
    setState(2570);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 322, _ctx)) {
    case 1: {
      setState(2569);
      delete_alias();
      break;
    }

    default:
      break;
    }
    setState(2574);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 323, _ctx)) {
    case 1: {
      setState(2572);
      where_clause();
      break;
    }

    case 2: {
      setState(2573);
      match(HplsqlParser::T_ALL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delete_aliasContext ------------------------------------------------------------------

HplsqlParser::Delete_aliasContext::Delete_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::IdentContext* HplsqlParser::Delete_aliasContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

tree::TerminalNode* HplsqlParser::Delete_aliasContext::T_AS() {
  return getToken(HplsqlParser::T_AS, 0);
}


size_t HplsqlParser::Delete_aliasContext::getRuleIndex() const {
  return HplsqlParser::RuleDelete_alias;
}

void HplsqlParser::Delete_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelete_alias(this);
}

void HplsqlParser::Delete_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelete_alias(this);
}


antlrcpp::Any HplsqlParser::Delete_aliasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitDelete_alias(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Delete_aliasContext* HplsqlParser::delete_alias() {
  Delete_aliasContext *_localctx = _tracker.createInstance<Delete_aliasContext>(_ctx, getState());
  enterRule(_localctx, 360, HplsqlParser::RuleDelete_alias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2576);

    if (!(strcasecmp(_input->LT(1)->getText().data(), "ALL"))) throw FailedPredicateException(this, "strcasecmp(_input->LT(1)->getText().data(), \"ALL\")");
    setState(2578);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 324, _ctx)) {
    case 1: {
      setState(2577);
      match(HplsqlParser::T_AS);
      break;
    }

    default:
      break;
    }
    setState(2580);
    ident();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Describe_stmtContext ------------------------------------------------------------------

HplsqlParser::Describe_stmtContext::Describe_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Table_nameContext* HplsqlParser::Describe_stmtContext::table_name() {
  return getRuleContext<HplsqlParser::Table_nameContext>(0);
}

tree::TerminalNode* HplsqlParser::Describe_stmtContext::T_DESCRIBE() {
  return getToken(HplsqlParser::T_DESCRIBE, 0);
}

tree::TerminalNode* HplsqlParser::Describe_stmtContext::T_DESC() {
  return getToken(HplsqlParser::T_DESC, 0);
}

tree::TerminalNode* HplsqlParser::Describe_stmtContext::T_TABLE() {
  return getToken(HplsqlParser::T_TABLE, 0);
}


size_t HplsqlParser::Describe_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleDescribe_stmt;
}

void HplsqlParser::Describe_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDescribe_stmt(this);
}

void HplsqlParser::Describe_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDescribe_stmt(this);
}


antlrcpp::Any HplsqlParser::Describe_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitDescribe_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Describe_stmtContext* HplsqlParser::describe_stmt() {
  Describe_stmtContext *_localctx = _tracker.createInstance<Describe_stmtContext>(_ctx, getState());
  enterRule(_localctx, 362, HplsqlParser::RuleDescribe_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2582);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_DESC

    || _la == HplsqlParser::T_DESCRIBE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2584);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 325, _ctx)) {
    case 1: {
      setState(2583);
      match(HplsqlParser::T_TABLE);
      break;
    }

    default:
      break;
    }
    setState(2586);
    table_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bool_exprContext ------------------------------------------------------------------

HplsqlParser::Bool_exprContext::Bool_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Bool_exprContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

std::vector<HplsqlParser::Bool_exprContext *> HplsqlParser::Bool_exprContext::bool_expr() {
  return getRuleContexts<HplsqlParser::Bool_exprContext>();
}

HplsqlParser::Bool_exprContext* HplsqlParser::Bool_exprContext::bool_expr(size_t i) {
  return getRuleContext<HplsqlParser::Bool_exprContext>(i);
}

tree::TerminalNode* HplsqlParser::Bool_exprContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

tree::TerminalNode* HplsqlParser::Bool_exprContext::T_NOT() {
  return getToken(HplsqlParser::T_NOT, 0);
}

HplsqlParser::Bool_expr_atomContext* HplsqlParser::Bool_exprContext::bool_expr_atom() {
  return getRuleContext<HplsqlParser::Bool_expr_atomContext>(0);
}

HplsqlParser::Bool_expr_logical_operatorContext* HplsqlParser::Bool_exprContext::bool_expr_logical_operator() {
  return getRuleContext<HplsqlParser::Bool_expr_logical_operatorContext>(0);
}


size_t HplsqlParser::Bool_exprContext::getRuleIndex() const {
  return HplsqlParser::RuleBool_expr;
}

void HplsqlParser::Bool_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBool_expr(this);
}

void HplsqlParser::Bool_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBool_expr(this);
}


antlrcpp::Any HplsqlParser::Bool_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitBool_expr(this);
  else
    return visitor->visitChildren(this);
}


HplsqlParser::Bool_exprContext* HplsqlParser::bool_expr() {
   return bool_expr(0);
}

HplsqlParser::Bool_exprContext* HplsqlParser::bool_expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  HplsqlParser::Bool_exprContext *_localctx = _tracker.createInstance<Bool_exprContext>(_ctx, parentState);
  HplsqlParser::Bool_exprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 364;
  enterRecursionRule(_localctx, 364, HplsqlParser::RuleBool_expr, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2597);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 327, _ctx)) {
    case 1: {
      setState(2590);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HplsqlParser::T_NOT) {
        setState(2589);
        match(HplsqlParser::T_NOT);
      }
      setState(2592);
      match(HplsqlParser::T_OPEN_P);
      setState(2593);
      bool_expr(0);
      setState(2594);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 2: {
      setState(2596);
      bool_expr_atom();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(2605);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 328, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<Bool_exprContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleBool_expr);
        setState(2599);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(2600);
        bool_expr_logical_operator();
        setState(2601);
        bool_expr(3); 
      }
      setState(2607);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 328, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Bool_expr_atomContext ------------------------------------------------------------------

HplsqlParser::Bool_expr_atomContext::Bool_expr_atomContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Bool_expr_unaryContext* HplsqlParser::Bool_expr_atomContext::bool_expr_unary() {
  return getRuleContext<HplsqlParser::Bool_expr_unaryContext>(0);
}

HplsqlParser::Bool_expr_binaryContext* HplsqlParser::Bool_expr_atomContext::bool_expr_binary() {
  return getRuleContext<HplsqlParser::Bool_expr_binaryContext>(0);
}

HplsqlParser::ExprContext* HplsqlParser::Bool_expr_atomContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}


size_t HplsqlParser::Bool_expr_atomContext::getRuleIndex() const {
  return HplsqlParser::RuleBool_expr_atom;
}

void HplsqlParser::Bool_expr_atomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBool_expr_atom(this);
}

void HplsqlParser::Bool_expr_atomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBool_expr_atom(this);
}


antlrcpp::Any HplsqlParser::Bool_expr_atomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitBool_expr_atom(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Bool_expr_atomContext* HplsqlParser::bool_expr_atom() {
  Bool_expr_atomContext *_localctx = _tracker.createInstance<Bool_expr_atomContext>(_ctx, getState());
  enterRule(_localctx, 366, HplsqlParser::RuleBool_expr_atom);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2611);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 329, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2608);
      bool_expr_unary();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2609);
      bool_expr_binary();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2610);
      expr(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bool_expr_unaryContext ------------------------------------------------------------------

HplsqlParser::Bool_expr_unaryContext::Bool_expr_unaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HplsqlParser::ExprContext *> HplsqlParser::Bool_expr_unaryContext::expr() {
  return getRuleContexts<HplsqlParser::ExprContext>();
}

HplsqlParser::ExprContext* HplsqlParser::Bool_expr_unaryContext::expr(size_t i) {
  return getRuleContext<HplsqlParser::ExprContext>(i);
}

tree::TerminalNode* HplsqlParser::Bool_expr_unaryContext::T_IS() {
  return getToken(HplsqlParser::T_IS, 0);
}

tree::TerminalNode* HplsqlParser::Bool_expr_unaryContext::T_NULL() {
  return getToken(HplsqlParser::T_NULL, 0);
}

tree::TerminalNode* HplsqlParser::Bool_expr_unaryContext::T_NOT() {
  return getToken(HplsqlParser::T_NOT, 0);
}

tree::TerminalNode* HplsqlParser::Bool_expr_unaryContext::T_BETWEEN() {
  return getToken(HplsqlParser::T_BETWEEN, 0);
}

tree::TerminalNode* HplsqlParser::Bool_expr_unaryContext::T_AND() {
  return getToken(HplsqlParser::T_AND, 0);
}

tree::TerminalNode* HplsqlParser::Bool_expr_unaryContext::T_EXISTS() {
  return getToken(HplsqlParser::T_EXISTS, 0);
}

tree::TerminalNode* HplsqlParser::Bool_expr_unaryContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

HplsqlParser::Select_stmtContext* HplsqlParser::Bool_expr_unaryContext::select_stmt() {
  return getRuleContext<HplsqlParser::Select_stmtContext>(0);
}

tree::TerminalNode* HplsqlParser::Bool_expr_unaryContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

HplsqlParser::Bool_expr_single_inContext* HplsqlParser::Bool_expr_unaryContext::bool_expr_single_in() {
  return getRuleContext<HplsqlParser::Bool_expr_single_inContext>(0);
}

HplsqlParser::Bool_expr_multi_inContext* HplsqlParser::Bool_expr_unaryContext::bool_expr_multi_in() {
  return getRuleContext<HplsqlParser::Bool_expr_multi_inContext>(0);
}


size_t HplsqlParser::Bool_expr_unaryContext::getRuleIndex() const {
  return HplsqlParser::RuleBool_expr_unary;
}

void HplsqlParser::Bool_expr_unaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBool_expr_unary(this);
}

void HplsqlParser::Bool_expr_unaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBool_expr_unary(this);
}


antlrcpp::Any HplsqlParser::Bool_expr_unaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitBool_expr_unary(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Bool_expr_unaryContext* HplsqlParser::bool_expr_unary() {
  Bool_expr_unaryContext *_localctx = _tracker.createInstance<Bool_expr_unaryContext>(_ctx, getState());
  enterRule(_localctx, 368, HplsqlParser::RuleBool_expr_unary);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2636);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 332, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2613);
      expr(0);
      setState(2614);
      match(HplsqlParser::T_IS);
      setState(2616);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HplsqlParser::T_NOT) {
        setState(2615);
        match(HplsqlParser::T_NOT);
      }
      setState(2618);
      match(HplsqlParser::T_NULL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2620);
      expr(0);
      setState(2621);
      match(HplsqlParser::T_BETWEEN);
      setState(2622);
      expr(0);
      setState(2623);
      match(HplsqlParser::T_AND);
      setState(2624);
      expr(0);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2627);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HplsqlParser::T_NOT) {
        setState(2626);
        match(HplsqlParser::T_NOT);
      }
      setState(2629);
      match(HplsqlParser::T_EXISTS);
      setState(2630);
      match(HplsqlParser::T_OPEN_P);
      setState(2631);
      select_stmt();
      setState(2632);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2634);
      bool_expr_single_in();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2635);
      bool_expr_multi_in();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bool_expr_single_inContext ------------------------------------------------------------------

HplsqlParser::Bool_expr_single_inContext::Bool_expr_single_inContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HplsqlParser::ExprContext *> HplsqlParser::Bool_expr_single_inContext::expr() {
  return getRuleContexts<HplsqlParser::ExprContext>();
}

HplsqlParser::ExprContext* HplsqlParser::Bool_expr_single_inContext::expr(size_t i) {
  return getRuleContext<HplsqlParser::ExprContext>(i);
}

tree::TerminalNode* HplsqlParser::Bool_expr_single_inContext::T_IN() {
  return getToken(HplsqlParser::T_IN, 0);
}

tree::TerminalNode* HplsqlParser::Bool_expr_single_inContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

tree::TerminalNode* HplsqlParser::Bool_expr_single_inContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

HplsqlParser::Select_stmtContext* HplsqlParser::Bool_expr_single_inContext::select_stmt() {
  return getRuleContext<HplsqlParser::Select_stmtContext>(0);
}

tree::TerminalNode* HplsqlParser::Bool_expr_single_inContext::T_NOT() {
  return getToken(HplsqlParser::T_NOT, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Bool_expr_single_inContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Bool_expr_single_inContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Bool_expr_single_inContext::getRuleIndex() const {
  return HplsqlParser::RuleBool_expr_single_in;
}

void HplsqlParser::Bool_expr_single_inContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBool_expr_single_in(this);
}

void HplsqlParser::Bool_expr_single_inContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBool_expr_single_in(this);
}


antlrcpp::Any HplsqlParser::Bool_expr_single_inContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitBool_expr_single_in(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Bool_expr_single_inContext* HplsqlParser::bool_expr_single_in() {
  Bool_expr_single_inContext *_localctx = _tracker.createInstance<Bool_expr_single_inContext>(_ctx, getState());
  enterRule(_localctx, 370, HplsqlParser::RuleBool_expr_single_in);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2638);
    expr(0);
    setState(2640);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_NOT) {
      setState(2639);
      match(HplsqlParser::T_NOT);
    }
    setState(2642);
    match(HplsqlParser::T_IN);
    setState(2643);
    match(HplsqlParser::T_OPEN_P);
    setState(2653);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 335, _ctx)) {
    case 1: {
      setState(2644);
      expr(0);
      setState(2649);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == HplsqlParser::T_COMMA) {
        setState(2645);
        match(HplsqlParser::T_COMMA);
        setState(2646);
        expr(0);
        setState(2651);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      setState(2652);
      select_stmt();
      break;
    }

    default:
      break;
    }
    setState(2655);
    match(HplsqlParser::T_CLOSE_P);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bool_expr_multi_inContext ------------------------------------------------------------------

HplsqlParser::Bool_expr_multi_inContext::Bool_expr_multi_inContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> HplsqlParser::Bool_expr_multi_inContext::T_OPEN_P() {
  return getTokens(HplsqlParser::T_OPEN_P);
}

tree::TerminalNode* HplsqlParser::Bool_expr_multi_inContext::T_OPEN_P(size_t i) {
  return getToken(HplsqlParser::T_OPEN_P, i);
}

std::vector<HplsqlParser::ExprContext *> HplsqlParser::Bool_expr_multi_inContext::expr() {
  return getRuleContexts<HplsqlParser::ExprContext>();
}

HplsqlParser::ExprContext* HplsqlParser::Bool_expr_multi_inContext::expr(size_t i) {
  return getRuleContext<HplsqlParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Bool_expr_multi_inContext::T_CLOSE_P() {
  return getTokens(HplsqlParser::T_CLOSE_P);
}

tree::TerminalNode* HplsqlParser::Bool_expr_multi_inContext::T_CLOSE_P(size_t i) {
  return getToken(HplsqlParser::T_CLOSE_P, i);
}

tree::TerminalNode* HplsqlParser::Bool_expr_multi_inContext::T_IN() {
  return getToken(HplsqlParser::T_IN, 0);
}

HplsqlParser::Select_stmtContext* HplsqlParser::Bool_expr_multi_inContext::select_stmt() {
  return getRuleContext<HplsqlParser::Select_stmtContext>(0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Bool_expr_multi_inContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Bool_expr_multi_inContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}

tree::TerminalNode* HplsqlParser::Bool_expr_multi_inContext::T_NOT() {
  return getToken(HplsqlParser::T_NOT, 0);
}


size_t HplsqlParser::Bool_expr_multi_inContext::getRuleIndex() const {
  return HplsqlParser::RuleBool_expr_multi_in;
}

void HplsqlParser::Bool_expr_multi_inContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBool_expr_multi_in(this);
}

void HplsqlParser::Bool_expr_multi_inContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBool_expr_multi_in(this);
}


antlrcpp::Any HplsqlParser::Bool_expr_multi_inContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitBool_expr_multi_in(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Bool_expr_multi_inContext* HplsqlParser::bool_expr_multi_in() {
  Bool_expr_multi_inContext *_localctx = _tracker.createInstance<Bool_expr_multi_inContext>(_ctx, getState());
  enterRule(_localctx, 372, HplsqlParser::RuleBool_expr_multi_in);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2657);
    match(HplsqlParser::T_OPEN_P);
    setState(2658);
    expr(0);
    setState(2663);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HplsqlParser::T_COMMA) {
      setState(2659);
      match(HplsqlParser::T_COMMA);
      setState(2660);
      expr(0);
      setState(2665);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2666);
    match(HplsqlParser::T_CLOSE_P);
    setState(2668);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_NOT) {
      setState(2667);
      match(HplsqlParser::T_NOT);
    }
    setState(2670);
    match(HplsqlParser::T_IN);
    setState(2671);
    match(HplsqlParser::T_OPEN_P);
    setState(2672);
    select_stmt();
    setState(2673);
    match(HplsqlParser::T_CLOSE_P);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bool_expr_binaryContext ------------------------------------------------------------------

HplsqlParser::Bool_expr_binaryContext::Bool_expr_binaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HplsqlParser::ExprContext *> HplsqlParser::Bool_expr_binaryContext::expr() {
  return getRuleContexts<HplsqlParser::ExprContext>();
}

HplsqlParser::ExprContext* HplsqlParser::Bool_expr_binaryContext::expr(size_t i) {
  return getRuleContext<HplsqlParser::ExprContext>(i);
}

HplsqlParser::Bool_expr_binary_operatorContext* HplsqlParser::Bool_expr_binaryContext::bool_expr_binary_operator() {
  return getRuleContext<HplsqlParser::Bool_expr_binary_operatorContext>(0);
}


size_t HplsqlParser::Bool_expr_binaryContext::getRuleIndex() const {
  return HplsqlParser::RuleBool_expr_binary;
}

void HplsqlParser::Bool_expr_binaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBool_expr_binary(this);
}

void HplsqlParser::Bool_expr_binaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBool_expr_binary(this);
}


antlrcpp::Any HplsqlParser::Bool_expr_binaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitBool_expr_binary(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Bool_expr_binaryContext* HplsqlParser::bool_expr_binary() {
  Bool_expr_binaryContext *_localctx = _tracker.createInstance<Bool_expr_binaryContext>(_ctx, getState());
  enterRule(_localctx, 374, HplsqlParser::RuleBool_expr_binary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2675);
    expr(0);
    setState(2676);
    bool_expr_binary_operator();
    setState(2677);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bool_expr_logical_operatorContext ------------------------------------------------------------------

HplsqlParser::Bool_expr_logical_operatorContext::Bool_expr_logical_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Bool_expr_logical_operatorContext::T_AND() {
  return getToken(HplsqlParser::T_AND, 0);
}

tree::TerminalNode* HplsqlParser::Bool_expr_logical_operatorContext::T_OR() {
  return getToken(HplsqlParser::T_OR, 0);
}


size_t HplsqlParser::Bool_expr_logical_operatorContext::getRuleIndex() const {
  return HplsqlParser::RuleBool_expr_logical_operator;
}

void HplsqlParser::Bool_expr_logical_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBool_expr_logical_operator(this);
}

void HplsqlParser::Bool_expr_logical_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBool_expr_logical_operator(this);
}


antlrcpp::Any HplsqlParser::Bool_expr_logical_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitBool_expr_logical_operator(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Bool_expr_logical_operatorContext* HplsqlParser::bool_expr_logical_operator() {
  Bool_expr_logical_operatorContext *_localctx = _tracker.createInstance<Bool_expr_logical_operatorContext>(_ctx, getState());
  enterRule(_localctx, 376, HplsqlParser::RuleBool_expr_logical_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2679);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_AND || _la == HplsqlParser::T_OR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bool_expr_binary_operatorContext ------------------------------------------------------------------

HplsqlParser::Bool_expr_binary_operatorContext::Bool_expr_binary_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Bool_expr_binary_operatorContext::T_EQUAL() {
  return getToken(HplsqlParser::T_EQUAL, 0);
}

tree::TerminalNode* HplsqlParser::Bool_expr_binary_operatorContext::T_EQUAL2() {
  return getToken(HplsqlParser::T_EQUAL2, 0);
}

tree::TerminalNode* HplsqlParser::Bool_expr_binary_operatorContext::T_NOTEQUAL() {
  return getToken(HplsqlParser::T_NOTEQUAL, 0);
}

tree::TerminalNode* HplsqlParser::Bool_expr_binary_operatorContext::T_NOTEQUAL2() {
  return getToken(HplsqlParser::T_NOTEQUAL2, 0);
}

tree::TerminalNode* HplsqlParser::Bool_expr_binary_operatorContext::T_LESS() {
  return getToken(HplsqlParser::T_LESS, 0);
}

tree::TerminalNode* HplsqlParser::Bool_expr_binary_operatorContext::T_LESSEQUAL() {
  return getToken(HplsqlParser::T_LESSEQUAL, 0);
}

tree::TerminalNode* HplsqlParser::Bool_expr_binary_operatorContext::T_GREATER() {
  return getToken(HplsqlParser::T_GREATER, 0);
}

tree::TerminalNode* HplsqlParser::Bool_expr_binary_operatorContext::T_GREATEREQUAL() {
  return getToken(HplsqlParser::T_GREATEREQUAL, 0);
}

tree::TerminalNode* HplsqlParser::Bool_expr_binary_operatorContext::T_LIKE() {
  return getToken(HplsqlParser::T_LIKE, 0);
}

tree::TerminalNode* HplsqlParser::Bool_expr_binary_operatorContext::T_RLIKE() {
  return getToken(HplsqlParser::T_RLIKE, 0);
}

tree::TerminalNode* HplsqlParser::Bool_expr_binary_operatorContext::T_REGEXP() {
  return getToken(HplsqlParser::T_REGEXP, 0);
}

tree::TerminalNode* HplsqlParser::Bool_expr_binary_operatorContext::T_NOT() {
  return getToken(HplsqlParser::T_NOT, 0);
}


size_t HplsqlParser::Bool_expr_binary_operatorContext::getRuleIndex() const {
  return HplsqlParser::RuleBool_expr_binary_operator;
}

void HplsqlParser::Bool_expr_binary_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBool_expr_binary_operator(this);
}

void HplsqlParser::Bool_expr_binary_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBool_expr_binary_operator(this);
}


antlrcpp::Any HplsqlParser::Bool_expr_binary_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitBool_expr_binary_operator(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Bool_expr_binary_operatorContext* HplsqlParser::bool_expr_binary_operator() {
  Bool_expr_binary_operatorContext *_localctx = _tracker.createInstance<Bool_expr_binary_operatorContext>(_ctx, getState());
  enterRule(_localctx, 378, HplsqlParser::RuleBool_expr_binary_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2693);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_EQUAL: {
        enterOuterAlt(_localctx, 1);
        setState(2681);
        match(HplsqlParser::T_EQUAL);
        break;
      }

      case HplsqlParser::T_EQUAL2: {
        enterOuterAlt(_localctx, 2);
        setState(2682);
        match(HplsqlParser::T_EQUAL2);
        break;
      }

      case HplsqlParser::T_NOTEQUAL: {
        enterOuterAlt(_localctx, 3);
        setState(2683);
        match(HplsqlParser::T_NOTEQUAL);
        break;
      }

      case HplsqlParser::T_NOTEQUAL2: {
        enterOuterAlt(_localctx, 4);
        setState(2684);
        match(HplsqlParser::T_NOTEQUAL2);
        break;
      }

      case HplsqlParser::T_LESS: {
        enterOuterAlt(_localctx, 5);
        setState(2685);
        match(HplsqlParser::T_LESS);
        break;
      }

      case HplsqlParser::T_LESSEQUAL: {
        enterOuterAlt(_localctx, 6);
        setState(2686);
        match(HplsqlParser::T_LESSEQUAL);
        break;
      }

      case HplsqlParser::T_GREATER: {
        enterOuterAlt(_localctx, 7);
        setState(2687);
        match(HplsqlParser::T_GREATER);
        break;
      }

      case HplsqlParser::T_GREATEREQUAL: {
        enterOuterAlt(_localctx, 8);
        setState(2688);
        match(HplsqlParser::T_GREATEREQUAL);
        break;
      }

      case HplsqlParser::T_LIKE:
      case HplsqlParser::T_NOT:
      case HplsqlParser::T_REGEXP:
      case HplsqlParser::T_RLIKE: {
        enterOuterAlt(_localctx, 9);
        setState(2690);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_NOT) {
          setState(2689);
          match(HplsqlParser::T_NOT);
        }
        setState(2692);
        _la = _input->LA(1);
        if (!(_la == HplsqlParser::T_LIKE || _la == HplsqlParser::T_REGEXP

        || _la == HplsqlParser::T_RLIKE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprContext ------------------------------------------------------------------

HplsqlParser::ExprContext::ExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::ExprContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

HplsqlParser::Select_stmtContext* HplsqlParser::ExprContext::select_stmt() {
  return getRuleContext<HplsqlParser::Select_stmtContext>(0);
}

tree::TerminalNode* HplsqlParser::ExprContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

std::vector<HplsqlParser::ExprContext *> HplsqlParser::ExprContext::expr() {
  return getRuleContexts<HplsqlParser::ExprContext>();
}

HplsqlParser::ExprContext* HplsqlParser::ExprContext::expr(size_t i) {
  return getRuleContext<HplsqlParser::ExprContext>(i);
}

HplsqlParser::Expr_intervalContext* HplsqlParser::ExprContext::expr_interval() {
  return getRuleContext<HplsqlParser::Expr_intervalContext>(0);
}

HplsqlParser::Expr_concatContext* HplsqlParser::ExprContext::expr_concat() {
  return getRuleContext<HplsqlParser::Expr_concatContext>(0);
}

HplsqlParser::Expr_caseContext* HplsqlParser::ExprContext::expr_case() {
  return getRuleContext<HplsqlParser::Expr_caseContext>(0);
}

HplsqlParser::Expr_cursor_attributeContext* HplsqlParser::ExprContext::expr_cursor_attribute() {
  return getRuleContext<HplsqlParser::Expr_cursor_attributeContext>(0);
}

HplsqlParser::Expr_agg_window_funcContext* HplsqlParser::ExprContext::expr_agg_window_func() {
  return getRuleContext<HplsqlParser::Expr_agg_window_funcContext>(0);
}

HplsqlParser::Expr_spec_funcContext* HplsqlParser::ExprContext::expr_spec_func() {
  return getRuleContext<HplsqlParser::Expr_spec_funcContext>(0);
}

HplsqlParser::Expr_funcContext* HplsqlParser::ExprContext::expr_func() {
  return getRuleContext<HplsqlParser::Expr_funcContext>(0);
}

HplsqlParser::Expr_atomContext* HplsqlParser::ExprContext::expr_atom() {
  return getRuleContext<HplsqlParser::Expr_atomContext>(0);
}

tree::TerminalNode* HplsqlParser::ExprContext::T_MUL() {
  return getToken(HplsqlParser::T_MUL, 0);
}

tree::TerminalNode* HplsqlParser::ExprContext::T_DIV() {
  return getToken(HplsqlParser::T_DIV, 0);
}

tree::TerminalNode* HplsqlParser::ExprContext::T_ADD() {
  return getToken(HplsqlParser::T_ADD, 0);
}

tree::TerminalNode* HplsqlParser::ExprContext::T_SUB() {
  return getToken(HplsqlParser::T_SUB, 0);
}

HplsqlParser::Interval_itemContext* HplsqlParser::ExprContext::interval_item() {
  return getRuleContext<HplsqlParser::Interval_itemContext>(0);
}


size_t HplsqlParser::ExprContext::getRuleIndex() const {
  return HplsqlParser::RuleExpr;
}

void HplsqlParser::ExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr(this);
}

void HplsqlParser::ExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr(this);
}


antlrcpp::Any HplsqlParser::ExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitExpr(this);
  else
    return visitor->visitChildren(this);
}


HplsqlParser::ExprContext* HplsqlParser::expr() {
   return expr(0);
}

HplsqlParser::ExprContext* HplsqlParser::expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  HplsqlParser::ExprContext *_localctx = _tracker.createInstance<ExprContext>(_ctx, parentState);
  HplsqlParser::ExprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 380;
  enterRecursionRule(_localctx, 380, HplsqlParser::RuleExpr, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2712);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 340, _ctx)) {
    case 1: {
      setState(2696);
      match(HplsqlParser::T_OPEN_P);
      setState(2697);
      select_stmt();
      setState(2698);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 2: {
      setState(2700);
      match(HplsqlParser::T_OPEN_P);
      setState(2701);
      expr(0);
      setState(2702);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 3: {
      setState(2704);
      expr_interval();
      break;
    }

    case 4: {
      setState(2705);
      expr_concat();
      break;
    }

    case 5: {
      setState(2706);
      expr_case();
      break;
    }

    case 6: {
      setState(2707);
      expr_cursor_attribute();
      break;
    }

    case 7: {
      setState(2708);
      expr_agg_window_func();
      break;
    }

    case 8: {
      setState(2709);
      expr_spec_func();
      break;
    }

    case 9: {
      setState(2710);
      expr_func();
      break;
    }

    case 10: {
      setState(2711);
      expr_atom();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(2730);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 342, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(2728);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 341, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(2714);

          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, "precpred(_ctx, 14)");
          setState(2715);
          match(HplsqlParser::T_MUL);
          setState(2716);
          expr(15);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(2717);

          if (!(precpred(_ctx, 13))) throw FailedPredicateException(this, "precpred(_ctx, 13)");
          setState(2718);
          match(HplsqlParser::T_DIV);
          setState(2719);
          expr(14);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(2720);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(2721);
          match(HplsqlParser::T_ADD);
          setState(2722);
          expr(13);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(2723);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(2724);
          match(HplsqlParser::T_SUB);
          setState(2725);
          expr(12);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(2726);

          if (!(precpred(_ctx, 15))) throw FailedPredicateException(this, "precpred(_ctx, 15)");
          setState(2727);
          interval_item();
          break;
        }

        default:
          break;
        } 
      }
      setState(2732);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 342, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Expr_atomContext ------------------------------------------------------------------

HplsqlParser::Expr_atomContext::Expr_atomContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Date_literalContext* HplsqlParser::Expr_atomContext::date_literal() {
  return getRuleContext<HplsqlParser::Date_literalContext>(0);
}

HplsqlParser::Timestamp_literalContext* HplsqlParser::Expr_atomContext::timestamp_literal() {
  return getRuleContext<HplsqlParser::Timestamp_literalContext>(0);
}

HplsqlParser::Bool_literalContext* HplsqlParser::Expr_atomContext::bool_literal() {
  return getRuleContext<HplsqlParser::Bool_literalContext>(0);
}

HplsqlParser::IdentContext* HplsqlParser::Expr_atomContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

HplsqlParser::StringContext* HplsqlParser::Expr_atomContext::string() {
  return getRuleContext<HplsqlParser::StringContext>(0);
}

HplsqlParser::Dec_numberContext* HplsqlParser::Expr_atomContext::dec_number() {
  return getRuleContext<HplsqlParser::Dec_numberContext>(0);
}

HplsqlParser::Int_numberContext* HplsqlParser::Expr_atomContext::int_number() {
  return getRuleContext<HplsqlParser::Int_numberContext>(0);
}

HplsqlParser::Null_constContext* HplsqlParser::Expr_atomContext::null_const() {
  return getRuleContext<HplsqlParser::Null_constContext>(0);
}


size_t HplsqlParser::Expr_atomContext::getRuleIndex() const {
  return HplsqlParser::RuleExpr_atom;
}

void HplsqlParser::Expr_atomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_atom(this);
}

void HplsqlParser::Expr_atomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_atom(this);
}


antlrcpp::Any HplsqlParser::Expr_atomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitExpr_atom(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Expr_atomContext* HplsqlParser::expr_atom() {
  Expr_atomContext *_localctx = _tracker.createInstance<Expr_atomContext>(_ctx, getState());
  enterRule(_localctx, 382, HplsqlParser::RuleExpr_atom);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2741);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 343, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2733);
      date_literal();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2734);
      timestamp_literal();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2735);
      bool_literal();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2736);
      ident();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2737);
      string();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2738);
      dec_number();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2739);
      int_number();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2740);
      null_const();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_intervalContext ------------------------------------------------------------------

HplsqlParser::Expr_intervalContext::Expr_intervalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Expr_intervalContext::T_INTERVAL() {
  return getToken(HplsqlParser::T_INTERVAL, 0);
}

HplsqlParser::ExprContext* HplsqlParser::Expr_intervalContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}

HplsqlParser::Interval_itemContext* HplsqlParser::Expr_intervalContext::interval_item() {
  return getRuleContext<HplsqlParser::Interval_itemContext>(0);
}


size_t HplsqlParser::Expr_intervalContext::getRuleIndex() const {
  return HplsqlParser::RuleExpr_interval;
}

void HplsqlParser::Expr_intervalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_interval(this);
}

void HplsqlParser::Expr_intervalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_interval(this);
}


antlrcpp::Any HplsqlParser::Expr_intervalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitExpr_interval(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Expr_intervalContext* HplsqlParser::expr_interval() {
  Expr_intervalContext *_localctx = _tracker.createInstance<Expr_intervalContext>(_ctx, getState());
  enterRule(_localctx, 384, HplsqlParser::RuleExpr_interval);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2743);
    match(HplsqlParser::T_INTERVAL);
    setState(2744);
    expr(0);
    setState(2745);
    interval_item();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Interval_itemContext ------------------------------------------------------------------

HplsqlParser::Interval_itemContext::Interval_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Interval_itemContext::T_DAY() {
  return getToken(HplsqlParser::T_DAY, 0);
}

tree::TerminalNode* HplsqlParser::Interval_itemContext::T_DAYS() {
  return getToken(HplsqlParser::T_DAYS, 0);
}

tree::TerminalNode* HplsqlParser::Interval_itemContext::T_MICROSECOND() {
  return getToken(HplsqlParser::T_MICROSECOND, 0);
}

tree::TerminalNode* HplsqlParser::Interval_itemContext::T_MICROSECONDS() {
  return getToken(HplsqlParser::T_MICROSECONDS, 0);
}

tree::TerminalNode* HplsqlParser::Interval_itemContext::T_SECOND() {
  return getToken(HplsqlParser::T_SECOND, 0);
}

tree::TerminalNode* HplsqlParser::Interval_itemContext::T_SECONDS() {
  return getToken(HplsqlParser::T_SECONDS, 0);
}


size_t HplsqlParser::Interval_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleInterval_item;
}

void HplsqlParser::Interval_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterval_item(this);
}

void HplsqlParser::Interval_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterval_item(this);
}


antlrcpp::Any HplsqlParser::Interval_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitInterval_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Interval_itemContext* HplsqlParser::interval_item() {
  Interval_itemContext *_localctx = _tracker.createInstance<Interval_itemContext>(_ctx, getState());
  enterRule(_localctx, 386, HplsqlParser::RuleInterval_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2747);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_DAY

    || _la == HplsqlParser::T_DAYS || _la == HplsqlParser::T_MICROSECOND

    || _la == HplsqlParser::T_MICROSECONDS || _la == HplsqlParser::T_SECOND

    || _la == HplsqlParser::T_SECONDS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_concatContext ------------------------------------------------------------------

HplsqlParser::Expr_concatContext::Expr_concatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HplsqlParser::Expr_concat_itemContext *> HplsqlParser::Expr_concatContext::expr_concat_item() {
  return getRuleContexts<HplsqlParser::Expr_concat_itemContext>();
}

HplsqlParser::Expr_concat_itemContext* HplsqlParser::Expr_concatContext::expr_concat_item(size_t i) {
  return getRuleContext<HplsqlParser::Expr_concat_itemContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Expr_concatContext::T_PIPE() {
  return getTokens(HplsqlParser::T_PIPE);
}

tree::TerminalNode* HplsqlParser::Expr_concatContext::T_PIPE(size_t i) {
  return getToken(HplsqlParser::T_PIPE, i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Expr_concatContext::T_CONCAT() {
  return getTokens(HplsqlParser::T_CONCAT);
}

tree::TerminalNode* HplsqlParser::Expr_concatContext::T_CONCAT(size_t i) {
  return getToken(HplsqlParser::T_CONCAT, i);
}


size_t HplsqlParser::Expr_concatContext::getRuleIndex() const {
  return HplsqlParser::RuleExpr_concat;
}

void HplsqlParser::Expr_concatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_concat(this);
}

void HplsqlParser::Expr_concatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_concat(this);
}


antlrcpp::Any HplsqlParser::Expr_concatContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitExpr_concat(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Expr_concatContext* HplsqlParser::expr_concat() {
  Expr_concatContext *_localctx = _tracker.createInstance<Expr_concatContext>(_ctx, getState());
  enterRule(_localctx, 388, HplsqlParser::RuleExpr_concat);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2749);
    expr_concat_item();
    setState(2750);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_CONCAT || _la == HplsqlParser::T_PIPE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2751);
    expr_concat_item();
    setState(2756);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 344, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2752);
        _la = _input->LA(1);
        if (!(_la == HplsqlParser::T_CONCAT || _la == HplsqlParser::T_PIPE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2753);
        expr_concat_item(); 
      }
      setState(2758);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 344, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_concat_itemContext ------------------------------------------------------------------

HplsqlParser::Expr_concat_itemContext::Expr_concat_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Expr_concat_itemContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

HplsqlParser::ExprContext* HplsqlParser::Expr_concat_itemContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}

tree::TerminalNode* HplsqlParser::Expr_concat_itemContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

HplsqlParser::Expr_caseContext* HplsqlParser::Expr_concat_itemContext::expr_case() {
  return getRuleContext<HplsqlParser::Expr_caseContext>(0);
}

HplsqlParser::Expr_agg_window_funcContext* HplsqlParser::Expr_concat_itemContext::expr_agg_window_func() {
  return getRuleContext<HplsqlParser::Expr_agg_window_funcContext>(0);
}

HplsqlParser::Expr_spec_funcContext* HplsqlParser::Expr_concat_itemContext::expr_spec_func() {
  return getRuleContext<HplsqlParser::Expr_spec_funcContext>(0);
}

HplsqlParser::Expr_funcContext* HplsqlParser::Expr_concat_itemContext::expr_func() {
  return getRuleContext<HplsqlParser::Expr_funcContext>(0);
}

HplsqlParser::Expr_atomContext* HplsqlParser::Expr_concat_itemContext::expr_atom() {
  return getRuleContext<HplsqlParser::Expr_atomContext>(0);
}


size_t HplsqlParser::Expr_concat_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleExpr_concat_item;
}

void HplsqlParser::Expr_concat_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_concat_item(this);
}

void HplsqlParser::Expr_concat_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_concat_item(this);
}


antlrcpp::Any HplsqlParser::Expr_concat_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitExpr_concat_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Expr_concat_itemContext* HplsqlParser::expr_concat_item() {
  Expr_concat_itemContext *_localctx = _tracker.createInstance<Expr_concat_itemContext>(_ctx, getState());
  enterRule(_localctx, 390, HplsqlParser::RuleExpr_concat_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2768);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 345, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2759);
      match(HplsqlParser::T_OPEN_P);
      setState(2760);
      expr(0);
      setState(2761);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2763);
      expr_case();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2764);
      expr_agg_window_func();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2765);
      expr_spec_func();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2766);
      expr_func();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2767);
      expr_atom();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_caseContext ------------------------------------------------------------------

HplsqlParser::Expr_caseContext::Expr_caseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Expr_case_simpleContext* HplsqlParser::Expr_caseContext::expr_case_simple() {
  return getRuleContext<HplsqlParser::Expr_case_simpleContext>(0);
}

HplsqlParser::Expr_case_searchedContext* HplsqlParser::Expr_caseContext::expr_case_searched() {
  return getRuleContext<HplsqlParser::Expr_case_searchedContext>(0);
}


size_t HplsqlParser::Expr_caseContext::getRuleIndex() const {
  return HplsqlParser::RuleExpr_case;
}

void HplsqlParser::Expr_caseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_case(this);
}

void HplsqlParser::Expr_caseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_case(this);
}


antlrcpp::Any HplsqlParser::Expr_caseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitExpr_case(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Expr_caseContext* HplsqlParser::expr_case() {
  Expr_caseContext *_localctx = _tracker.createInstance<Expr_caseContext>(_ctx, getState());
  enterRule(_localctx, 392, HplsqlParser::RuleExpr_case);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2772);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 346, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2770);
      expr_case_simple();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2771);
      expr_case_searched();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_case_simpleContext ------------------------------------------------------------------

HplsqlParser::Expr_case_simpleContext::Expr_case_simpleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Expr_case_simpleContext::T_CASE() {
  return getToken(HplsqlParser::T_CASE, 0);
}

std::vector<HplsqlParser::ExprContext *> HplsqlParser::Expr_case_simpleContext::expr() {
  return getRuleContexts<HplsqlParser::ExprContext>();
}

HplsqlParser::ExprContext* HplsqlParser::Expr_case_simpleContext::expr(size_t i) {
  return getRuleContext<HplsqlParser::ExprContext>(i);
}

tree::TerminalNode* HplsqlParser::Expr_case_simpleContext::T_END() {
  return getToken(HplsqlParser::T_END, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Expr_case_simpleContext::T_WHEN() {
  return getTokens(HplsqlParser::T_WHEN);
}

tree::TerminalNode* HplsqlParser::Expr_case_simpleContext::T_WHEN(size_t i) {
  return getToken(HplsqlParser::T_WHEN, i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Expr_case_simpleContext::T_THEN() {
  return getTokens(HplsqlParser::T_THEN);
}

tree::TerminalNode* HplsqlParser::Expr_case_simpleContext::T_THEN(size_t i) {
  return getToken(HplsqlParser::T_THEN, i);
}

tree::TerminalNode* HplsqlParser::Expr_case_simpleContext::T_ELSE() {
  return getToken(HplsqlParser::T_ELSE, 0);
}


size_t HplsqlParser::Expr_case_simpleContext::getRuleIndex() const {
  return HplsqlParser::RuleExpr_case_simple;
}

void HplsqlParser::Expr_case_simpleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_case_simple(this);
}

void HplsqlParser::Expr_case_simpleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_case_simple(this);
}


antlrcpp::Any HplsqlParser::Expr_case_simpleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitExpr_case_simple(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Expr_case_simpleContext* HplsqlParser::expr_case_simple() {
  Expr_case_simpleContext *_localctx = _tracker.createInstance<Expr_case_simpleContext>(_ctx, getState());
  enterRule(_localctx, 394, HplsqlParser::RuleExpr_case_simple);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2774);
    match(HplsqlParser::T_CASE);
    setState(2775);
    expr(0);
    setState(2781); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2776);
      match(HplsqlParser::T_WHEN);
      setState(2777);
      expr(0);
      setState(2778);
      match(HplsqlParser::T_THEN);
      setState(2779);
      expr(0);
      setState(2783); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == HplsqlParser::T_WHEN);
    setState(2787);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_ELSE) {
      setState(2785);
      match(HplsqlParser::T_ELSE);
      setState(2786);
      expr(0);
    }
    setState(2789);
    match(HplsqlParser::T_END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_case_searchedContext ------------------------------------------------------------------

HplsqlParser::Expr_case_searchedContext::Expr_case_searchedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Expr_case_searchedContext::T_CASE() {
  return getToken(HplsqlParser::T_CASE, 0);
}

tree::TerminalNode* HplsqlParser::Expr_case_searchedContext::T_END() {
  return getToken(HplsqlParser::T_END, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Expr_case_searchedContext::T_WHEN() {
  return getTokens(HplsqlParser::T_WHEN);
}

tree::TerminalNode* HplsqlParser::Expr_case_searchedContext::T_WHEN(size_t i) {
  return getToken(HplsqlParser::T_WHEN, i);
}

std::vector<HplsqlParser::Bool_exprContext *> HplsqlParser::Expr_case_searchedContext::bool_expr() {
  return getRuleContexts<HplsqlParser::Bool_exprContext>();
}

HplsqlParser::Bool_exprContext* HplsqlParser::Expr_case_searchedContext::bool_expr(size_t i) {
  return getRuleContext<HplsqlParser::Bool_exprContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Expr_case_searchedContext::T_THEN() {
  return getTokens(HplsqlParser::T_THEN);
}

tree::TerminalNode* HplsqlParser::Expr_case_searchedContext::T_THEN(size_t i) {
  return getToken(HplsqlParser::T_THEN, i);
}

std::vector<HplsqlParser::ExprContext *> HplsqlParser::Expr_case_searchedContext::expr() {
  return getRuleContexts<HplsqlParser::ExprContext>();
}

HplsqlParser::ExprContext* HplsqlParser::Expr_case_searchedContext::expr(size_t i) {
  return getRuleContext<HplsqlParser::ExprContext>(i);
}

tree::TerminalNode* HplsqlParser::Expr_case_searchedContext::T_ELSE() {
  return getToken(HplsqlParser::T_ELSE, 0);
}


size_t HplsqlParser::Expr_case_searchedContext::getRuleIndex() const {
  return HplsqlParser::RuleExpr_case_searched;
}

void HplsqlParser::Expr_case_searchedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_case_searched(this);
}

void HplsqlParser::Expr_case_searchedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_case_searched(this);
}


antlrcpp::Any HplsqlParser::Expr_case_searchedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitExpr_case_searched(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Expr_case_searchedContext* HplsqlParser::expr_case_searched() {
  Expr_case_searchedContext *_localctx = _tracker.createInstance<Expr_case_searchedContext>(_ctx, getState());
  enterRule(_localctx, 396, HplsqlParser::RuleExpr_case_searched);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2791);
    match(HplsqlParser::T_CASE);
    setState(2797); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2792);
      match(HplsqlParser::T_WHEN);
      setState(2793);
      bool_expr(0);
      setState(2794);
      match(HplsqlParser::T_THEN);
      setState(2795);
      expr(0);
      setState(2799); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == HplsqlParser::T_WHEN);
    setState(2803);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_ELSE) {
      setState(2801);
      match(HplsqlParser::T_ELSE);
      setState(2802);
      expr(0);
    }
    setState(2805);
    match(HplsqlParser::T_END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_cursor_attributeContext ------------------------------------------------------------------

HplsqlParser::Expr_cursor_attributeContext::Expr_cursor_attributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::IdentContext* HplsqlParser::Expr_cursor_attributeContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

tree::TerminalNode* HplsqlParser::Expr_cursor_attributeContext::T_ISOPEN() {
  return getToken(HplsqlParser::T_ISOPEN, 0);
}

tree::TerminalNode* HplsqlParser::Expr_cursor_attributeContext::T_FOUND() {
  return getToken(HplsqlParser::T_FOUND, 0);
}

tree::TerminalNode* HplsqlParser::Expr_cursor_attributeContext::T_NOTFOUND() {
  return getToken(HplsqlParser::T_NOTFOUND, 0);
}


size_t HplsqlParser::Expr_cursor_attributeContext::getRuleIndex() const {
  return HplsqlParser::RuleExpr_cursor_attribute;
}

void HplsqlParser::Expr_cursor_attributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_cursor_attribute(this);
}

void HplsqlParser::Expr_cursor_attributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_cursor_attribute(this);
}


antlrcpp::Any HplsqlParser::Expr_cursor_attributeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitExpr_cursor_attribute(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Expr_cursor_attributeContext* HplsqlParser::expr_cursor_attribute() {
  Expr_cursor_attributeContext *_localctx = _tracker.createInstance<Expr_cursor_attributeContext>(_ctx, getState());
  enterRule(_localctx, 398, HplsqlParser::RuleExpr_cursor_attribute);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2807);
    ident();
    setState(2808);
    match(HplsqlParser::T__2);
    setState(2809);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_FOUND

    || _la == HplsqlParser::T_ISOPEN || _la == HplsqlParser::T_NOTFOUND)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_agg_window_funcContext ------------------------------------------------------------------

HplsqlParser::Expr_agg_window_funcContext::Expr_agg_window_funcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Expr_agg_window_funcContext::T_AVG() {
  return getToken(HplsqlParser::T_AVG, 0);
}

tree::TerminalNode* HplsqlParser::Expr_agg_window_funcContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

std::vector<HplsqlParser::ExprContext *> HplsqlParser::Expr_agg_window_funcContext::expr() {
  return getRuleContexts<HplsqlParser::ExprContext>();
}

HplsqlParser::ExprContext* HplsqlParser::Expr_agg_window_funcContext::expr(size_t i) {
  return getRuleContext<HplsqlParser::ExprContext>(i);
}

tree::TerminalNode* HplsqlParser::Expr_agg_window_funcContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

HplsqlParser::Expr_func_all_distinctContext* HplsqlParser::Expr_agg_window_funcContext::expr_func_all_distinct() {
  return getRuleContext<HplsqlParser::Expr_func_all_distinctContext>(0);
}

HplsqlParser::Expr_func_over_clauseContext* HplsqlParser::Expr_agg_window_funcContext::expr_func_over_clause() {
  return getRuleContext<HplsqlParser::Expr_func_over_clauseContext>(0);
}

tree::TerminalNode* HplsqlParser::Expr_agg_window_funcContext::T_COUNT() {
  return getToken(HplsqlParser::T_COUNT, 0);
}

tree::TerminalNode* HplsqlParser::Expr_agg_window_funcContext::T_MUL() {
  return getToken(HplsqlParser::T_MUL, 0);
}

tree::TerminalNode* HplsqlParser::Expr_agg_window_funcContext::T_COUNT_BIG() {
  return getToken(HplsqlParser::T_COUNT_BIG, 0);
}

tree::TerminalNode* HplsqlParser::Expr_agg_window_funcContext::T_CUME_DIST() {
  return getToken(HplsqlParser::T_CUME_DIST, 0);
}

tree::TerminalNode* HplsqlParser::Expr_agg_window_funcContext::T_DENSE_RANK() {
  return getToken(HplsqlParser::T_DENSE_RANK, 0);
}

tree::TerminalNode* HplsqlParser::Expr_agg_window_funcContext::T_FIRST_VALUE() {
  return getToken(HplsqlParser::T_FIRST_VALUE, 0);
}

tree::TerminalNode* HplsqlParser::Expr_agg_window_funcContext::T_LAG() {
  return getToken(HplsqlParser::T_LAG, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Expr_agg_window_funcContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Expr_agg_window_funcContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}

tree::TerminalNode* HplsqlParser::Expr_agg_window_funcContext::T_LAST_VALUE() {
  return getToken(HplsqlParser::T_LAST_VALUE, 0);
}

tree::TerminalNode* HplsqlParser::Expr_agg_window_funcContext::T_LEAD() {
  return getToken(HplsqlParser::T_LEAD, 0);
}

tree::TerminalNode* HplsqlParser::Expr_agg_window_funcContext::T_MAX() {
  return getToken(HplsqlParser::T_MAX, 0);
}

tree::TerminalNode* HplsqlParser::Expr_agg_window_funcContext::T_MIN() {
  return getToken(HplsqlParser::T_MIN, 0);
}

tree::TerminalNode* HplsqlParser::Expr_agg_window_funcContext::T_RANK() {
  return getToken(HplsqlParser::T_RANK, 0);
}

tree::TerminalNode* HplsqlParser::Expr_agg_window_funcContext::T_ROW_NUMBER() {
  return getToken(HplsqlParser::T_ROW_NUMBER, 0);
}

tree::TerminalNode* HplsqlParser::Expr_agg_window_funcContext::T_STDEV() {
  return getToken(HplsqlParser::T_STDEV, 0);
}

tree::TerminalNode* HplsqlParser::Expr_agg_window_funcContext::T_SUM() {
  return getToken(HplsqlParser::T_SUM, 0);
}

tree::TerminalNode* HplsqlParser::Expr_agg_window_funcContext::T_VAR() {
  return getToken(HplsqlParser::T_VAR, 0);
}

tree::TerminalNode* HplsqlParser::Expr_agg_window_funcContext::T_VARIANCE() {
  return getToken(HplsqlParser::T_VARIANCE, 0);
}


size_t HplsqlParser::Expr_agg_window_funcContext::getRuleIndex() const {
  return HplsqlParser::RuleExpr_agg_window_func;
}

void HplsqlParser::Expr_agg_window_funcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_agg_window_func(this);
}

void HplsqlParser::Expr_agg_window_funcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_agg_window_func(this);
}


antlrcpp::Any HplsqlParser::Expr_agg_window_funcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitExpr_agg_window_func(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Expr_agg_window_funcContext* HplsqlParser::expr_agg_window_func() {
  Expr_agg_window_funcContext *_localctx = _tracker.createInstance<Expr_agg_window_funcContext>(_ctx, getState());
  enterRule(_localctx, 400, HplsqlParser::RuleExpr_agg_window_func);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2963);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T_AVG: {
        enterOuterAlt(_localctx, 1);
        setState(2811);
        match(HplsqlParser::T_AVG);
        setState(2812);
        match(HplsqlParser::T_OPEN_P);
        setState(2814);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 351, _ctx)) {
        case 1: {
          setState(2813);
          expr_func_all_distinct();
          break;
        }

        default:
          break;
        }
        setState(2816);
        expr(0);
        setState(2817);
        match(HplsqlParser::T_CLOSE_P);
        setState(2819);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 352, _ctx)) {
        case 1: {
          setState(2818);
          expr_func_over_clause();
          break;
        }

        default:
          break;
        }
        break;
      }

      case HplsqlParser::T_COUNT: {
        enterOuterAlt(_localctx, 2);
        setState(2821);
        match(HplsqlParser::T_COUNT);
        setState(2822);
        match(HplsqlParser::T_OPEN_P);
        setState(2828);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case HplsqlParser::T_ACTION:
          case HplsqlParser::T_ADD2:
          case HplsqlParser::T_ALL:
          case HplsqlParser::T_ALLOCATE:
          case HplsqlParser::T_ALTER:
          case HplsqlParser::T_AND:
          case HplsqlParser::T_ANSI_NULLS:
          case HplsqlParser::T_ANSI_PADDING:
          case HplsqlParser::T_AS:
          case HplsqlParser::T_ASC:
          case HplsqlParser::T_ASSOCIATE:
          case HplsqlParser::T_AT:
          case HplsqlParser::T_AUTO_INCREMENT:
          case HplsqlParser::T_AVG:
          case HplsqlParser::T_BATCHSIZE:
          case HplsqlParser::T_BEGIN:
          case HplsqlParser::T_BETWEEN:
          case HplsqlParser::T_BIGINT:
          case HplsqlParser::T_BINARY_DOUBLE:
          case HplsqlParser::T_BINARY_FLOAT:
          case HplsqlParser::T_BIT:
          case HplsqlParser::T_BODY:
          case HplsqlParser::T_BREAK:
          case HplsqlParser::T_BY:
          case HplsqlParser::T_BYTE:
          case HplsqlParser::T_CALL:
          case HplsqlParser::T_CALLER:
          case HplsqlParser::T_CASCADE:
          case HplsqlParser::T_CASE:
          case HplsqlParser::T_CASESPECIFIC:
          case HplsqlParser::T_CAST:
          case HplsqlParser::T_CHAR:
          case HplsqlParser::T_CHARACTER:
          case HplsqlParser::T_CHARSET:
          case HplsqlParser::T_CLIENT:
          case HplsqlParser::T_CLOSE:
          case HplsqlParser::T_CLUSTERED:
          case HplsqlParser::T_CMP:
          case HplsqlParser::T_COLLECT:
          case HplsqlParser::T_COLLECTION:
          case HplsqlParser::T_COLUMN:
          case HplsqlParser::T_COMMENT:
          case HplsqlParser::T_CONSTANT:
          case HplsqlParser::T_COMMIT:
          case HplsqlParser::T_COMPRESS:
          case HplsqlParser::T_CONCAT:
          case HplsqlParser::T_CONDITION:
          case HplsqlParser::T_CONSTRAINT:
          case HplsqlParser::T_CONTINUE:
          case HplsqlParser::T_COPY:
          case HplsqlParser::T_COUNT:
          case HplsqlParser::T_COUNT_BIG:
          case HplsqlParser::T_CREATE:
          case HplsqlParser::T_CREATION:
          case HplsqlParser::T_CREATOR:
          case HplsqlParser::T_CS:
          case HplsqlParser::T_CURRENT:
          case HplsqlParser::T_CURRENT_SCHEMA:
          case HplsqlParser::T_CURSOR:
          case HplsqlParser::T_DATABASE:
          case HplsqlParser::T_DATA:
          case HplsqlParser::T_DATE:
          case HplsqlParser::T_DATETIME:
          case HplsqlParser::T_DAY:
          case HplsqlParser::T_DAYS:
          case HplsqlParser::T_DEC:
          case HplsqlParser::T_DECIMAL:
          case HplsqlParser::T_DECLARE:
          case HplsqlParser::T_DEFAULT:
          case HplsqlParser::T_DEFERRED:
          case HplsqlParser::T_DEFINED:
          case HplsqlParser::T_DEFINER:
          case HplsqlParser::T_DEFINITION:
          case HplsqlParser::T_DELETE:
          case HplsqlParser::T_DELIMITED:
          case HplsqlParser::T_DELIMITER:
          case HplsqlParser::T_DESC:
          case HplsqlParser::T_DESCRIBE:
          case HplsqlParser::T_DIAGNOSTICS:
          case HplsqlParser::T_DIR:
          case HplsqlParser::T_DIRECTORY:
          case HplsqlParser::T_DISTINCT:
          case HplsqlParser::T_DISTRIBUTE:
          case HplsqlParser::T_DO:
          case HplsqlParser::T_DOUBLE:
          case HplsqlParser::T_DROP:
          case HplsqlParser::T_DYNAMIC:
          case HplsqlParser::T_ENABLE:
          case HplsqlParser::T_ENGINE:
          case HplsqlParser::T_ESCAPED:
          case HplsqlParser::T_EXCEPT:
          case HplsqlParser::T_EXEC:
          case HplsqlParser::T_EXECUTE:
          case HplsqlParser::T_EXCEPTION:
          case HplsqlParser::T_EXCLUSIVE:
          case HplsqlParser::T_EXISTS:
          case HplsqlParser::T_EXIT:
          case HplsqlParser::T_FALLBACK:
          case HplsqlParser::T_FALSE:
          case HplsqlParser::T_FETCH:
          case HplsqlParser::T_FIELDS:
          case HplsqlParser::T_FILE:
          case HplsqlParser::T_FILES:
          case HplsqlParser::T_FLOAT:
          case HplsqlParser::T_FOR:
          case HplsqlParser::T_FOREIGN:
          case HplsqlParser::T_FORMAT:
          case HplsqlParser::T_FOUND:
          case HplsqlParser::T_FROM:
          case HplsqlParser::T_FULL:
          case HplsqlParser::T_FUNCTION:
          case HplsqlParser::T_GET:
          case HplsqlParser::T_GLOBAL:
          case HplsqlParser::T_GO:
          case HplsqlParser::T_GRANT:
          case HplsqlParser::T_GROUP:
          case HplsqlParser::T_HANDLER:
          case HplsqlParser::T_HASH:
          case HplsqlParser::T_HAVING:
          case HplsqlParser::T_HDFS:
          case HplsqlParser::T_HIVE:
          case HplsqlParser::T_HOST:
          case HplsqlParser::T_IDENTITY:
          case HplsqlParser::T_IF:
          case HplsqlParser::T_IGNORE:
          case HplsqlParser::T_IMMEDIATE:
          case HplsqlParser::T_IN:
          case HplsqlParser::T_INCLUDE:
          case HplsqlParser::T_INDEX:
          case HplsqlParser::T_INITRANS:
          case HplsqlParser::T_INNER:
          case HplsqlParser::T_INOUT:
          case HplsqlParser::T_INSERT:
          case HplsqlParser::T_INT:
          case HplsqlParser::T_INT2:
          case HplsqlParser::T_INT4:
          case HplsqlParser::T_INT8:
          case HplsqlParser::T_INTEGER:
          case HplsqlParser::T_INTERSECT:
          case HplsqlParser::T_INTERVAL:
          case HplsqlParser::T_INTO:
          case HplsqlParser::T_INVOKER:
          case HplsqlParser::T_IS:
          case HplsqlParser::T_ISOPEN:
          case HplsqlParser::T_ITEMS:
          case HplsqlParser::T_JOIN:
          case HplsqlParser::T_KEEP:
          case HplsqlParser::T_KEY:
          case HplsqlParser::T_KEYS:
          case HplsqlParser::T_LANGUAGE:
          case HplsqlParser::T_LEAVE:
          case HplsqlParser::T_LEFT:
          case HplsqlParser::T_LIKE:
          case HplsqlParser::T_LIMIT:
          case HplsqlParser::T_LINES:
          case HplsqlParser::T_LOCAL:
          case HplsqlParser::T_LOCATION:
          case HplsqlParser::T_LOCATOR:
          case HplsqlParser::T_LOCATORS:
          case HplsqlParser::T_LOCKS:
          case HplsqlParser::T_LOG:
          case HplsqlParser::T_LOGGED:
          case HplsqlParser::T_LOGGING:
          case HplsqlParser::T_LOOP:
          case HplsqlParser::T_MAP:
          case HplsqlParser::T_MATCHED:
          case HplsqlParser::T_MAX:
          case HplsqlParser::T_MAXTRANS:
          case HplsqlParser::T_MERGE:
          case HplsqlParser::T_MESSAGE_TEXT:
          case HplsqlParser::T_MICROSECOND:
          case HplsqlParser::T_MICROSECONDS:
          case HplsqlParser::T_MIN:
          case HplsqlParser::T_MULTISET:
          case HplsqlParser::T_NCHAR:
          case HplsqlParser::T_NEW:
          case HplsqlParser::T_NVARCHAR:
          case HplsqlParser::T_NO:
          case HplsqlParser::T_NOCOUNT:
          case HplsqlParser::T_NOCOMPRESS:
          case HplsqlParser::T_NOLOGGING:
          case HplsqlParser::T_NONE:
          case HplsqlParser::T_NOT:
          case HplsqlParser::T_NOTFOUND:
          case HplsqlParser::T_NULL:
          case HplsqlParser::T_NUMERIC:
          case HplsqlParser::T_NUMBER:
          case HplsqlParser::T_OBJECT:
          case HplsqlParser::T_OFF:
          case HplsqlParser::T_ON:
          case HplsqlParser::T_ONLY:
          case HplsqlParser::T_OPEN:
          case HplsqlParser::T_OR:
          case HplsqlParser::T_ORDER:
          case HplsqlParser::T_OUT:
          case HplsqlParser::T_OUTER:
          case HplsqlParser::T_OVER:
          case HplsqlParser::T_OVERWRITE:
          case HplsqlParser::T_OWNER:
          case HplsqlParser::T_PACKAGE:
          case HplsqlParser::T_PARTITION:
          case HplsqlParser::T_PCTFREE:
          case HplsqlParser::T_PCTUSED:
          case HplsqlParser::T_PRECISION:
          case HplsqlParser::T_PRESERVE:
          case HplsqlParser::T_PRIMARY:
          case HplsqlParser::T_PRINT:
          case HplsqlParser::T_PROC:
          case HplsqlParser::T_PROCEDURE:
          case HplsqlParser::T_QUALIFY:
          case HplsqlParser::T_QUERY_BAND:
          case HplsqlParser::T_QUIT:
          case HplsqlParser::T_QUOTED_IDENTIFIER:
          case HplsqlParser::T_RAISE:
          case HplsqlParser::T_REAL:
          case HplsqlParser::T_REFERENCES:
          case HplsqlParser::T_REGEXP:
          case HplsqlParser::T_REPLACE:
          case HplsqlParser::T_RESIGNAL:
          case HplsqlParser::T_RESTRICT:
          case HplsqlParser::T_RESULT:
          case HplsqlParser::T_RESULT_SET_LOCATOR:
          case HplsqlParser::T_RETURN:
          case HplsqlParser::T_RETURNS:
          case HplsqlParser::T_REVERSE:
          case HplsqlParser::T_RIGHT:
          case HplsqlParser::T_RLIKE:
          case HplsqlParser::T_ROLE:
          case HplsqlParser::T_ROLLBACK:
          case HplsqlParser::T_ROW:
          case HplsqlParser::T_ROWS:
          case HplsqlParser::T_ROW_COUNT:
          case HplsqlParser::T_RR:
          case HplsqlParser::T_RS:
          case HplsqlParser::T_PWD:
          case HplsqlParser::T_TRIM:
          case HplsqlParser::T_SCHEMA:
          case HplsqlParser::T_SECOND:
          case HplsqlParser::T_SECONDS:
          case HplsqlParser::T_SECURITY:
          case HplsqlParser::T_SEGMENT:
          case HplsqlParser::T_SEL:
          case HplsqlParser::T_SELECT:
          case HplsqlParser::T_SET:
          case HplsqlParser::T_SESSION:
          case HplsqlParser::T_SESSIONS:
          case HplsqlParser::T_SETS:
          case HplsqlParser::T_SHARE:
          case HplsqlParser::T_SIGNAL:
          case HplsqlParser::T_SIMPLE_DOUBLE:
          case HplsqlParser::T_SIMPLE_FLOAT:
          case HplsqlParser::T_SMALLDATETIME:
          case HplsqlParser::T_SMALLINT:
          case HplsqlParser::T_SQL:
          case HplsqlParser::T_SQLEXCEPTION:
          case HplsqlParser::T_SQLINSERT:
          case HplsqlParser::T_SQLSTATE:
          case HplsqlParser::T_SQLWARNING:
          case HplsqlParser::T_STATS:
          case HplsqlParser::T_STATISTICS:
          case HplsqlParser::T_STEP:
          case HplsqlParser::T_STORAGE:
          case HplsqlParser::T_STORED:
          case HplsqlParser::T_STRING:
          case HplsqlParser::T_SUBDIR:
          case HplsqlParser::T_SUBSTRING:
          case HplsqlParser::T_SUM:
          case HplsqlParser::T_SYS_REFCURSOR:
          case HplsqlParser::T_TABLE:
          case HplsqlParser::T_TABLESPACE:
          case HplsqlParser::T_TEMPORARY:
          case HplsqlParser::T_TERMINATED:
          case HplsqlParser::T_TEXTIMAGE_ON:
          case HplsqlParser::T_THEN:
          case HplsqlParser::T_TIMESTAMP:
          case HplsqlParser::T_TITLE:
          case HplsqlParser::T_TO:
          case HplsqlParser::T_TOP:
          case HplsqlParser::T_TRANSACTION:
          case HplsqlParser::T_TRUE:
          case HplsqlParser::T_TRUNCATE:
          case HplsqlParser::T_UNIQUE:
          case HplsqlParser::T_UPDATE:
          case HplsqlParser::T_UR:
          case HplsqlParser::T_USE:
          case HplsqlParser::T_USING:
          case HplsqlParser::T_VALUE:
          case HplsqlParser::T_VALUES:
          case HplsqlParser::T_VAR:
          case HplsqlParser::T_VARCHAR:
          case HplsqlParser::T_VARCHAR2:
          case HplsqlParser::T_VARYING:
          case HplsqlParser::T_VOLATILE:
          case HplsqlParser::T_WHILE:
          case HplsqlParser::T_WITH:
          case HplsqlParser::T_WITHOUT:
          case HplsqlParser::T_WORK:
          case HplsqlParser::T_XACT_ABORT:
          case HplsqlParser::T_XML:
          case HplsqlParser::T_YES:
          case HplsqlParser::T_ACTIVITY_COUNT:
          case HplsqlParser::T_CUME_DIST:
          case HplsqlParser::T_CURRENT_DATE:
          case HplsqlParser::T_CURRENT_TIMESTAMP:
          case HplsqlParser::T_CURRENT_USER:
          case HplsqlParser::T_DENSE_RANK:
          case HplsqlParser::T_FIRST_VALUE:
          case HplsqlParser::T_LAG:
          case HplsqlParser::T_LAST_VALUE:
          case HplsqlParser::T_LEAD:
          case HplsqlParser::T_MAX_PART_STRING:
          case HplsqlParser::T_MIN_PART_STRING:
          case HplsqlParser::T_MAX_PART_INT:
          case HplsqlParser::T_MIN_PART_INT:
          case HplsqlParser::T_MAX_PART_DATE:
          case HplsqlParser::T_MIN_PART_DATE:
          case HplsqlParser::T_PART_COUNT:
          case HplsqlParser::T_PART_LOC:
          case HplsqlParser::T_RANK:
          case HplsqlParser::T_ROW_NUMBER:
          case HplsqlParser::T_STDEV:
          case HplsqlParser::T_SYSDATE:
          case HplsqlParser::T_VARIANCE:
          case HplsqlParser::T_USER:
          case HplsqlParser::T_ADD:
          case HplsqlParser::T_OPEN_P:
          case HplsqlParser::T_SUB:
          case HplsqlParser::L_ID:
          case HplsqlParser::L_S_STRING:
          case HplsqlParser::L_D_STRING:
          case HplsqlParser::L_INT:
          case HplsqlParser::L_DEC: {
            setState(2824);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 353, _ctx)) {
            case 1: {
              setState(2823);
              expr_func_all_distinct();
              break;
            }

            default:
              break;
            }
            setState(2826);
            expr(0);
            break;
          }

          case HplsqlParser::T_MUL: {
            setState(2827);
            match(HplsqlParser::T_MUL);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(2830);
        match(HplsqlParser::T_CLOSE_P);
        setState(2832);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 355, _ctx)) {
        case 1: {
          setState(2831);
          expr_func_over_clause();
          break;
        }

        default:
          break;
        }
        break;
      }

      case HplsqlParser::T_COUNT_BIG: {
        enterOuterAlt(_localctx, 3);
        setState(2834);
        match(HplsqlParser::T_COUNT_BIG);
        setState(2835);
        match(HplsqlParser::T_OPEN_P);
        setState(2841);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case HplsqlParser::T_ACTION:
          case HplsqlParser::T_ADD2:
          case HplsqlParser::T_ALL:
          case HplsqlParser::T_ALLOCATE:
          case HplsqlParser::T_ALTER:
          case HplsqlParser::T_AND:
          case HplsqlParser::T_ANSI_NULLS:
          case HplsqlParser::T_ANSI_PADDING:
          case HplsqlParser::T_AS:
          case HplsqlParser::T_ASC:
          case HplsqlParser::T_ASSOCIATE:
          case HplsqlParser::T_AT:
          case HplsqlParser::T_AUTO_INCREMENT:
          case HplsqlParser::T_AVG:
          case HplsqlParser::T_BATCHSIZE:
          case HplsqlParser::T_BEGIN:
          case HplsqlParser::T_BETWEEN:
          case HplsqlParser::T_BIGINT:
          case HplsqlParser::T_BINARY_DOUBLE:
          case HplsqlParser::T_BINARY_FLOAT:
          case HplsqlParser::T_BIT:
          case HplsqlParser::T_BODY:
          case HplsqlParser::T_BREAK:
          case HplsqlParser::T_BY:
          case HplsqlParser::T_BYTE:
          case HplsqlParser::T_CALL:
          case HplsqlParser::T_CALLER:
          case HplsqlParser::T_CASCADE:
          case HplsqlParser::T_CASE:
          case HplsqlParser::T_CASESPECIFIC:
          case HplsqlParser::T_CAST:
          case HplsqlParser::T_CHAR:
          case HplsqlParser::T_CHARACTER:
          case HplsqlParser::T_CHARSET:
          case HplsqlParser::T_CLIENT:
          case HplsqlParser::T_CLOSE:
          case HplsqlParser::T_CLUSTERED:
          case HplsqlParser::T_CMP:
          case HplsqlParser::T_COLLECT:
          case HplsqlParser::T_COLLECTION:
          case HplsqlParser::T_COLUMN:
          case HplsqlParser::T_COMMENT:
          case HplsqlParser::T_CONSTANT:
          case HplsqlParser::T_COMMIT:
          case HplsqlParser::T_COMPRESS:
          case HplsqlParser::T_CONCAT:
          case HplsqlParser::T_CONDITION:
          case HplsqlParser::T_CONSTRAINT:
          case HplsqlParser::T_CONTINUE:
          case HplsqlParser::T_COPY:
          case HplsqlParser::T_COUNT:
          case HplsqlParser::T_COUNT_BIG:
          case HplsqlParser::T_CREATE:
          case HplsqlParser::T_CREATION:
          case HplsqlParser::T_CREATOR:
          case HplsqlParser::T_CS:
          case HplsqlParser::T_CURRENT:
          case HplsqlParser::T_CURRENT_SCHEMA:
          case HplsqlParser::T_CURSOR:
          case HplsqlParser::T_DATABASE:
          case HplsqlParser::T_DATA:
          case HplsqlParser::T_DATE:
          case HplsqlParser::T_DATETIME:
          case HplsqlParser::T_DAY:
          case HplsqlParser::T_DAYS:
          case HplsqlParser::T_DEC:
          case HplsqlParser::T_DECIMAL:
          case HplsqlParser::T_DECLARE:
          case HplsqlParser::T_DEFAULT:
          case HplsqlParser::T_DEFERRED:
          case HplsqlParser::T_DEFINED:
          case HplsqlParser::T_DEFINER:
          case HplsqlParser::T_DEFINITION:
          case HplsqlParser::T_DELETE:
          case HplsqlParser::T_DELIMITED:
          case HplsqlParser::T_DELIMITER:
          case HplsqlParser::T_DESC:
          case HplsqlParser::T_DESCRIBE:
          case HplsqlParser::T_DIAGNOSTICS:
          case HplsqlParser::T_DIR:
          case HplsqlParser::T_DIRECTORY:
          case HplsqlParser::T_DISTINCT:
          case HplsqlParser::T_DISTRIBUTE:
          case HplsqlParser::T_DO:
          case HplsqlParser::T_DOUBLE:
          case HplsqlParser::T_DROP:
          case HplsqlParser::T_DYNAMIC:
          case HplsqlParser::T_ENABLE:
          case HplsqlParser::T_ENGINE:
          case HplsqlParser::T_ESCAPED:
          case HplsqlParser::T_EXCEPT:
          case HplsqlParser::T_EXEC:
          case HplsqlParser::T_EXECUTE:
          case HplsqlParser::T_EXCEPTION:
          case HplsqlParser::T_EXCLUSIVE:
          case HplsqlParser::T_EXISTS:
          case HplsqlParser::T_EXIT:
          case HplsqlParser::T_FALLBACK:
          case HplsqlParser::T_FALSE:
          case HplsqlParser::T_FETCH:
          case HplsqlParser::T_FIELDS:
          case HplsqlParser::T_FILE:
          case HplsqlParser::T_FILES:
          case HplsqlParser::T_FLOAT:
          case HplsqlParser::T_FOR:
          case HplsqlParser::T_FOREIGN:
          case HplsqlParser::T_FORMAT:
          case HplsqlParser::T_FOUND:
          case HplsqlParser::T_FROM:
          case HplsqlParser::T_FULL:
          case HplsqlParser::T_FUNCTION:
          case HplsqlParser::T_GET:
          case HplsqlParser::T_GLOBAL:
          case HplsqlParser::T_GO:
          case HplsqlParser::T_GRANT:
          case HplsqlParser::T_GROUP:
          case HplsqlParser::T_HANDLER:
          case HplsqlParser::T_HASH:
          case HplsqlParser::T_HAVING:
          case HplsqlParser::T_HDFS:
          case HplsqlParser::T_HIVE:
          case HplsqlParser::T_HOST:
          case HplsqlParser::T_IDENTITY:
          case HplsqlParser::T_IF:
          case HplsqlParser::T_IGNORE:
          case HplsqlParser::T_IMMEDIATE:
          case HplsqlParser::T_IN:
          case HplsqlParser::T_INCLUDE:
          case HplsqlParser::T_INDEX:
          case HplsqlParser::T_INITRANS:
          case HplsqlParser::T_INNER:
          case HplsqlParser::T_INOUT:
          case HplsqlParser::T_INSERT:
          case HplsqlParser::T_INT:
          case HplsqlParser::T_INT2:
          case HplsqlParser::T_INT4:
          case HplsqlParser::T_INT8:
          case HplsqlParser::T_INTEGER:
          case HplsqlParser::T_INTERSECT:
          case HplsqlParser::T_INTERVAL:
          case HplsqlParser::T_INTO:
          case HplsqlParser::T_INVOKER:
          case HplsqlParser::T_IS:
          case HplsqlParser::T_ISOPEN:
          case HplsqlParser::T_ITEMS:
          case HplsqlParser::T_JOIN:
          case HplsqlParser::T_KEEP:
          case HplsqlParser::T_KEY:
          case HplsqlParser::T_KEYS:
          case HplsqlParser::T_LANGUAGE:
          case HplsqlParser::T_LEAVE:
          case HplsqlParser::T_LEFT:
          case HplsqlParser::T_LIKE:
          case HplsqlParser::T_LIMIT:
          case HplsqlParser::T_LINES:
          case HplsqlParser::T_LOCAL:
          case HplsqlParser::T_LOCATION:
          case HplsqlParser::T_LOCATOR:
          case HplsqlParser::T_LOCATORS:
          case HplsqlParser::T_LOCKS:
          case HplsqlParser::T_LOG:
          case HplsqlParser::T_LOGGED:
          case HplsqlParser::T_LOGGING:
          case HplsqlParser::T_LOOP:
          case HplsqlParser::T_MAP:
          case HplsqlParser::T_MATCHED:
          case HplsqlParser::T_MAX:
          case HplsqlParser::T_MAXTRANS:
          case HplsqlParser::T_MERGE:
          case HplsqlParser::T_MESSAGE_TEXT:
          case HplsqlParser::T_MICROSECOND:
          case HplsqlParser::T_MICROSECONDS:
          case HplsqlParser::T_MIN:
          case HplsqlParser::T_MULTISET:
          case HplsqlParser::T_NCHAR:
          case HplsqlParser::T_NEW:
          case HplsqlParser::T_NVARCHAR:
          case HplsqlParser::T_NO:
          case HplsqlParser::T_NOCOUNT:
          case HplsqlParser::T_NOCOMPRESS:
          case HplsqlParser::T_NOLOGGING:
          case HplsqlParser::T_NONE:
          case HplsqlParser::T_NOT:
          case HplsqlParser::T_NOTFOUND:
          case HplsqlParser::T_NULL:
          case HplsqlParser::T_NUMERIC:
          case HplsqlParser::T_NUMBER:
          case HplsqlParser::T_OBJECT:
          case HplsqlParser::T_OFF:
          case HplsqlParser::T_ON:
          case HplsqlParser::T_ONLY:
          case HplsqlParser::T_OPEN:
          case HplsqlParser::T_OR:
          case HplsqlParser::T_ORDER:
          case HplsqlParser::T_OUT:
          case HplsqlParser::T_OUTER:
          case HplsqlParser::T_OVER:
          case HplsqlParser::T_OVERWRITE:
          case HplsqlParser::T_OWNER:
          case HplsqlParser::T_PACKAGE:
          case HplsqlParser::T_PARTITION:
          case HplsqlParser::T_PCTFREE:
          case HplsqlParser::T_PCTUSED:
          case HplsqlParser::T_PRECISION:
          case HplsqlParser::T_PRESERVE:
          case HplsqlParser::T_PRIMARY:
          case HplsqlParser::T_PRINT:
          case HplsqlParser::T_PROC:
          case HplsqlParser::T_PROCEDURE:
          case HplsqlParser::T_QUALIFY:
          case HplsqlParser::T_QUERY_BAND:
          case HplsqlParser::T_QUIT:
          case HplsqlParser::T_QUOTED_IDENTIFIER:
          case HplsqlParser::T_RAISE:
          case HplsqlParser::T_REAL:
          case HplsqlParser::T_REFERENCES:
          case HplsqlParser::T_REGEXP:
          case HplsqlParser::T_REPLACE:
          case HplsqlParser::T_RESIGNAL:
          case HplsqlParser::T_RESTRICT:
          case HplsqlParser::T_RESULT:
          case HplsqlParser::T_RESULT_SET_LOCATOR:
          case HplsqlParser::T_RETURN:
          case HplsqlParser::T_RETURNS:
          case HplsqlParser::T_REVERSE:
          case HplsqlParser::T_RIGHT:
          case HplsqlParser::T_RLIKE:
          case HplsqlParser::T_ROLE:
          case HplsqlParser::T_ROLLBACK:
          case HplsqlParser::T_ROW:
          case HplsqlParser::T_ROWS:
          case HplsqlParser::T_ROW_COUNT:
          case HplsqlParser::T_RR:
          case HplsqlParser::T_RS:
          case HplsqlParser::T_PWD:
          case HplsqlParser::T_TRIM:
          case HplsqlParser::T_SCHEMA:
          case HplsqlParser::T_SECOND:
          case HplsqlParser::T_SECONDS:
          case HplsqlParser::T_SECURITY:
          case HplsqlParser::T_SEGMENT:
          case HplsqlParser::T_SEL:
          case HplsqlParser::T_SELECT:
          case HplsqlParser::T_SET:
          case HplsqlParser::T_SESSION:
          case HplsqlParser::T_SESSIONS:
          case HplsqlParser::T_SETS:
          case HplsqlParser::T_SHARE:
          case HplsqlParser::T_SIGNAL:
          case HplsqlParser::T_SIMPLE_DOUBLE:
          case HplsqlParser::T_SIMPLE_FLOAT:
          case HplsqlParser::T_SMALLDATETIME:
          case HplsqlParser::T_SMALLINT:
          case HplsqlParser::T_SQL:
          case HplsqlParser::T_SQLEXCEPTION:
          case HplsqlParser::T_SQLINSERT:
          case HplsqlParser::T_SQLSTATE:
          case HplsqlParser::T_SQLWARNING:
          case HplsqlParser::T_STATS:
          case HplsqlParser::T_STATISTICS:
          case HplsqlParser::T_STEP:
          case HplsqlParser::T_STORAGE:
          case HplsqlParser::T_STORED:
          case HplsqlParser::T_STRING:
          case HplsqlParser::T_SUBDIR:
          case HplsqlParser::T_SUBSTRING:
          case HplsqlParser::T_SUM:
          case HplsqlParser::T_SYS_REFCURSOR:
          case HplsqlParser::T_TABLE:
          case HplsqlParser::T_TABLESPACE:
          case HplsqlParser::T_TEMPORARY:
          case HplsqlParser::T_TERMINATED:
          case HplsqlParser::T_TEXTIMAGE_ON:
          case HplsqlParser::T_THEN:
          case HplsqlParser::T_TIMESTAMP:
          case HplsqlParser::T_TITLE:
          case HplsqlParser::T_TO:
          case HplsqlParser::T_TOP:
          case HplsqlParser::T_TRANSACTION:
          case HplsqlParser::T_TRUE:
          case HplsqlParser::T_TRUNCATE:
          case HplsqlParser::T_UNIQUE:
          case HplsqlParser::T_UPDATE:
          case HplsqlParser::T_UR:
          case HplsqlParser::T_USE:
          case HplsqlParser::T_USING:
          case HplsqlParser::T_VALUE:
          case HplsqlParser::T_VALUES:
          case HplsqlParser::T_VAR:
          case HplsqlParser::T_VARCHAR:
          case HplsqlParser::T_VARCHAR2:
          case HplsqlParser::T_VARYING:
          case HplsqlParser::T_VOLATILE:
          case HplsqlParser::T_WHILE:
          case HplsqlParser::T_WITH:
          case HplsqlParser::T_WITHOUT:
          case HplsqlParser::T_WORK:
          case HplsqlParser::T_XACT_ABORT:
          case HplsqlParser::T_XML:
          case HplsqlParser::T_YES:
          case HplsqlParser::T_ACTIVITY_COUNT:
          case HplsqlParser::T_CUME_DIST:
          case HplsqlParser::T_CURRENT_DATE:
          case HplsqlParser::T_CURRENT_TIMESTAMP:
          case HplsqlParser::T_CURRENT_USER:
          case HplsqlParser::T_DENSE_RANK:
          case HplsqlParser::T_FIRST_VALUE:
          case HplsqlParser::T_LAG:
          case HplsqlParser::T_LAST_VALUE:
          case HplsqlParser::T_LEAD:
          case HplsqlParser::T_MAX_PART_STRING:
          case HplsqlParser::T_MIN_PART_STRING:
          case HplsqlParser::T_MAX_PART_INT:
          case HplsqlParser::T_MIN_PART_INT:
          case HplsqlParser::T_MAX_PART_DATE:
          case HplsqlParser::T_MIN_PART_DATE:
          case HplsqlParser::T_PART_COUNT:
          case HplsqlParser::T_PART_LOC:
          case HplsqlParser::T_RANK:
          case HplsqlParser::T_ROW_NUMBER:
          case HplsqlParser::T_STDEV:
          case HplsqlParser::T_SYSDATE:
          case HplsqlParser::T_VARIANCE:
          case HplsqlParser::T_USER:
          case HplsqlParser::T_ADD:
          case HplsqlParser::T_OPEN_P:
          case HplsqlParser::T_SUB:
          case HplsqlParser::L_ID:
          case HplsqlParser::L_S_STRING:
          case HplsqlParser::L_D_STRING:
          case HplsqlParser::L_INT:
          case HplsqlParser::L_DEC: {
            setState(2837);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 356, _ctx)) {
            case 1: {
              setState(2836);
              expr_func_all_distinct();
              break;
            }

            default:
              break;
            }
            setState(2839);
            expr(0);
            break;
          }

          case HplsqlParser::T_MUL: {
            setState(2840);
            match(HplsqlParser::T_MUL);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(2843);
        match(HplsqlParser::T_CLOSE_P);
        setState(2845);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 358, _ctx)) {
        case 1: {
          setState(2844);
          expr_func_over_clause();
          break;
        }

        default:
          break;
        }
        break;
      }

      case HplsqlParser::T_CUME_DIST: {
        enterOuterAlt(_localctx, 4);
        setState(2847);
        match(HplsqlParser::T_CUME_DIST);
        setState(2848);
        match(HplsqlParser::T_OPEN_P);
        setState(2849);
        match(HplsqlParser::T_CLOSE_P);
        setState(2850);
        expr_func_over_clause();
        break;
      }

      case HplsqlParser::T_DENSE_RANK: {
        enterOuterAlt(_localctx, 5);
        setState(2851);
        match(HplsqlParser::T_DENSE_RANK);
        setState(2852);
        match(HplsqlParser::T_OPEN_P);
        setState(2853);
        match(HplsqlParser::T_CLOSE_P);
        setState(2854);
        expr_func_over_clause();
        break;
      }

      case HplsqlParser::T_FIRST_VALUE: {
        enterOuterAlt(_localctx, 6);
        setState(2855);
        match(HplsqlParser::T_FIRST_VALUE);
        setState(2856);
        match(HplsqlParser::T_OPEN_P);
        setState(2857);
        expr(0);
        setState(2858);
        match(HplsqlParser::T_CLOSE_P);
        setState(2859);
        expr_func_over_clause();
        break;
      }

      case HplsqlParser::T_LAG: {
        enterOuterAlt(_localctx, 7);
        setState(2861);
        match(HplsqlParser::T_LAG);
        setState(2862);
        match(HplsqlParser::T_OPEN_P);
        setState(2863);
        expr(0);
        setState(2870);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_COMMA) {
          setState(2864);
          match(HplsqlParser::T_COMMA);
          setState(2865);
          expr(0);
          setState(2868);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == HplsqlParser::T_COMMA) {
            setState(2866);
            match(HplsqlParser::T_COMMA);
            setState(2867);
            expr(0);
          }
        }
        setState(2872);
        match(HplsqlParser::T_CLOSE_P);
        setState(2873);
        expr_func_over_clause();
        break;
      }

      case HplsqlParser::T_LAST_VALUE: {
        enterOuterAlt(_localctx, 8);
        setState(2875);
        match(HplsqlParser::T_LAST_VALUE);
        setState(2876);
        match(HplsqlParser::T_OPEN_P);
        setState(2877);
        expr(0);
        setState(2878);
        match(HplsqlParser::T_CLOSE_P);
        setState(2879);
        expr_func_over_clause();
        break;
      }

      case HplsqlParser::T_LEAD: {
        enterOuterAlt(_localctx, 9);
        setState(2881);
        match(HplsqlParser::T_LEAD);
        setState(2882);
        match(HplsqlParser::T_OPEN_P);
        setState(2883);
        expr(0);
        setState(2890);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == HplsqlParser::T_COMMA) {
          setState(2884);
          match(HplsqlParser::T_COMMA);
          setState(2885);
          expr(0);
          setState(2888);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == HplsqlParser::T_COMMA) {
            setState(2886);
            match(HplsqlParser::T_COMMA);
            setState(2887);
            expr(0);
          }
        }
        setState(2892);
        match(HplsqlParser::T_CLOSE_P);
        setState(2893);
        expr_func_over_clause();
        break;
      }

      case HplsqlParser::T_MAX: {
        enterOuterAlt(_localctx, 10);
        setState(2895);
        match(HplsqlParser::T_MAX);
        setState(2896);
        match(HplsqlParser::T_OPEN_P);
        setState(2898);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 363, _ctx)) {
        case 1: {
          setState(2897);
          expr_func_all_distinct();
          break;
        }

        default:
          break;
        }
        setState(2900);
        expr(0);
        setState(2901);
        match(HplsqlParser::T_CLOSE_P);
        setState(2903);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 364, _ctx)) {
        case 1: {
          setState(2902);
          expr_func_over_clause();
          break;
        }

        default:
          break;
        }
        break;
      }

      case HplsqlParser::T_MIN: {
        enterOuterAlt(_localctx, 11);
        setState(2905);
        match(HplsqlParser::T_MIN);
        setState(2906);
        match(HplsqlParser::T_OPEN_P);
        setState(2908);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 365, _ctx)) {
        case 1: {
          setState(2907);
          expr_func_all_distinct();
          break;
        }

        default:
          break;
        }
        setState(2910);
        expr(0);
        setState(2911);
        match(HplsqlParser::T_CLOSE_P);
        setState(2913);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 366, _ctx)) {
        case 1: {
          setState(2912);
          expr_func_over_clause();
          break;
        }

        default:
          break;
        }
        break;
      }

      case HplsqlParser::T_RANK: {
        enterOuterAlt(_localctx, 12);
        setState(2915);
        match(HplsqlParser::T_RANK);
        setState(2916);
        match(HplsqlParser::T_OPEN_P);
        setState(2917);
        match(HplsqlParser::T_CLOSE_P);
        setState(2918);
        expr_func_over_clause();
        break;
      }

      case HplsqlParser::T_ROW_NUMBER: {
        enterOuterAlt(_localctx, 13);
        setState(2919);
        match(HplsqlParser::T_ROW_NUMBER);
        setState(2920);
        match(HplsqlParser::T_OPEN_P);
        setState(2921);
        match(HplsqlParser::T_CLOSE_P);
        setState(2922);
        expr_func_over_clause();
        break;
      }

      case HplsqlParser::T_STDEV: {
        enterOuterAlt(_localctx, 14);
        setState(2923);
        match(HplsqlParser::T_STDEV);
        setState(2924);
        match(HplsqlParser::T_OPEN_P);
        setState(2926);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 367, _ctx)) {
        case 1: {
          setState(2925);
          expr_func_all_distinct();
          break;
        }

        default:
          break;
        }
        setState(2928);
        expr(0);
        setState(2929);
        match(HplsqlParser::T_CLOSE_P);
        setState(2931);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 368, _ctx)) {
        case 1: {
          setState(2930);
          expr_func_over_clause();
          break;
        }

        default:
          break;
        }
        break;
      }

      case HplsqlParser::T_SUM: {
        enterOuterAlt(_localctx, 15);
        setState(2933);
        match(HplsqlParser::T_SUM);
        setState(2934);
        match(HplsqlParser::T_OPEN_P);
        setState(2936);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 369, _ctx)) {
        case 1: {
          setState(2935);
          expr_func_all_distinct();
          break;
        }

        default:
          break;
        }
        setState(2938);
        expr(0);
        setState(2939);
        match(HplsqlParser::T_CLOSE_P);
        setState(2941);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 370, _ctx)) {
        case 1: {
          setState(2940);
          expr_func_over_clause();
          break;
        }

        default:
          break;
        }
        break;
      }

      case HplsqlParser::T_VAR: {
        enterOuterAlt(_localctx, 16);
        setState(2943);
        match(HplsqlParser::T_VAR);
        setState(2944);
        match(HplsqlParser::T_OPEN_P);
        setState(2946);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 371, _ctx)) {
        case 1: {
          setState(2945);
          expr_func_all_distinct();
          break;
        }

        default:
          break;
        }
        setState(2948);
        expr(0);
        setState(2949);
        match(HplsqlParser::T_CLOSE_P);
        setState(2951);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 372, _ctx)) {
        case 1: {
          setState(2950);
          expr_func_over_clause();
          break;
        }

        default:
          break;
        }
        break;
      }

      case HplsqlParser::T_VARIANCE: {
        enterOuterAlt(_localctx, 17);
        setState(2953);
        match(HplsqlParser::T_VARIANCE);
        setState(2954);
        match(HplsqlParser::T_OPEN_P);
        setState(2956);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 373, _ctx)) {
        case 1: {
          setState(2955);
          expr_func_all_distinct();
          break;
        }

        default:
          break;
        }
        setState(2958);
        expr(0);
        setState(2959);
        match(HplsqlParser::T_CLOSE_P);
        setState(2961);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 374, _ctx)) {
        case 1: {
          setState(2960);
          expr_func_over_clause();
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_func_all_distinctContext ------------------------------------------------------------------

HplsqlParser::Expr_func_all_distinctContext::Expr_func_all_distinctContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Expr_func_all_distinctContext::T_ALL() {
  return getToken(HplsqlParser::T_ALL, 0);
}

tree::TerminalNode* HplsqlParser::Expr_func_all_distinctContext::T_DISTINCT() {
  return getToken(HplsqlParser::T_DISTINCT, 0);
}


size_t HplsqlParser::Expr_func_all_distinctContext::getRuleIndex() const {
  return HplsqlParser::RuleExpr_func_all_distinct;
}

void HplsqlParser::Expr_func_all_distinctContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_func_all_distinct(this);
}

void HplsqlParser::Expr_func_all_distinctContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_func_all_distinct(this);
}


antlrcpp::Any HplsqlParser::Expr_func_all_distinctContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitExpr_func_all_distinct(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Expr_func_all_distinctContext* HplsqlParser::expr_func_all_distinct() {
  Expr_func_all_distinctContext *_localctx = _tracker.createInstance<Expr_func_all_distinctContext>(_ctx, getState());
  enterRule(_localctx, 402, HplsqlParser::RuleExpr_func_all_distinct);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2965);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_ALL || _la == HplsqlParser::T_DISTINCT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_func_over_clauseContext ------------------------------------------------------------------

HplsqlParser::Expr_func_over_clauseContext::Expr_func_over_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Expr_func_over_clauseContext::T_OVER() {
  return getToken(HplsqlParser::T_OVER, 0);
}

tree::TerminalNode* HplsqlParser::Expr_func_over_clauseContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

tree::TerminalNode* HplsqlParser::Expr_func_over_clauseContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

HplsqlParser::Expr_func_partition_by_clauseContext* HplsqlParser::Expr_func_over_clauseContext::expr_func_partition_by_clause() {
  return getRuleContext<HplsqlParser::Expr_func_partition_by_clauseContext>(0);
}

HplsqlParser::Order_by_clauseContext* HplsqlParser::Expr_func_over_clauseContext::order_by_clause() {
  return getRuleContext<HplsqlParser::Order_by_clauseContext>(0);
}


size_t HplsqlParser::Expr_func_over_clauseContext::getRuleIndex() const {
  return HplsqlParser::RuleExpr_func_over_clause;
}

void HplsqlParser::Expr_func_over_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_func_over_clause(this);
}

void HplsqlParser::Expr_func_over_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_func_over_clause(this);
}


antlrcpp::Any HplsqlParser::Expr_func_over_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitExpr_func_over_clause(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Expr_func_over_clauseContext* HplsqlParser::expr_func_over_clause() {
  Expr_func_over_clauseContext *_localctx = _tracker.createInstance<Expr_func_over_clauseContext>(_ctx, getState());
  enterRule(_localctx, 404, HplsqlParser::RuleExpr_func_over_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2967);
    match(HplsqlParser::T_OVER);
    setState(2968);
    match(HplsqlParser::T_OPEN_P);
    setState(2970);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_PARTITION) {
      setState(2969);
      expr_func_partition_by_clause();
    }
    setState(2973);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_ORDER) {
      setState(2972);
      order_by_clause();
    }
    setState(2975);
    match(HplsqlParser::T_CLOSE_P);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_func_partition_by_clauseContext ------------------------------------------------------------------

HplsqlParser::Expr_func_partition_by_clauseContext::Expr_func_partition_by_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Expr_func_partition_by_clauseContext::T_PARTITION() {
  return getToken(HplsqlParser::T_PARTITION, 0);
}

tree::TerminalNode* HplsqlParser::Expr_func_partition_by_clauseContext::T_BY() {
  return getToken(HplsqlParser::T_BY, 0);
}

std::vector<HplsqlParser::ExprContext *> HplsqlParser::Expr_func_partition_by_clauseContext::expr() {
  return getRuleContexts<HplsqlParser::ExprContext>();
}

HplsqlParser::ExprContext* HplsqlParser::Expr_func_partition_by_clauseContext::expr(size_t i) {
  return getRuleContext<HplsqlParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Expr_func_partition_by_clauseContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Expr_func_partition_by_clauseContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Expr_func_partition_by_clauseContext::getRuleIndex() const {
  return HplsqlParser::RuleExpr_func_partition_by_clause;
}

void HplsqlParser::Expr_func_partition_by_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_func_partition_by_clause(this);
}

void HplsqlParser::Expr_func_partition_by_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_func_partition_by_clause(this);
}


antlrcpp::Any HplsqlParser::Expr_func_partition_by_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitExpr_func_partition_by_clause(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Expr_func_partition_by_clauseContext* HplsqlParser::expr_func_partition_by_clause() {
  Expr_func_partition_by_clauseContext *_localctx = _tracker.createInstance<Expr_func_partition_by_clauseContext>(_ctx, getState());
  enterRule(_localctx, 406, HplsqlParser::RuleExpr_func_partition_by_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2977);
    match(HplsqlParser::T_PARTITION);
    setState(2978);
    match(HplsqlParser::T_BY);
    setState(2979);
    expr(0);
    setState(2984);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == HplsqlParser::T_COMMA) {
      setState(2980);
      match(HplsqlParser::T_COMMA);
      setState(2981);
      expr(0);
      setState(2986);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_spec_funcContext ------------------------------------------------------------------

HplsqlParser::Expr_spec_funcContext::Expr_spec_funcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_ACTIVITY_COUNT() {
  return getToken(HplsqlParser::T_ACTIVITY_COUNT, 0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_CAST() {
  return getToken(HplsqlParser::T_CAST, 0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

std::vector<HplsqlParser::ExprContext *> HplsqlParser::Expr_spec_funcContext::expr() {
  return getRuleContexts<HplsqlParser::ExprContext>();
}

HplsqlParser::ExprContext* HplsqlParser::Expr_spec_funcContext::expr(size_t i) {
  return getRuleContext<HplsqlParser::ExprContext>(i);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_AS() {
  return getToken(HplsqlParser::T_AS, 0);
}

HplsqlParser::DtypeContext* HplsqlParser::Expr_spec_funcContext::dtype() {
  return getRuleContext<HplsqlParser::DtypeContext>(0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

HplsqlParser::Dtype_lenContext* HplsqlParser::Expr_spec_funcContext::dtype_len() {
  return getRuleContext<HplsqlParser::Dtype_lenContext>(0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_COUNT() {
  return getToken(HplsqlParser::T_COUNT, 0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_MUL() {
  return getToken(HplsqlParser::T_MUL, 0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_CURRENT_DATE() {
  return getToken(HplsqlParser::T_CURRENT_DATE, 0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_CURRENT() {
  return getToken(HplsqlParser::T_CURRENT, 0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_DATE() {
  return getToken(HplsqlParser::T_DATE, 0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_CURRENT_TIMESTAMP() {
  return getToken(HplsqlParser::T_CURRENT_TIMESTAMP, 0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_TIMESTAMP() {
  return getToken(HplsqlParser::T_TIMESTAMP, 0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_CURRENT_USER() {
  return getToken(HplsqlParser::T_CURRENT_USER, 0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_USER() {
  return getToken(HplsqlParser::T_USER, 0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_MAX_PART_STRING() {
  return getToken(HplsqlParser::T_MAX_PART_STRING, 0);
}

std::vector<tree::TerminalNode *> HplsqlParser::Expr_spec_funcContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Expr_spec_funcContext::T_EQUAL() {
  return getTokens(HplsqlParser::T_EQUAL);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_EQUAL(size_t i) {
  return getToken(HplsqlParser::T_EQUAL, i);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_MIN_PART_STRING() {
  return getToken(HplsqlParser::T_MIN_PART_STRING, 0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_MAX_PART_INT() {
  return getToken(HplsqlParser::T_MAX_PART_INT, 0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_MIN_PART_INT() {
  return getToken(HplsqlParser::T_MIN_PART_INT, 0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_MAX_PART_DATE() {
  return getToken(HplsqlParser::T_MAX_PART_DATE, 0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_MIN_PART_DATE() {
  return getToken(HplsqlParser::T_MIN_PART_DATE, 0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_PART_COUNT() {
  return getToken(HplsqlParser::T_PART_COUNT, 0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_PART_LOC() {
  return getToken(HplsqlParser::T_PART_LOC, 0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_TRIM() {
  return getToken(HplsqlParser::T_TRIM, 0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_SUBSTRING() {
  return getToken(HplsqlParser::T_SUBSTRING, 0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_FROM() {
  return getToken(HplsqlParser::T_FROM, 0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_FOR() {
  return getToken(HplsqlParser::T_FOR, 0);
}

tree::TerminalNode* HplsqlParser::Expr_spec_funcContext::T_SYSDATE() {
  return getToken(HplsqlParser::T_SYSDATE, 0);
}


size_t HplsqlParser::Expr_spec_funcContext::getRuleIndex() const {
  return HplsqlParser::RuleExpr_spec_func;
}

void HplsqlParser::Expr_spec_funcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_spec_func(this);
}

void HplsqlParser::Expr_spec_funcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_spec_func(this);
}


antlrcpp::Any HplsqlParser::Expr_spec_funcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitExpr_spec_func(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Expr_spec_funcContext* HplsqlParser::expr_spec_func() {
  Expr_spec_funcContext *_localctx = _tracker.createInstance<Expr_spec_funcContext>(_ctx, getState());
  enterRule(_localctx, 408, HplsqlParser::RuleExpr_spec_func);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(3187);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 399, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2987);
      match(HplsqlParser::T_ACTIVITY_COUNT);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2988);
      match(HplsqlParser::T_CAST);
      setState(2989);
      match(HplsqlParser::T_OPEN_P);
      setState(2990);
      expr(0);
      setState(2991);
      match(HplsqlParser::T_AS);
      setState(2992);
      dtype();
      setState(2994);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HplsqlParser::T_OPEN_P) {
        setState(2993);
        dtype_len();
      }
      setState(2996);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2998);
      match(HplsqlParser::T_COUNT);
      setState(2999);
      match(HplsqlParser::T_OPEN_P);
      setState(3002);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case HplsqlParser::T_ACTION:
        case HplsqlParser::T_ADD2:
        case HplsqlParser::T_ALL:
        case HplsqlParser::T_ALLOCATE:
        case HplsqlParser::T_ALTER:
        case HplsqlParser::T_AND:
        case HplsqlParser::T_ANSI_NULLS:
        case HplsqlParser::T_ANSI_PADDING:
        case HplsqlParser::T_AS:
        case HplsqlParser::T_ASC:
        case HplsqlParser::T_ASSOCIATE:
        case HplsqlParser::T_AT:
        case HplsqlParser::T_AUTO_INCREMENT:
        case HplsqlParser::T_AVG:
        case HplsqlParser::T_BATCHSIZE:
        case HplsqlParser::T_BEGIN:
        case HplsqlParser::T_BETWEEN:
        case HplsqlParser::T_BIGINT:
        case HplsqlParser::T_BINARY_DOUBLE:
        case HplsqlParser::T_BINARY_FLOAT:
        case HplsqlParser::T_BIT:
        case HplsqlParser::T_BODY:
        case HplsqlParser::T_BREAK:
        case HplsqlParser::T_BY:
        case HplsqlParser::T_BYTE:
        case HplsqlParser::T_CALL:
        case HplsqlParser::T_CALLER:
        case HplsqlParser::T_CASCADE:
        case HplsqlParser::T_CASE:
        case HplsqlParser::T_CASESPECIFIC:
        case HplsqlParser::T_CAST:
        case HplsqlParser::T_CHAR:
        case HplsqlParser::T_CHARACTER:
        case HplsqlParser::T_CHARSET:
        case HplsqlParser::T_CLIENT:
        case HplsqlParser::T_CLOSE:
        case HplsqlParser::T_CLUSTERED:
        case HplsqlParser::T_CMP:
        case HplsqlParser::T_COLLECT:
        case HplsqlParser::T_COLLECTION:
        case HplsqlParser::T_COLUMN:
        case HplsqlParser::T_COMMENT:
        case HplsqlParser::T_CONSTANT:
        case HplsqlParser::T_COMMIT:
        case HplsqlParser::T_COMPRESS:
        case HplsqlParser::T_CONCAT:
        case HplsqlParser::T_CONDITION:
        case HplsqlParser::T_CONSTRAINT:
        case HplsqlParser::T_CONTINUE:
        case HplsqlParser::T_COPY:
        case HplsqlParser::T_COUNT:
        case HplsqlParser::T_COUNT_BIG:
        case HplsqlParser::T_CREATE:
        case HplsqlParser::T_CREATION:
        case HplsqlParser::T_CREATOR:
        case HplsqlParser::T_CS:
        case HplsqlParser::T_CURRENT:
        case HplsqlParser::T_CURRENT_SCHEMA:
        case HplsqlParser::T_CURSOR:
        case HplsqlParser::T_DATABASE:
        case HplsqlParser::T_DATA:
        case HplsqlParser::T_DATE:
        case HplsqlParser::T_DATETIME:
        case HplsqlParser::T_DAY:
        case HplsqlParser::T_DAYS:
        case HplsqlParser::T_DEC:
        case HplsqlParser::T_DECIMAL:
        case HplsqlParser::T_DECLARE:
        case HplsqlParser::T_DEFAULT:
        case HplsqlParser::T_DEFERRED:
        case HplsqlParser::T_DEFINED:
        case HplsqlParser::T_DEFINER:
        case HplsqlParser::T_DEFINITION:
        case HplsqlParser::T_DELETE:
        case HplsqlParser::T_DELIMITED:
        case HplsqlParser::T_DELIMITER:
        case HplsqlParser::T_DESC:
        case HplsqlParser::T_DESCRIBE:
        case HplsqlParser::T_DIAGNOSTICS:
        case HplsqlParser::T_DIR:
        case HplsqlParser::T_DIRECTORY:
        case HplsqlParser::T_DISTINCT:
        case HplsqlParser::T_DISTRIBUTE:
        case HplsqlParser::T_DO:
        case HplsqlParser::T_DOUBLE:
        case HplsqlParser::T_DROP:
        case HplsqlParser::T_DYNAMIC:
        case HplsqlParser::T_ENABLE:
        case HplsqlParser::T_ENGINE:
        case HplsqlParser::T_ESCAPED:
        case HplsqlParser::T_EXCEPT:
        case HplsqlParser::T_EXEC:
        case HplsqlParser::T_EXECUTE:
        case HplsqlParser::T_EXCEPTION:
        case HplsqlParser::T_EXCLUSIVE:
        case HplsqlParser::T_EXISTS:
        case HplsqlParser::T_EXIT:
        case HplsqlParser::T_FALLBACK:
        case HplsqlParser::T_FALSE:
        case HplsqlParser::T_FETCH:
        case HplsqlParser::T_FIELDS:
        case HplsqlParser::T_FILE:
        case HplsqlParser::T_FILES:
        case HplsqlParser::T_FLOAT:
        case HplsqlParser::T_FOR:
        case HplsqlParser::T_FOREIGN:
        case HplsqlParser::T_FORMAT:
        case HplsqlParser::T_FOUND:
        case HplsqlParser::T_FROM:
        case HplsqlParser::T_FULL:
        case HplsqlParser::T_FUNCTION:
        case HplsqlParser::T_GET:
        case HplsqlParser::T_GLOBAL:
        case HplsqlParser::T_GO:
        case HplsqlParser::T_GRANT:
        case HplsqlParser::T_GROUP:
        case HplsqlParser::T_HANDLER:
        case HplsqlParser::T_HASH:
        case HplsqlParser::T_HAVING:
        case HplsqlParser::T_HDFS:
        case HplsqlParser::T_HIVE:
        case HplsqlParser::T_HOST:
        case HplsqlParser::T_IDENTITY:
        case HplsqlParser::T_IF:
        case HplsqlParser::T_IGNORE:
        case HplsqlParser::T_IMMEDIATE:
        case HplsqlParser::T_IN:
        case HplsqlParser::T_INCLUDE:
        case HplsqlParser::T_INDEX:
        case HplsqlParser::T_INITRANS:
        case HplsqlParser::T_INNER:
        case HplsqlParser::T_INOUT:
        case HplsqlParser::T_INSERT:
        case HplsqlParser::T_INT:
        case HplsqlParser::T_INT2:
        case HplsqlParser::T_INT4:
        case HplsqlParser::T_INT8:
        case HplsqlParser::T_INTEGER:
        case HplsqlParser::T_INTERSECT:
        case HplsqlParser::T_INTERVAL:
        case HplsqlParser::T_INTO:
        case HplsqlParser::T_INVOKER:
        case HplsqlParser::T_IS:
        case HplsqlParser::T_ISOPEN:
        case HplsqlParser::T_ITEMS:
        case HplsqlParser::T_JOIN:
        case HplsqlParser::T_KEEP:
        case HplsqlParser::T_KEY:
        case HplsqlParser::T_KEYS:
        case HplsqlParser::T_LANGUAGE:
        case HplsqlParser::T_LEAVE:
        case HplsqlParser::T_LEFT:
        case HplsqlParser::T_LIKE:
        case HplsqlParser::T_LIMIT:
        case HplsqlParser::T_LINES:
        case HplsqlParser::T_LOCAL:
        case HplsqlParser::T_LOCATION:
        case HplsqlParser::T_LOCATOR:
        case HplsqlParser::T_LOCATORS:
        case HplsqlParser::T_LOCKS:
        case HplsqlParser::T_LOG:
        case HplsqlParser::T_LOGGED:
        case HplsqlParser::T_LOGGING:
        case HplsqlParser::T_LOOP:
        case HplsqlParser::T_MAP:
        case HplsqlParser::T_MATCHED:
        case HplsqlParser::T_MAX:
        case HplsqlParser::T_MAXTRANS:
        case HplsqlParser::T_MERGE:
        case HplsqlParser::T_MESSAGE_TEXT:
        case HplsqlParser::T_MICROSECOND:
        case HplsqlParser::T_MICROSECONDS:
        case HplsqlParser::T_MIN:
        case HplsqlParser::T_MULTISET:
        case HplsqlParser::T_NCHAR:
        case HplsqlParser::T_NEW:
        case HplsqlParser::T_NVARCHAR:
        case HplsqlParser::T_NO:
        case HplsqlParser::T_NOCOUNT:
        case HplsqlParser::T_NOCOMPRESS:
        case HplsqlParser::T_NOLOGGING:
        case HplsqlParser::T_NONE:
        case HplsqlParser::T_NOT:
        case HplsqlParser::T_NOTFOUND:
        case HplsqlParser::T_NULL:
        case HplsqlParser::T_NUMERIC:
        case HplsqlParser::T_NUMBER:
        case HplsqlParser::T_OBJECT:
        case HplsqlParser::T_OFF:
        case HplsqlParser::T_ON:
        case HplsqlParser::T_ONLY:
        case HplsqlParser::T_OPEN:
        case HplsqlParser::T_OR:
        case HplsqlParser::T_ORDER:
        case HplsqlParser::T_OUT:
        case HplsqlParser::T_OUTER:
        case HplsqlParser::T_OVER:
        case HplsqlParser::T_OVERWRITE:
        case HplsqlParser::T_OWNER:
        case HplsqlParser::T_PACKAGE:
        case HplsqlParser::T_PARTITION:
        case HplsqlParser::T_PCTFREE:
        case HplsqlParser::T_PCTUSED:
        case HplsqlParser::T_PRECISION:
        case HplsqlParser::T_PRESERVE:
        case HplsqlParser::T_PRIMARY:
        case HplsqlParser::T_PRINT:
        case HplsqlParser::T_PROC:
        case HplsqlParser::T_PROCEDURE:
        case HplsqlParser::T_QUALIFY:
        case HplsqlParser::T_QUERY_BAND:
        case HplsqlParser::T_QUIT:
        case HplsqlParser::T_QUOTED_IDENTIFIER:
        case HplsqlParser::T_RAISE:
        case HplsqlParser::T_REAL:
        case HplsqlParser::T_REFERENCES:
        case HplsqlParser::T_REGEXP:
        case HplsqlParser::T_REPLACE:
        case HplsqlParser::T_RESIGNAL:
        case HplsqlParser::T_RESTRICT:
        case HplsqlParser::T_RESULT:
        case HplsqlParser::T_RESULT_SET_LOCATOR:
        case HplsqlParser::T_RETURN:
        case HplsqlParser::T_RETURNS:
        case HplsqlParser::T_REVERSE:
        case HplsqlParser::T_RIGHT:
        case HplsqlParser::T_RLIKE:
        case HplsqlParser::T_ROLE:
        case HplsqlParser::T_ROLLBACK:
        case HplsqlParser::T_ROW:
        case HplsqlParser::T_ROWS:
        case HplsqlParser::T_ROW_COUNT:
        case HplsqlParser::T_RR:
        case HplsqlParser::T_RS:
        case HplsqlParser::T_PWD:
        case HplsqlParser::T_TRIM:
        case HplsqlParser::T_SCHEMA:
        case HplsqlParser::T_SECOND:
        case HplsqlParser::T_SECONDS:
        case HplsqlParser::T_SECURITY:
        case HplsqlParser::T_SEGMENT:
        case HplsqlParser::T_SEL:
        case HplsqlParser::T_SELECT:
        case HplsqlParser::T_SET:
        case HplsqlParser::T_SESSION:
        case HplsqlParser::T_SESSIONS:
        case HplsqlParser::T_SETS:
        case HplsqlParser::T_SHARE:
        case HplsqlParser::T_SIGNAL:
        case HplsqlParser::T_SIMPLE_DOUBLE:
        case HplsqlParser::T_SIMPLE_FLOAT:
        case HplsqlParser::T_SMALLDATETIME:
        case HplsqlParser::T_SMALLINT:
        case HplsqlParser::T_SQL:
        case HplsqlParser::T_SQLEXCEPTION:
        case HplsqlParser::T_SQLINSERT:
        case HplsqlParser::T_SQLSTATE:
        case HplsqlParser::T_SQLWARNING:
        case HplsqlParser::T_STATS:
        case HplsqlParser::T_STATISTICS:
        case HplsqlParser::T_STEP:
        case HplsqlParser::T_STORAGE:
        case HplsqlParser::T_STORED:
        case HplsqlParser::T_STRING:
        case HplsqlParser::T_SUBDIR:
        case HplsqlParser::T_SUBSTRING:
        case HplsqlParser::T_SUM:
        case HplsqlParser::T_SYS_REFCURSOR:
        case HplsqlParser::T_TABLE:
        case HplsqlParser::T_TABLESPACE:
        case HplsqlParser::T_TEMPORARY:
        case HplsqlParser::T_TERMINATED:
        case HplsqlParser::T_TEXTIMAGE_ON:
        case HplsqlParser::T_THEN:
        case HplsqlParser::T_TIMESTAMP:
        case HplsqlParser::T_TITLE:
        case HplsqlParser::T_TO:
        case HplsqlParser::T_TOP:
        case HplsqlParser::T_TRANSACTION:
        case HplsqlParser::T_TRUE:
        case HplsqlParser::T_TRUNCATE:
        case HplsqlParser::T_UNIQUE:
        case HplsqlParser::T_UPDATE:
        case HplsqlParser::T_UR:
        case HplsqlParser::T_USE:
        case HplsqlParser::T_USING:
        case HplsqlParser::T_VALUE:
        case HplsqlParser::T_VALUES:
        case HplsqlParser::T_VAR:
        case HplsqlParser::T_VARCHAR:
        case HplsqlParser::T_VARCHAR2:
        case HplsqlParser::T_VARYING:
        case HplsqlParser::T_VOLATILE:
        case HplsqlParser::T_WHILE:
        case HplsqlParser::T_WITH:
        case HplsqlParser::T_WITHOUT:
        case HplsqlParser::T_WORK:
        case HplsqlParser::T_XACT_ABORT:
        case HplsqlParser::T_XML:
        case HplsqlParser::T_YES:
        case HplsqlParser::T_ACTIVITY_COUNT:
        case HplsqlParser::T_CUME_DIST:
        case HplsqlParser::T_CURRENT_DATE:
        case HplsqlParser::T_CURRENT_TIMESTAMP:
        case HplsqlParser::T_CURRENT_USER:
        case HplsqlParser::T_DENSE_RANK:
        case HplsqlParser::T_FIRST_VALUE:
        case HplsqlParser::T_LAG:
        case HplsqlParser::T_LAST_VALUE:
        case HplsqlParser::T_LEAD:
        case HplsqlParser::T_MAX_PART_STRING:
        case HplsqlParser::T_MIN_PART_STRING:
        case HplsqlParser::T_MAX_PART_INT:
        case HplsqlParser::T_MIN_PART_INT:
        case HplsqlParser::T_MAX_PART_DATE:
        case HplsqlParser::T_MIN_PART_DATE:
        case HplsqlParser::T_PART_COUNT:
        case HplsqlParser::T_PART_LOC:
        case HplsqlParser::T_RANK:
        case HplsqlParser::T_ROW_NUMBER:
        case HplsqlParser::T_STDEV:
        case HplsqlParser::T_SYSDATE:
        case HplsqlParser::T_VARIANCE:
        case HplsqlParser::T_USER:
        case HplsqlParser::T_ADD:
        case HplsqlParser::T_OPEN_P:
        case HplsqlParser::T_SUB:
        case HplsqlParser::L_ID:
        case HplsqlParser::L_S_STRING:
        case HplsqlParser::L_D_STRING:
        case HplsqlParser::L_INT:
        case HplsqlParser::L_DEC: {
          setState(3000);
          expr(0);
          break;
        }

        case HplsqlParser::T_MUL: {
          setState(3001);
          match(HplsqlParser::T_MUL);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(3004);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3005);
      match(HplsqlParser::T_CURRENT_DATE);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3006);
      match(HplsqlParser::T_CURRENT);
      setState(3007);
      match(HplsqlParser::T_DATE);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3011);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case HplsqlParser::T_CURRENT_TIMESTAMP: {
          setState(3008);
          match(HplsqlParser::T_CURRENT_TIMESTAMP);
          break;
        }

        case HplsqlParser::T_CURRENT: {
          setState(3009);
          match(HplsqlParser::T_CURRENT);
          setState(3010);
          match(HplsqlParser::T_TIMESTAMP);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(3017);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 382, _ctx)) {
      case 1: {
        setState(3013);
        match(HplsqlParser::T_OPEN_P);
        setState(3014);
        expr(0);
        setState(3015);
        match(HplsqlParser::T_CLOSE_P);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3019);
      match(HplsqlParser::T_CURRENT_USER);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(3020);
      match(HplsqlParser::T_CURRENT);
      setState(3021);
      match(HplsqlParser::T_USER);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(3022);
      match(HplsqlParser::T_MAX_PART_STRING);
      setState(3023);
      match(HplsqlParser::T_OPEN_P);
      setState(3024);
      expr(0);
      setState(3037);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HplsqlParser::T_COMMA) {
        setState(3025);
        match(HplsqlParser::T_COMMA);
        setState(3026);
        expr(0);
        setState(3034);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == HplsqlParser::T_COMMA) {
          setState(3027);
          match(HplsqlParser::T_COMMA);
          setState(3028);
          expr(0);
          setState(3029);
          match(HplsqlParser::T_EQUAL);
          setState(3030);
          expr(0);
          setState(3036);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
      }
      setState(3039);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(3041);
      match(HplsqlParser::T_MIN_PART_STRING);
      setState(3042);
      match(HplsqlParser::T_OPEN_P);
      setState(3043);
      expr(0);
      setState(3056);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HplsqlParser::T_COMMA) {
        setState(3044);
        match(HplsqlParser::T_COMMA);
        setState(3045);
        expr(0);
        setState(3053);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == HplsqlParser::T_COMMA) {
          setState(3046);
          match(HplsqlParser::T_COMMA);
          setState(3047);
          expr(0);
          setState(3048);
          match(HplsqlParser::T_EQUAL);
          setState(3049);
          expr(0);
          setState(3055);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
      }
      setState(3058);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(3060);
      match(HplsqlParser::T_MAX_PART_INT);
      setState(3061);
      match(HplsqlParser::T_OPEN_P);
      setState(3062);
      expr(0);
      setState(3075);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HplsqlParser::T_COMMA) {
        setState(3063);
        match(HplsqlParser::T_COMMA);
        setState(3064);
        expr(0);
        setState(3072);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == HplsqlParser::T_COMMA) {
          setState(3065);
          match(HplsqlParser::T_COMMA);
          setState(3066);
          expr(0);
          setState(3067);
          match(HplsqlParser::T_EQUAL);
          setState(3068);
          expr(0);
          setState(3074);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
      }
      setState(3077);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(3079);
      match(HplsqlParser::T_MIN_PART_INT);
      setState(3080);
      match(HplsqlParser::T_OPEN_P);
      setState(3081);
      expr(0);
      setState(3094);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HplsqlParser::T_COMMA) {
        setState(3082);
        match(HplsqlParser::T_COMMA);
        setState(3083);
        expr(0);
        setState(3091);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == HplsqlParser::T_COMMA) {
          setState(3084);
          match(HplsqlParser::T_COMMA);
          setState(3085);
          expr(0);
          setState(3086);
          match(HplsqlParser::T_EQUAL);
          setState(3087);
          expr(0);
          setState(3093);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
      }
      setState(3096);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(3098);
      match(HplsqlParser::T_MAX_PART_DATE);
      setState(3099);
      match(HplsqlParser::T_OPEN_P);
      setState(3100);
      expr(0);
      setState(3113);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HplsqlParser::T_COMMA) {
        setState(3101);
        match(HplsqlParser::T_COMMA);
        setState(3102);
        expr(0);
        setState(3110);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == HplsqlParser::T_COMMA) {
          setState(3103);
          match(HplsqlParser::T_COMMA);
          setState(3104);
          expr(0);
          setState(3105);
          match(HplsqlParser::T_EQUAL);
          setState(3106);
          expr(0);
          setState(3112);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
      }
      setState(3115);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(3117);
      match(HplsqlParser::T_MIN_PART_DATE);
      setState(3118);
      match(HplsqlParser::T_OPEN_P);
      setState(3119);
      expr(0);
      setState(3132);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HplsqlParser::T_COMMA) {
        setState(3120);
        match(HplsqlParser::T_COMMA);
        setState(3121);
        expr(0);
        setState(3129);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == HplsqlParser::T_COMMA) {
          setState(3122);
          match(HplsqlParser::T_COMMA);
          setState(3123);
          expr(0);
          setState(3124);
          match(HplsqlParser::T_EQUAL);
          setState(3125);
          expr(0);
          setState(3131);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
      }
      setState(3134);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(3136);
      match(HplsqlParser::T_PART_COUNT);
      setState(3137);
      match(HplsqlParser::T_OPEN_P);
      setState(3138);
      expr(0);
      setState(3146);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == HplsqlParser::T_COMMA) {
        setState(3139);
        match(HplsqlParser::T_COMMA);
        setState(3140);
        expr(0);
        setState(3141);
        match(HplsqlParser::T_EQUAL);
        setState(3142);
        expr(0);
        setState(3148);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3149);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(3151);
      match(HplsqlParser::T_PART_LOC);
      setState(3152);
      match(HplsqlParser::T_OPEN_P);
      setState(3153);
      expr(0);
      setState(3159); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(3154);
                match(HplsqlParser::T_COMMA);
                setState(3155);
                expr(0);
                setState(3156);
                match(HplsqlParser::T_EQUAL);
                setState(3157);
                expr(0);
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(3161); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 396, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(3165);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HplsqlParser::T_COMMA) {
        setState(3163);
        match(HplsqlParser::T_COMMA);
        setState(3164);
        expr(0);
      }
      setState(3167);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(3169);
      match(HplsqlParser::T_TRIM);
      setState(3170);
      match(HplsqlParser::T_OPEN_P);
      setState(3171);
      expr(0);
      setState(3172);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(3174);
      match(HplsqlParser::T_SUBSTRING);
      setState(3175);
      match(HplsqlParser::T_OPEN_P);
      setState(3176);
      expr(0);
      setState(3177);
      match(HplsqlParser::T_FROM);
      setState(3178);
      expr(0);
      setState(3181);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HplsqlParser::T_FOR) {
        setState(3179);
        match(HplsqlParser::T_FOR);
        setState(3180);
        expr(0);
      }
      setState(3183);
      match(HplsqlParser::T_CLOSE_P);
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(3185);
      match(HplsqlParser::T_SYSDATE);
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(3186);
      match(HplsqlParser::T_USER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_funcContext ------------------------------------------------------------------

HplsqlParser::Expr_funcContext::Expr_funcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::IdentContext* HplsqlParser::Expr_funcContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

tree::TerminalNode* HplsqlParser::Expr_funcContext::T_OPEN_P() {
  return getToken(HplsqlParser::T_OPEN_P, 0);
}

tree::TerminalNode* HplsqlParser::Expr_funcContext::T_CLOSE_P() {
  return getToken(HplsqlParser::T_CLOSE_P, 0);
}

HplsqlParser::Expr_func_paramsContext* HplsqlParser::Expr_funcContext::expr_func_params() {
  return getRuleContext<HplsqlParser::Expr_func_paramsContext>(0);
}


size_t HplsqlParser::Expr_funcContext::getRuleIndex() const {
  return HplsqlParser::RuleExpr_func;
}

void HplsqlParser::Expr_funcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_func(this);
}

void HplsqlParser::Expr_funcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_func(this);
}


antlrcpp::Any HplsqlParser::Expr_funcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitExpr_func(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Expr_funcContext* HplsqlParser::expr_func() {
  Expr_funcContext *_localctx = _tracker.createInstance<Expr_funcContext>(_ctx, getState());
  enterRule(_localctx, 410, HplsqlParser::RuleExpr_func);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3189);
    ident();
    setState(3190);
    match(HplsqlParser::T_OPEN_P);
    setState(3192);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 400, _ctx)) {
    case 1: {
      setState(3191);
      expr_func_params();
      break;
    }

    default:
      break;
    }
    setState(3194);
    match(HplsqlParser::T_CLOSE_P);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_func_paramsContext ------------------------------------------------------------------

HplsqlParser::Expr_func_paramsContext::Expr_func_paramsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<HplsqlParser::Func_paramContext *> HplsqlParser::Expr_func_paramsContext::func_param() {
  return getRuleContexts<HplsqlParser::Func_paramContext>();
}

HplsqlParser::Func_paramContext* HplsqlParser::Expr_func_paramsContext::func_param(size_t i) {
  return getRuleContext<HplsqlParser::Func_paramContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::Expr_func_paramsContext::T_COMMA() {
  return getTokens(HplsqlParser::T_COMMA);
}

tree::TerminalNode* HplsqlParser::Expr_func_paramsContext::T_COMMA(size_t i) {
  return getToken(HplsqlParser::T_COMMA, i);
}


size_t HplsqlParser::Expr_func_paramsContext::getRuleIndex() const {
  return HplsqlParser::RuleExpr_func_params;
}

void HplsqlParser::Expr_func_paramsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_func_params(this);
}

void HplsqlParser::Expr_func_paramsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_func_params(this);
}


antlrcpp::Any HplsqlParser::Expr_func_paramsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitExpr_func_params(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Expr_func_paramsContext* HplsqlParser::expr_func_params() {
  Expr_func_paramsContext *_localctx = _tracker.createInstance<Expr_func_paramsContext>(_ctx, getState());
  enterRule(_localctx, 412, HplsqlParser::RuleExpr_func_params);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3196);
    func_param();
    setState(3201);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 401, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3197);
        match(HplsqlParser::T_COMMA);
        setState(3198);
        func_param(); 
      }
      setState(3203);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 401, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_paramContext ------------------------------------------------------------------

HplsqlParser::Func_paramContext::Func_paramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::ExprContext* HplsqlParser::Func_paramContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}

HplsqlParser::IdentContext* HplsqlParser::Func_paramContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

tree::TerminalNode* HplsqlParser::Func_paramContext::T_EQUAL() {
  return getToken(HplsqlParser::T_EQUAL, 0);
}

tree::TerminalNode* HplsqlParser::Func_paramContext::T_GREATER() {
  return getToken(HplsqlParser::T_GREATER, 0);
}


size_t HplsqlParser::Func_paramContext::getRuleIndex() const {
  return HplsqlParser::RuleFunc_param;
}

void HplsqlParser::Func_paramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_param(this);
}

void HplsqlParser::Func_paramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_param(this);
}


antlrcpp::Any HplsqlParser::Func_paramContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitFunc_param(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Func_paramContext* HplsqlParser::func_param() {
  Func_paramContext *_localctx = _tracker.createInstance<Func_paramContext>(_ctx, getState());
  enterRule(_localctx, 414, HplsqlParser::RuleFunc_param);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3204);

    if (!(strcasecmp(_input->LT(1)->getText().data(), "INTO"))) throw FailedPredicateException(this, "strcasecmp(_input->LT(1)->getText().data(), \"INTO\")");
    setState(3210);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 403, _ctx)) {
    case 1: {
      setState(3205);
      ident();
      setState(3206);
      match(HplsqlParser::T_EQUAL);
      setState(3208);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == HplsqlParser::T_GREATER) {
        setState(3207);
        match(HplsqlParser::T_GREATER);
      }
      break;
    }

    default:
      break;
    }
    setState(3212);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_selectContext ------------------------------------------------------------------

HplsqlParser::Expr_selectContext::Expr_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Select_stmtContext* HplsqlParser::Expr_selectContext::select_stmt() {
  return getRuleContext<HplsqlParser::Select_stmtContext>(0);
}

HplsqlParser::ExprContext* HplsqlParser::Expr_selectContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}


size_t HplsqlParser::Expr_selectContext::getRuleIndex() const {
  return HplsqlParser::RuleExpr_select;
}

void HplsqlParser::Expr_selectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_select(this);
}

void HplsqlParser::Expr_selectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_select(this);
}


antlrcpp::Any HplsqlParser::Expr_selectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitExpr_select(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Expr_selectContext* HplsqlParser::expr_select() {
  Expr_selectContext *_localctx = _tracker.createInstance<Expr_selectContext>(_ctx, getState());
  enterRule(_localctx, 416, HplsqlParser::RuleExpr_select);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3216);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 404, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3214);
      select_stmt();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3215);
      expr(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_fileContext ------------------------------------------------------------------

HplsqlParser::Expr_fileContext::Expr_fileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::File_nameContext* HplsqlParser::Expr_fileContext::file_name() {
  return getRuleContext<HplsqlParser::File_nameContext>(0);
}

HplsqlParser::ExprContext* HplsqlParser::Expr_fileContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}


size_t HplsqlParser::Expr_fileContext::getRuleIndex() const {
  return HplsqlParser::RuleExpr_file;
}

void HplsqlParser::Expr_fileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_file(this);
}

void HplsqlParser::Expr_fileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_file(this);
}


antlrcpp::Any HplsqlParser::Expr_fileContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitExpr_file(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Expr_fileContext* HplsqlParser::expr_file() {
  Expr_fileContext *_localctx = _tracker.createInstance<Expr_fileContext>(_ctx, getState());
  enterRule(_localctx, 418, HplsqlParser::RuleExpr_file);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3220);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 405, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3218);
      file_name();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3219);
      expr(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HiveContext ------------------------------------------------------------------

HplsqlParser::HiveContext::HiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::HiveContext::T_HIVE() {
  return getToken(HplsqlParser::T_HIVE, 0);
}

std::vector<HplsqlParser::Hive_itemContext *> HplsqlParser::HiveContext::hive_item() {
  return getRuleContexts<HplsqlParser::Hive_itemContext>();
}

HplsqlParser::Hive_itemContext* HplsqlParser::HiveContext::hive_item(size_t i) {
  return getRuleContext<HplsqlParser::Hive_itemContext>(i);
}


size_t HplsqlParser::HiveContext::getRuleIndex() const {
  return HplsqlParser::RuleHive;
}

void HplsqlParser::HiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHive(this);
}

void HplsqlParser::HiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHive(this);
}


antlrcpp::Any HplsqlParser::HiveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitHive(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::HiveContext* HplsqlParser::hive() {
  HiveContext *_localctx = _tracker.createInstance<HiveContext>(_ctx, getState());
  enterRule(_localctx, 420, HplsqlParser::RuleHive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3222);
    match(HplsqlParser::T_HIVE);
    setState(3226);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 406, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3223);
        hive_item(); 
      }
      setState(3228);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 406, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hive_itemContext ------------------------------------------------------------------

HplsqlParser::Hive_itemContext::Hive_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Hive_itemContext::T_SUB() {
  return getToken(HplsqlParser::T_SUB, 0);
}

HplsqlParser::IdentContext* HplsqlParser::Hive_itemContext::ident() {
  return getRuleContext<HplsqlParser::IdentContext>(0);
}

HplsqlParser::ExprContext* HplsqlParser::Hive_itemContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}

tree::TerminalNode* HplsqlParser::Hive_itemContext::L_ID() {
  return getToken(HplsqlParser::L_ID, 0);
}

tree::TerminalNode* HplsqlParser::Hive_itemContext::T_EQUAL() {
  return getToken(HplsqlParser::T_EQUAL, 0);
}


size_t HplsqlParser::Hive_itemContext::getRuleIndex() const {
  return HplsqlParser::RuleHive_item;
}

void HplsqlParser::Hive_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHive_item(this);
}

void HplsqlParser::Hive_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHive_item(this);
}


antlrcpp::Any HplsqlParser::Hive_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitHive_item(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Hive_itemContext* HplsqlParser::hive_item() {
  Hive_itemContext *_localctx = _tracker.createInstance<Hive_itemContext>(_ctx, getState());
  enterRule(_localctx, 422, HplsqlParser::RuleHive_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3241);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 407, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3229);
      match(HplsqlParser::T_SUB);
      setState(3230);
      ident();
      setState(3231);
      expr(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3233);
      match(HplsqlParser::T_SUB);
      setState(3234);
      ident();
      setState(3235);
      match(HplsqlParser::L_ID);
      setState(3236);
      match(HplsqlParser::T_EQUAL);
      setState(3237);
      expr(0);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3239);
      match(HplsqlParser::T_SUB);
      setState(3240);
      ident();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HostContext ------------------------------------------------------------------

HplsqlParser::HostContext::HostContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

HplsqlParser::Host_cmdContext* HplsqlParser::HostContext::host_cmd() {
  return getRuleContext<HplsqlParser::Host_cmdContext>(0);
}

tree::TerminalNode* HplsqlParser::HostContext::T_SEMICOLON() {
  return getToken(HplsqlParser::T_SEMICOLON, 0);
}

HplsqlParser::Host_stmtContext* HplsqlParser::HostContext::host_stmt() {
  return getRuleContext<HplsqlParser::Host_stmtContext>(0);
}


size_t HplsqlParser::HostContext::getRuleIndex() const {
  return HplsqlParser::RuleHost;
}

void HplsqlParser::HostContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHost(this);
}

void HplsqlParser::HostContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHost(this);
}


antlrcpp::Any HplsqlParser::HostContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitHost(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::HostContext* HplsqlParser::host() {
  HostContext *_localctx = _tracker.createInstance<HostContext>(_ctx, getState());
  enterRule(_localctx, 424, HplsqlParser::RuleHost);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3248);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::T__4: {
        enterOuterAlt(_localctx, 1);
        setState(3243);
        match(HplsqlParser::T__4);
        setState(3244);
        host_cmd();
        setState(3245);
        match(HplsqlParser::T_SEMICOLON);
        break;
      }

      case HplsqlParser::T_HOST: {
        enterOuterAlt(_localctx, 2);
        setState(3247);
        host_stmt();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Host_cmdContext ------------------------------------------------------------------

HplsqlParser::Host_cmdContext::Host_cmdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t HplsqlParser::Host_cmdContext::getRuleIndex() const {
  return HplsqlParser::RuleHost_cmd;
}

void HplsqlParser::Host_cmdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHost_cmd(this);
}

void HplsqlParser::Host_cmdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHost_cmd(this);
}


antlrcpp::Any HplsqlParser::Host_cmdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitHost_cmd(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Host_cmdContext* HplsqlParser::host_cmd() {
  Host_cmdContext *_localctx = _tracker.createInstance<Host_cmdContext>(_ctx, getState());
  enterRule(_localctx, 426, HplsqlParser::RuleHost_cmd);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3253);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 409, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(3250);
        matchWildcard(); 
      }
      setState(3255);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 409, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Host_stmtContext ------------------------------------------------------------------

HplsqlParser::Host_stmtContext::Host_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Host_stmtContext::T_HOST() {
  return getToken(HplsqlParser::T_HOST, 0);
}

HplsqlParser::ExprContext* HplsqlParser::Host_stmtContext::expr() {
  return getRuleContext<HplsqlParser::ExprContext>(0);
}


size_t HplsqlParser::Host_stmtContext::getRuleIndex() const {
  return HplsqlParser::RuleHost_stmt;
}

void HplsqlParser::Host_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHost_stmt(this);
}

void HplsqlParser::Host_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHost_stmt(this);
}


antlrcpp::Any HplsqlParser::Host_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitHost_stmt(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Host_stmtContext* HplsqlParser::host_stmt() {
  Host_stmtContext *_localctx = _tracker.createInstance<Host_stmtContext>(_ctx, getState());
  enterRule(_localctx, 428, HplsqlParser::RuleHost_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3256);
    match(HplsqlParser::T_HOST);
    setState(3257);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_nameContext ------------------------------------------------------------------

HplsqlParser::File_nameContext::File_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::File_nameContext::L_FILE() {
  return getToken(HplsqlParser::L_FILE, 0);
}

std::vector<HplsqlParser::IdentContext *> HplsqlParser::File_nameContext::ident() {
  return getRuleContexts<HplsqlParser::IdentContext>();
}

HplsqlParser::IdentContext* HplsqlParser::File_nameContext::ident(size_t i) {
  return getRuleContext<HplsqlParser::IdentContext>(i);
}

std::vector<tree::TerminalNode *> HplsqlParser::File_nameContext::T_DIV() {
  return getTokens(HplsqlParser::T_DIV);
}

tree::TerminalNode* HplsqlParser::File_nameContext::T_DIV(size_t i) {
  return getToken(HplsqlParser::T_DIV, i);
}


size_t HplsqlParser::File_nameContext::getRuleIndex() const {
  return HplsqlParser::RuleFile_name;
}

void HplsqlParser::File_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFile_name(this);
}

void HplsqlParser::File_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFile_name(this);
}


antlrcpp::Any HplsqlParser::File_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitFile_name(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::File_nameContext* HplsqlParser::file_name() {
  File_nameContext *_localctx = _tracker.createInstance<File_nameContext>(_ctx, getState());
  enterRule(_localctx, 430, HplsqlParser::RuleFile_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(3273);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::L_FILE: {
        enterOuterAlt(_localctx, 1);
        setState(3259);
        match(HplsqlParser::L_FILE);
        break;
      }

      case HplsqlParser::T__3:
      case HplsqlParser::T_ACTION:
      case HplsqlParser::T_ADD2:
      case HplsqlParser::T_ALL:
      case HplsqlParser::T_ALLOCATE:
      case HplsqlParser::T_ALTER:
      case HplsqlParser::T_AND:
      case HplsqlParser::T_ANSI_NULLS:
      case HplsqlParser::T_ANSI_PADDING:
      case HplsqlParser::T_AS:
      case HplsqlParser::T_ASC:
      case HplsqlParser::T_ASSOCIATE:
      case HplsqlParser::T_AT:
      case HplsqlParser::T_AUTO_INCREMENT:
      case HplsqlParser::T_AVG:
      case HplsqlParser::T_BATCHSIZE:
      case HplsqlParser::T_BEGIN:
      case HplsqlParser::T_BETWEEN:
      case HplsqlParser::T_BIGINT:
      case HplsqlParser::T_BINARY_DOUBLE:
      case HplsqlParser::T_BINARY_FLOAT:
      case HplsqlParser::T_BIT:
      case HplsqlParser::T_BODY:
      case HplsqlParser::T_BREAK:
      case HplsqlParser::T_BY:
      case HplsqlParser::T_BYTE:
      case HplsqlParser::T_CALL:
      case HplsqlParser::T_CALLER:
      case HplsqlParser::T_CASCADE:
      case HplsqlParser::T_CASE:
      case HplsqlParser::T_CASESPECIFIC:
      case HplsqlParser::T_CAST:
      case HplsqlParser::T_CHAR:
      case HplsqlParser::T_CHARACTER:
      case HplsqlParser::T_CHARSET:
      case HplsqlParser::T_CLIENT:
      case HplsqlParser::T_CLOSE:
      case HplsqlParser::T_CLUSTERED:
      case HplsqlParser::T_CMP:
      case HplsqlParser::T_COLLECT:
      case HplsqlParser::T_COLLECTION:
      case HplsqlParser::T_COLUMN:
      case HplsqlParser::T_COMMENT:
      case HplsqlParser::T_CONSTANT:
      case HplsqlParser::T_COMMIT:
      case HplsqlParser::T_COMPRESS:
      case HplsqlParser::T_CONCAT:
      case HplsqlParser::T_CONDITION:
      case HplsqlParser::T_CONSTRAINT:
      case HplsqlParser::T_CONTINUE:
      case HplsqlParser::T_COPY:
      case HplsqlParser::T_COUNT:
      case HplsqlParser::T_COUNT_BIG:
      case HplsqlParser::T_CREATE:
      case HplsqlParser::T_CREATION:
      case HplsqlParser::T_CREATOR:
      case HplsqlParser::T_CS:
      case HplsqlParser::T_CURRENT:
      case HplsqlParser::T_CURRENT_SCHEMA:
      case HplsqlParser::T_CURSOR:
      case HplsqlParser::T_DATABASE:
      case HplsqlParser::T_DATA:
      case HplsqlParser::T_DATE:
      case HplsqlParser::T_DATETIME:
      case HplsqlParser::T_DAY:
      case HplsqlParser::T_DAYS:
      case HplsqlParser::T_DEC:
      case HplsqlParser::T_DECIMAL:
      case HplsqlParser::T_DECLARE:
      case HplsqlParser::T_DEFAULT:
      case HplsqlParser::T_DEFERRED:
      case HplsqlParser::T_DEFINED:
      case HplsqlParser::T_DEFINER:
      case HplsqlParser::T_DEFINITION:
      case HplsqlParser::T_DELETE:
      case HplsqlParser::T_DELIMITED:
      case HplsqlParser::T_DELIMITER:
      case HplsqlParser::T_DESC:
      case HplsqlParser::T_DESCRIBE:
      case HplsqlParser::T_DIAGNOSTICS:
      case HplsqlParser::T_DIR:
      case HplsqlParser::T_DIRECTORY:
      case HplsqlParser::T_DISTINCT:
      case HplsqlParser::T_DISTRIBUTE:
      case HplsqlParser::T_DO:
      case HplsqlParser::T_DOUBLE:
      case HplsqlParser::T_DROP:
      case HplsqlParser::T_DYNAMIC:
      case HplsqlParser::T_ENABLE:
      case HplsqlParser::T_ENGINE:
      case HplsqlParser::T_ESCAPED:
      case HplsqlParser::T_EXCEPT:
      case HplsqlParser::T_EXEC:
      case HplsqlParser::T_EXECUTE:
      case HplsqlParser::T_EXCEPTION:
      case HplsqlParser::T_EXCLUSIVE:
      case HplsqlParser::T_EXISTS:
      case HplsqlParser::T_EXIT:
      case HplsqlParser::T_FALLBACK:
      case HplsqlParser::T_FALSE:
      case HplsqlParser::T_FETCH:
      case HplsqlParser::T_FIELDS:
      case HplsqlParser::T_FILE:
      case HplsqlParser::T_FILES:
      case HplsqlParser::T_FLOAT:
      case HplsqlParser::T_FOR:
      case HplsqlParser::T_FOREIGN:
      case HplsqlParser::T_FORMAT:
      case HplsqlParser::T_FOUND:
      case HplsqlParser::T_FROM:
      case HplsqlParser::T_FULL:
      case HplsqlParser::T_FUNCTION:
      case HplsqlParser::T_GET:
      case HplsqlParser::T_GLOBAL:
      case HplsqlParser::T_GO:
      case HplsqlParser::T_GRANT:
      case HplsqlParser::T_GROUP:
      case HplsqlParser::T_HANDLER:
      case HplsqlParser::T_HASH:
      case HplsqlParser::T_HAVING:
      case HplsqlParser::T_HDFS:
      case HplsqlParser::T_HIVE:
      case HplsqlParser::T_HOST:
      case HplsqlParser::T_IDENTITY:
      case HplsqlParser::T_IF:
      case HplsqlParser::T_IGNORE:
      case HplsqlParser::T_IMMEDIATE:
      case HplsqlParser::T_IN:
      case HplsqlParser::T_INCLUDE:
      case HplsqlParser::T_INDEX:
      case HplsqlParser::T_INITRANS:
      case HplsqlParser::T_INNER:
      case HplsqlParser::T_INOUT:
      case HplsqlParser::T_INSERT:
      case HplsqlParser::T_INT:
      case HplsqlParser::T_INT2:
      case HplsqlParser::T_INT4:
      case HplsqlParser::T_INT8:
      case HplsqlParser::T_INTEGER:
      case HplsqlParser::T_INTERSECT:
      case HplsqlParser::T_INTERVAL:
      case HplsqlParser::T_INTO:
      case HplsqlParser::T_INVOKER:
      case HplsqlParser::T_IS:
      case HplsqlParser::T_ISOPEN:
      case HplsqlParser::T_ITEMS:
      case HplsqlParser::T_JOIN:
      case HplsqlParser::T_KEEP:
      case HplsqlParser::T_KEY:
      case HplsqlParser::T_KEYS:
      case HplsqlParser::T_LANGUAGE:
      case HplsqlParser::T_LEAVE:
      case HplsqlParser::T_LEFT:
      case HplsqlParser::T_LIKE:
      case HplsqlParser::T_LIMIT:
      case HplsqlParser::T_LINES:
      case HplsqlParser::T_LOCAL:
      case HplsqlParser::T_LOCATION:
      case HplsqlParser::T_LOCATOR:
      case HplsqlParser::T_LOCATORS:
      case HplsqlParser::T_LOCKS:
      case HplsqlParser::T_LOG:
      case HplsqlParser::T_LOGGED:
      case HplsqlParser::T_LOGGING:
      case HplsqlParser::T_LOOP:
      case HplsqlParser::T_MAP:
      case HplsqlParser::T_MATCHED:
      case HplsqlParser::T_MAX:
      case HplsqlParser::T_MAXTRANS:
      case HplsqlParser::T_MERGE:
      case HplsqlParser::T_MESSAGE_TEXT:
      case HplsqlParser::T_MICROSECOND:
      case HplsqlParser::T_MICROSECONDS:
      case HplsqlParser::T_MIN:
      case HplsqlParser::T_MULTISET:
      case HplsqlParser::T_NCHAR:
      case HplsqlParser::T_NEW:
      case HplsqlParser::T_NVARCHAR:
      case HplsqlParser::T_NO:
      case HplsqlParser::T_NOCOUNT:
      case HplsqlParser::T_NOCOMPRESS:
      case HplsqlParser::T_NOLOGGING:
      case HplsqlParser::T_NONE:
      case HplsqlParser::T_NOT:
      case HplsqlParser::T_NOTFOUND:
      case HplsqlParser::T_NUMERIC:
      case HplsqlParser::T_NUMBER:
      case HplsqlParser::T_OBJECT:
      case HplsqlParser::T_OFF:
      case HplsqlParser::T_ON:
      case HplsqlParser::T_ONLY:
      case HplsqlParser::T_OPEN:
      case HplsqlParser::T_OR:
      case HplsqlParser::T_ORDER:
      case HplsqlParser::T_OUT:
      case HplsqlParser::T_OUTER:
      case HplsqlParser::T_OVER:
      case HplsqlParser::T_OVERWRITE:
      case HplsqlParser::T_OWNER:
      case HplsqlParser::T_PACKAGE:
      case HplsqlParser::T_PARTITION:
      case HplsqlParser::T_PCTFREE:
      case HplsqlParser::T_PCTUSED:
      case HplsqlParser::T_PRECISION:
      case HplsqlParser::T_PRESERVE:
      case HplsqlParser::T_PRIMARY:
      case HplsqlParser::T_PRINT:
      case HplsqlParser::T_PROC:
      case HplsqlParser::T_PROCEDURE:
      case HplsqlParser::T_QUALIFY:
      case HplsqlParser::T_QUERY_BAND:
      case HplsqlParser::T_QUIT:
      case HplsqlParser::T_QUOTED_IDENTIFIER:
      case HplsqlParser::T_RAISE:
      case HplsqlParser::T_REAL:
      case HplsqlParser::T_REFERENCES:
      case HplsqlParser::T_REGEXP:
      case HplsqlParser::T_REPLACE:
      case HplsqlParser::T_RESIGNAL:
      case HplsqlParser::T_RESTRICT:
      case HplsqlParser::T_RESULT:
      case HplsqlParser::T_RESULT_SET_LOCATOR:
      case HplsqlParser::T_RETURN:
      case HplsqlParser::T_RETURNS:
      case HplsqlParser::T_REVERSE:
      case HplsqlParser::T_RIGHT:
      case HplsqlParser::T_RLIKE:
      case HplsqlParser::T_ROLE:
      case HplsqlParser::T_ROLLBACK:
      case HplsqlParser::T_ROW:
      case HplsqlParser::T_ROWS:
      case HplsqlParser::T_ROW_COUNT:
      case HplsqlParser::T_RR:
      case HplsqlParser::T_RS:
      case HplsqlParser::T_PWD:
      case HplsqlParser::T_TRIM:
      case HplsqlParser::T_SCHEMA:
      case HplsqlParser::T_SECOND:
      case HplsqlParser::T_SECONDS:
      case HplsqlParser::T_SECURITY:
      case HplsqlParser::T_SEGMENT:
      case HplsqlParser::T_SEL:
      case HplsqlParser::T_SELECT:
      case HplsqlParser::T_SET:
      case HplsqlParser::T_SESSION:
      case HplsqlParser::T_SESSIONS:
      case HplsqlParser::T_SETS:
      case HplsqlParser::T_SHARE:
      case HplsqlParser::T_SIGNAL:
      case HplsqlParser::T_SIMPLE_DOUBLE:
      case HplsqlParser::T_SIMPLE_FLOAT:
      case HplsqlParser::T_SMALLDATETIME:
      case HplsqlParser::T_SMALLINT:
      case HplsqlParser::T_SQL:
      case HplsqlParser::T_SQLEXCEPTION:
      case HplsqlParser::T_SQLINSERT:
      case HplsqlParser::T_SQLSTATE:
      case HplsqlParser::T_SQLWARNING:
      case HplsqlParser::T_STATS:
      case HplsqlParser::T_STATISTICS:
      case HplsqlParser::T_STEP:
      case HplsqlParser::T_STORAGE:
      case HplsqlParser::T_STORED:
      case HplsqlParser::T_STRING:
      case HplsqlParser::T_SUBDIR:
      case HplsqlParser::T_SUBSTRING:
      case HplsqlParser::T_SUM:
      case HplsqlParser::T_SYS_REFCURSOR:
      case HplsqlParser::T_TABLE:
      case HplsqlParser::T_TABLESPACE:
      case HplsqlParser::T_TEMPORARY:
      case HplsqlParser::T_TERMINATED:
      case HplsqlParser::T_TEXTIMAGE_ON:
      case HplsqlParser::T_THEN:
      case HplsqlParser::T_TIMESTAMP:
      case HplsqlParser::T_TITLE:
      case HplsqlParser::T_TO:
      case HplsqlParser::T_TOP:
      case HplsqlParser::T_TRANSACTION:
      case HplsqlParser::T_TRUE:
      case HplsqlParser::T_TRUNCATE:
      case HplsqlParser::T_UNIQUE:
      case HplsqlParser::T_UPDATE:
      case HplsqlParser::T_UR:
      case HplsqlParser::T_USE:
      case HplsqlParser::T_USING:
      case HplsqlParser::T_VALUE:
      case HplsqlParser::T_VALUES:
      case HplsqlParser::T_VAR:
      case HplsqlParser::T_VARCHAR:
      case HplsqlParser::T_VARCHAR2:
      case HplsqlParser::T_VARYING:
      case HplsqlParser::T_VOLATILE:
      case HplsqlParser::T_WHILE:
      case HplsqlParser::T_WITH:
      case HplsqlParser::T_WITHOUT:
      case HplsqlParser::T_WORK:
      case HplsqlParser::T_XACT_ABORT:
      case HplsqlParser::T_XML:
      case HplsqlParser::T_YES:
      case HplsqlParser::T_ACTIVITY_COUNT:
      case HplsqlParser::T_CUME_DIST:
      case HplsqlParser::T_CURRENT_DATE:
      case HplsqlParser::T_CURRENT_TIMESTAMP:
      case HplsqlParser::T_CURRENT_USER:
      case HplsqlParser::T_DENSE_RANK:
      case HplsqlParser::T_FIRST_VALUE:
      case HplsqlParser::T_LAG:
      case HplsqlParser::T_LAST_VALUE:
      case HplsqlParser::T_LEAD:
      case HplsqlParser::T_PART_COUNT:
      case HplsqlParser::T_PART_LOC:
      case HplsqlParser::T_RANK:
      case HplsqlParser::T_ROW_NUMBER:
      case HplsqlParser::T_STDEV:
      case HplsqlParser::T_SYSDATE:
      case HplsqlParser::T_VARIANCE:
      case HplsqlParser::T_USER:
      case HplsqlParser::T_DIV:
      case HplsqlParser::L_ID: {
        enterOuterAlt(_localctx, 2);
        setState(3263);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case HplsqlParser::T_DIV: {
            setState(3260);
            match(HplsqlParser::T_DIV);
            break;
          }

          case HplsqlParser::T__3: {
            setState(3261);
            match(HplsqlParser::T__3);
            setState(3262);
            match(HplsqlParser::T_DIV);
            break;
          }

          case HplsqlParser::T_ACTION:
          case HplsqlParser::T_ADD2:
          case HplsqlParser::T_ALL:
          case HplsqlParser::T_ALLOCATE:
          case HplsqlParser::T_ALTER:
          case HplsqlParser::T_AND:
          case HplsqlParser::T_ANSI_NULLS:
          case HplsqlParser::T_ANSI_PADDING:
          case HplsqlParser::T_AS:
          case HplsqlParser::T_ASC:
          case HplsqlParser::T_ASSOCIATE:
          case HplsqlParser::T_AT:
          case HplsqlParser::T_AUTO_INCREMENT:
          case HplsqlParser::T_AVG:
          case HplsqlParser::T_BATCHSIZE:
          case HplsqlParser::T_BEGIN:
          case HplsqlParser::T_BETWEEN:
          case HplsqlParser::T_BIGINT:
          case HplsqlParser::T_BINARY_DOUBLE:
          case HplsqlParser::T_BINARY_FLOAT:
          case HplsqlParser::T_BIT:
          case HplsqlParser::T_BODY:
          case HplsqlParser::T_BREAK:
          case HplsqlParser::T_BY:
          case HplsqlParser::T_BYTE:
          case HplsqlParser::T_CALL:
          case HplsqlParser::T_CALLER:
          case HplsqlParser::T_CASCADE:
          case HplsqlParser::T_CASE:
          case HplsqlParser::T_CASESPECIFIC:
          case HplsqlParser::T_CAST:
          case HplsqlParser::T_CHAR:
          case HplsqlParser::T_CHARACTER:
          case HplsqlParser::T_CHARSET:
          case HplsqlParser::T_CLIENT:
          case HplsqlParser::T_CLOSE:
          case HplsqlParser::T_CLUSTERED:
          case HplsqlParser::T_CMP:
          case HplsqlParser::T_COLLECT:
          case HplsqlParser::T_COLLECTION:
          case HplsqlParser::T_COLUMN:
          case HplsqlParser::T_COMMENT:
          case HplsqlParser::T_CONSTANT:
          case HplsqlParser::T_COMMIT:
          case HplsqlParser::T_COMPRESS:
          case HplsqlParser::T_CONCAT:
          case HplsqlParser::T_CONDITION:
          case HplsqlParser::T_CONSTRAINT:
          case HplsqlParser::T_CONTINUE:
          case HplsqlParser::T_COPY:
          case HplsqlParser::T_COUNT:
          case HplsqlParser::T_COUNT_BIG:
          case HplsqlParser::T_CREATE:
          case HplsqlParser::T_CREATION:
          case HplsqlParser::T_CREATOR:
          case HplsqlParser::T_CS:
          case HplsqlParser::T_CURRENT:
          case HplsqlParser::T_CURRENT_SCHEMA:
          case HplsqlParser::T_CURSOR:
          case HplsqlParser::T_DATABASE:
          case HplsqlParser::T_DATA:
          case HplsqlParser::T_DATE:
          case HplsqlParser::T_DATETIME:
          case HplsqlParser::T_DAY:
          case HplsqlParser::T_DAYS:
          case HplsqlParser::T_DEC:
          case HplsqlParser::T_DECIMAL:
          case HplsqlParser::T_DECLARE:
          case HplsqlParser::T_DEFAULT:
          case HplsqlParser::T_DEFERRED:
          case HplsqlParser::T_DEFINED:
          case HplsqlParser::T_DEFINER:
          case HplsqlParser::T_DEFINITION:
          case HplsqlParser::T_DELETE:
          case HplsqlParser::T_DELIMITED:
          case HplsqlParser::T_DELIMITER:
          case HplsqlParser::T_DESC:
          case HplsqlParser::T_DESCRIBE:
          case HplsqlParser::T_DIAGNOSTICS:
          case HplsqlParser::T_DIR:
          case HplsqlParser::T_DIRECTORY:
          case HplsqlParser::T_DISTINCT:
          case HplsqlParser::T_DISTRIBUTE:
          case HplsqlParser::T_DO:
          case HplsqlParser::T_DOUBLE:
          case HplsqlParser::T_DROP:
          case HplsqlParser::T_DYNAMIC:
          case HplsqlParser::T_ENABLE:
          case HplsqlParser::T_ENGINE:
          case HplsqlParser::T_ESCAPED:
          case HplsqlParser::T_EXCEPT:
          case HplsqlParser::T_EXEC:
          case HplsqlParser::T_EXECUTE:
          case HplsqlParser::T_EXCEPTION:
          case HplsqlParser::T_EXCLUSIVE:
          case HplsqlParser::T_EXISTS:
          case HplsqlParser::T_EXIT:
          case HplsqlParser::T_FALLBACK:
          case HplsqlParser::T_FALSE:
          case HplsqlParser::T_FETCH:
          case HplsqlParser::T_FIELDS:
          case HplsqlParser::T_FILE:
          case HplsqlParser::T_FILES:
          case HplsqlParser::T_FLOAT:
          case HplsqlParser::T_FOR:
          case HplsqlParser::T_FOREIGN:
          case HplsqlParser::T_FORMAT:
          case HplsqlParser::T_FOUND:
          case HplsqlParser::T_FROM:
          case HplsqlParser::T_FULL:
          case HplsqlParser::T_FUNCTION:
          case HplsqlParser::T_GET:
          case HplsqlParser::T_GLOBAL:
          case HplsqlParser::T_GO:
          case HplsqlParser::T_GRANT:
          case HplsqlParser::T_GROUP:
          case HplsqlParser::T_HANDLER:
          case HplsqlParser::T_HASH:
          case HplsqlParser::T_HAVING:
          case HplsqlParser::T_HDFS:
          case HplsqlParser::T_HIVE:
          case HplsqlParser::T_HOST:
          case HplsqlParser::T_IDENTITY:
          case HplsqlParser::T_IF:
          case HplsqlParser::T_IGNORE:
          case HplsqlParser::T_IMMEDIATE:
          case HplsqlParser::T_IN:
          case HplsqlParser::T_INCLUDE:
          case HplsqlParser::T_INDEX:
          case HplsqlParser::T_INITRANS:
          case HplsqlParser::T_INNER:
          case HplsqlParser::T_INOUT:
          case HplsqlParser::T_INSERT:
          case HplsqlParser::T_INT:
          case HplsqlParser::T_INT2:
          case HplsqlParser::T_INT4:
          case HplsqlParser::T_INT8:
          case HplsqlParser::T_INTEGER:
          case HplsqlParser::T_INTERSECT:
          case HplsqlParser::T_INTERVAL:
          case HplsqlParser::T_INTO:
          case HplsqlParser::T_INVOKER:
          case HplsqlParser::T_IS:
          case HplsqlParser::T_ISOPEN:
          case HplsqlParser::T_ITEMS:
          case HplsqlParser::T_JOIN:
          case HplsqlParser::T_KEEP:
          case HplsqlParser::T_KEY:
          case HplsqlParser::T_KEYS:
          case HplsqlParser::T_LANGUAGE:
          case HplsqlParser::T_LEAVE:
          case HplsqlParser::T_LEFT:
          case HplsqlParser::T_LIKE:
          case HplsqlParser::T_LIMIT:
          case HplsqlParser::T_LINES:
          case HplsqlParser::T_LOCAL:
          case HplsqlParser::T_LOCATION:
          case HplsqlParser::T_LOCATOR:
          case HplsqlParser::T_LOCATORS:
          case HplsqlParser::T_LOCKS:
          case HplsqlParser::T_LOG:
          case HplsqlParser::T_LOGGED:
          case HplsqlParser::T_LOGGING:
          case HplsqlParser::T_LOOP:
          case HplsqlParser::T_MAP:
          case HplsqlParser::T_MATCHED:
          case HplsqlParser::T_MAX:
          case HplsqlParser::T_MAXTRANS:
          case HplsqlParser::T_MERGE:
          case HplsqlParser::T_MESSAGE_TEXT:
          case HplsqlParser::T_MICROSECOND:
          case HplsqlParser::T_MICROSECONDS:
          case HplsqlParser::T_MIN:
          case HplsqlParser::T_MULTISET:
          case HplsqlParser::T_NCHAR:
          case HplsqlParser::T_NEW:
          case HplsqlParser::T_NVARCHAR:
          case HplsqlParser::T_NO:
          case HplsqlParser::T_NOCOUNT:
          case HplsqlParser::T_NOCOMPRESS:
          case HplsqlParser::T_NOLOGGING:
          case HplsqlParser::T_NONE:
          case HplsqlParser::T_NOT:
          case HplsqlParser::T_NOTFOUND:
          case HplsqlParser::T_NUMERIC:
          case HplsqlParser::T_NUMBER:
          case HplsqlParser::T_OBJECT:
          case HplsqlParser::T_OFF:
          case HplsqlParser::T_ON:
          case HplsqlParser::T_ONLY:
          case HplsqlParser::T_OPEN:
          case HplsqlParser::T_OR:
          case HplsqlParser::T_ORDER:
          case HplsqlParser::T_OUT:
          case HplsqlParser::T_OUTER:
          case HplsqlParser::T_OVER:
          case HplsqlParser::T_OVERWRITE:
          case HplsqlParser::T_OWNER:
          case HplsqlParser::T_PACKAGE:
          case HplsqlParser::T_PARTITION:
          case HplsqlParser::T_PCTFREE:
          case HplsqlParser::T_PCTUSED:
          case HplsqlParser::T_PRECISION:
          case HplsqlParser::T_PRESERVE:
          case HplsqlParser::T_PRIMARY:
          case HplsqlParser::T_PRINT:
          case HplsqlParser::T_PROC:
          case HplsqlParser::T_PROCEDURE:
          case HplsqlParser::T_QUALIFY:
          case HplsqlParser::T_QUERY_BAND:
          case HplsqlParser::T_QUIT:
          case HplsqlParser::T_QUOTED_IDENTIFIER:
          case HplsqlParser::T_RAISE:
          case HplsqlParser::T_REAL:
          case HplsqlParser::T_REFERENCES:
          case HplsqlParser::T_REGEXP:
          case HplsqlParser::T_REPLACE:
          case HplsqlParser::T_RESIGNAL:
          case HplsqlParser::T_RESTRICT:
          case HplsqlParser::T_RESULT:
          case HplsqlParser::T_RESULT_SET_LOCATOR:
          case HplsqlParser::T_RETURN:
          case HplsqlParser::T_RETURNS:
          case HplsqlParser::T_REVERSE:
          case HplsqlParser::T_RIGHT:
          case HplsqlParser::T_RLIKE:
          case HplsqlParser::T_ROLE:
          case HplsqlParser::T_ROLLBACK:
          case HplsqlParser::T_ROW:
          case HplsqlParser::T_ROWS:
          case HplsqlParser::T_ROW_COUNT:
          case HplsqlParser::T_RR:
          case HplsqlParser::T_RS:
          case HplsqlParser::T_PWD:
          case HplsqlParser::T_TRIM:
          case HplsqlParser::T_SCHEMA:
          case HplsqlParser::T_SECOND:
          case HplsqlParser::T_SECONDS:
          case HplsqlParser::T_SECURITY:
          case HplsqlParser::T_SEGMENT:
          case HplsqlParser::T_SEL:
          case HplsqlParser::T_SELECT:
          case HplsqlParser::T_SET:
          case HplsqlParser::T_SESSION:
          case HplsqlParser::T_SESSIONS:
          case HplsqlParser::T_SETS:
          case HplsqlParser::T_SHARE:
          case HplsqlParser::T_SIGNAL:
          case HplsqlParser::T_SIMPLE_DOUBLE:
          case HplsqlParser::T_SIMPLE_FLOAT:
          case HplsqlParser::T_SMALLDATETIME:
          case HplsqlParser::T_SMALLINT:
          case HplsqlParser::T_SQL:
          case HplsqlParser::T_SQLEXCEPTION:
          case HplsqlParser::T_SQLINSERT:
          case HplsqlParser::T_SQLSTATE:
          case HplsqlParser::T_SQLWARNING:
          case HplsqlParser::T_STATS:
          case HplsqlParser::T_STATISTICS:
          case HplsqlParser::T_STEP:
          case HplsqlParser::T_STORAGE:
          case HplsqlParser::T_STORED:
          case HplsqlParser::T_STRING:
          case HplsqlParser::T_SUBDIR:
          case HplsqlParser::T_SUBSTRING:
          case HplsqlParser::T_SUM:
          case HplsqlParser::T_SYS_REFCURSOR:
          case HplsqlParser::T_TABLE:
          case HplsqlParser::T_TABLESPACE:
          case HplsqlParser::T_TEMPORARY:
          case HplsqlParser::T_TERMINATED:
          case HplsqlParser::T_TEXTIMAGE_ON:
          case HplsqlParser::T_THEN:
          case HplsqlParser::T_TIMESTAMP:
          case HplsqlParser::T_TITLE:
          case HplsqlParser::T_TO:
          case HplsqlParser::T_TOP:
          case HplsqlParser::T_TRANSACTION:
          case HplsqlParser::T_TRUE:
          case HplsqlParser::T_TRUNCATE:
          case HplsqlParser::T_UNIQUE:
          case HplsqlParser::T_UPDATE:
          case HplsqlParser::T_UR:
          case HplsqlParser::T_USE:
          case HplsqlParser::T_USING:
          case HplsqlParser::T_VALUE:
          case HplsqlParser::T_VALUES:
          case HplsqlParser::T_VAR:
          case HplsqlParser::T_VARCHAR:
          case HplsqlParser::T_VARCHAR2:
          case HplsqlParser::T_VARYING:
          case HplsqlParser::T_VOLATILE:
          case HplsqlParser::T_WHILE:
          case HplsqlParser::T_WITH:
          case HplsqlParser::T_WITHOUT:
          case HplsqlParser::T_WORK:
          case HplsqlParser::T_XACT_ABORT:
          case HplsqlParser::T_XML:
          case HplsqlParser::T_YES:
          case HplsqlParser::T_ACTIVITY_COUNT:
          case HplsqlParser::T_CUME_DIST:
          case HplsqlParser::T_CURRENT_DATE:
          case HplsqlParser::T_CURRENT_TIMESTAMP:
          case HplsqlParser::T_CURRENT_USER:
          case HplsqlParser::T_DENSE_RANK:
          case HplsqlParser::T_FIRST_VALUE:
          case HplsqlParser::T_LAG:
          case HplsqlParser::T_LAST_VALUE:
          case HplsqlParser::T_LEAD:
          case HplsqlParser::T_PART_COUNT:
          case HplsqlParser::T_PART_LOC:
          case HplsqlParser::T_RANK:
          case HplsqlParser::T_ROW_NUMBER:
          case HplsqlParser::T_STDEV:
          case HplsqlParser::T_SYSDATE:
          case HplsqlParser::T_VARIANCE:
          case HplsqlParser::T_USER:
          case HplsqlParser::L_ID: {
            break;
          }

        default:
          break;
        }
        setState(3265);
        ident();
        setState(3270);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 411, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(3266);
            match(HplsqlParser::T_DIV);
            setState(3267);
            ident(); 
          }
          setState(3272);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 411, _ctx);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Date_literalContext ------------------------------------------------------------------

HplsqlParser::Date_literalContext::Date_literalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Date_literalContext::T_DATE() {
  return getToken(HplsqlParser::T_DATE, 0);
}

HplsqlParser::StringContext* HplsqlParser::Date_literalContext::string() {
  return getRuleContext<HplsqlParser::StringContext>(0);
}


size_t HplsqlParser::Date_literalContext::getRuleIndex() const {
  return HplsqlParser::RuleDate_literal;
}

void HplsqlParser::Date_literalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDate_literal(this);
}

void HplsqlParser::Date_literalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDate_literal(this);
}


antlrcpp::Any HplsqlParser::Date_literalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitDate_literal(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Date_literalContext* HplsqlParser::date_literal() {
  Date_literalContext *_localctx = _tracker.createInstance<Date_literalContext>(_ctx, getState());
  enterRule(_localctx, 432, HplsqlParser::RuleDate_literal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3275);
    match(HplsqlParser::T_DATE);
    setState(3276);
    string();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timestamp_literalContext ------------------------------------------------------------------

HplsqlParser::Timestamp_literalContext::Timestamp_literalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Timestamp_literalContext::T_TIMESTAMP() {
  return getToken(HplsqlParser::T_TIMESTAMP, 0);
}

HplsqlParser::StringContext* HplsqlParser::Timestamp_literalContext::string() {
  return getRuleContext<HplsqlParser::StringContext>(0);
}


size_t HplsqlParser::Timestamp_literalContext::getRuleIndex() const {
  return HplsqlParser::RuleTimestamp_literal;
}

void HplsqlParser::Timestamp_literalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimestamp_literal(this);
}

void HplsqlParser::Timestamp_literalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimestamp_literal(this);
}


antlrcpp::Any HplsqlParser::Timestamp_literalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitTimestamp_literal(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Timestamp_literalContext* HplsqlParser::timestamp_literal() {
  Timestamp_literalContext *_localctx = _tracker.createInstance<Timestamp_literalContext>(_ctx, getState());
  enterRule(_localctx, 434, HplsqlParser::RuleTimestamp_literal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3278);
    match(HplsqlParser::T_TIMESTAMP);
    setState(3279);
    string();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentContext ------------------------------------------------------------------

HplsqlParser::IdentContext::IdentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> HplsqlParser::IdentContext::L_ID() {
  return getTokens(HplsqlParser::L_ID);
}

tree::TerminalNode* HplsqlParser::IdentContext::L_ID(size_t i) {
  return getToken(HplsqlParser::L_ID, i);
}

std::vector<HplsqlParser::Non_reserved_wordsContext *> HplsqlParser::IdentContext::non_reserved_words() {
  return getRuleContexts<HplsqlParser::Non_reserved_wordsContext>();
}

HplsqlParser::Non_reserved_wordsContext* HplsqlParser::IdentContext::non_reserved_words(size_t i) {
  return getRuleContext<HplsqlParser::Non_reserved_wordsContext>(i);
}


size_t HplsqlParser::IdentContext::getRuleIndex() const {
  return HplsqlParser::RuleIdent;
}

void HplsqlParser::IdentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdent(this);
}

void HplsqlParser::IdentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdent(this);
}


antlrcpp::Any HplsqlParser::IdentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitIdent(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::IdentContext* HplsqlParser::ident() {
  IdentContext *_localctx = _tracker.createInstance<IdentContext>(_ctx, getState());
  enterRule(_localctx, 436, HplsqlParser::RuleIdent);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3283);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::L_ID: {
        setState(3281);
        match(HplsqlParser::L_ID);
        break;
      }

      case HplsqlParser::T_ACTION:
      case HplsqlParser::T_ADD2:
      case HplsqlParser::T_ALL:
      case HplsqlParser::T_ALLOCATE:
      case HplsqlParser::T_ALTER:
      case HplsqlParser::T_AND:
      case HplsqlParser::T_ANSI_NULLS:
      case HplsqlParser::T_ANSI_PADDING:
      case HplsqlParser::T_AS:
      case HplsqlParser::T_ASC:
      case HplsqlParser::T_ASSOCIATE:
      case HplsqlParser::T_AT:
      case HplsqlParser::T_AUTO_INCREMENT:
      case HplsqlParser::T_AVG:
      case HplsqlParser::T_BATCHSIZE:
      case HplsqlParser::T_BEGIN:
      case HplsqlParser::T_BETWEEN:
      case HplsqlParser::T_BIGINT:
      case HplsqlParser::T_BINARY_DOUBLE:
      case HplsqlParser::T_BINARY_FLOAT:
      case HplsqlParser::T_BIT:
      case HplsqlParser::T_BODY:
      case HplsqlParser::T_BREAK:
      case HplsqlParser::T_BY:
      case HplsqlParser::T_BYTE:
      case HplsqlParser::T_CALL:
      case HplsqlParser::T_CALLER:
      case HplsqlParser::T_CASCADE:
      case HplsqlParser::T_CASE:
      case HplsqlParser::T_CASESPECIFIC:
      case HplsqlParser::T_CAST:
      case HplsqlParser::T_CHAR:
      case HplsqlParser::T_CHARACTER:
      case HplsqlParser::T_CHARSET:
      case HplsqlParser::T_CLIENT:
      case HplsqlParser::T_CLOSE:
      case HplsqlParser::T_CLUSTERED:
      case HplsqlParser::T_CMP:
      case HplsqlParser::T_COLLECT:
      case HplsqlParser::T_COLLECTION:
      case HplsqlParser::T_COLUMN:
      case HplsqlParser::T_COMMENT:
      case HplsqlParser::T_CONSTANT:
      case HplsqlParser::T_COMMIT:
      case HplsqlParser::T_COMPRESS:
      case HplsqlParser::T_CONCAT:
      case HplsqlParser::T_CONDITION:
      case HplsqlParser::T_CONSTRAINT:
      case HplsqlParser::T_CONTINUE:
      case HplsqlParser::T_COPY:
      case HplsqlParser::T_COUNT:
      case HplsqlParser::T_COUNT_BIG:
      case HplsqlParser::T_CREATE:
      case HplsqlParser::T_CREATION:
      case HplsqlParser::T_CREATOR:
      case HplsqlParser::T_CS:
      case HplsqlParser::T_CURRENT:
      case HplsqlParser::T_CURRENT_SCHEMA:
      case HplsqlParser::T_CURSOR:
      case HplsqlParser::T_DATABASE:
      case HplsqlParser::T_DATA:
      case HplsqlParser::T_DATE:
      case HplsqlParser::T_DATETIME:
      case HplsqlParser::T_DAY:
      case HplsqlParser::T_DAYS:
      case HplsqlParser::T_DEC:
      case HplsqlParser::T_DECIMAL:
      case HplsqlParser::T_DECLARE:
      case HplsqlParser::T_DEFAULT:
      case HplsqlParser::T_DEFERRED:
      case HplsqlParser::T_DEFINED:
      case HplsqlParser::T_DEFINER:
      case HplsqlParser::T_DEFINITION:
      case HplsqlParser::T_DELETE:
      case HplsqlParser::T_DELIMITED:
      case HplsqlParser::T_DELIMITER:
      case HplsqlParser::T_DESC:
      case HplsqlParser::T_DESCRIBE:
      case HplsqlParser::T_DIAGNOSTICS:
      case HplsqlParser::T_DIR:
      case HplsqlParser::T_DIRECTORY:
      case HplsqlParser::T_DISTINCT:
      case HplsqlParser::T_DISTRIBUTE:
      case HplsqlParser::T_DO:
      case HplsqlParser::T_DOUBLE:
      case HplsqlParser::T_DROP:
      case HplsqlParser::T_DYNAMIC:
      case HplsqlParser::T_ENABLE:
      case HplsqlParser::T_ENGINE:
      case HplsqlParser::T_ESCAPED:
      case HplsqlParser::T_EXCEPT:
      case HplsqlParser::T_EXEC:
      case HplsqlParser::T_EXECUTE:
      case HplsqlParser::T_EXCEPTION:
      case HplsqlParser::T_EXCLUSIVE:
      case HplsqlParser::T_EXISTS:
      case HplsqlParser::T_EXIT:
      case HplsqlParser::T_FALLBACK:
      case HplsqlParser::T_FALSE:
      case HplsqlParser::T_FETCH:
      case HplsqlParser::T_FIELDS:
      case HplsqlParser::T_FILE:
      case HplsqlParser::T_FILES:
      case HplsqlParser::T_FLOAT:
      case HplsqlParser::T_FOR:
      case HplsqlParser::T_FOREIGN:
      case HplsqlParser::T_FORMAT:
      case HplsqlParser::T_FOUND:
      case HplsqlParser::T_FROM:
      case HplsqlParser::T_FULL:
      case HplsqlParser::T_FUNCTION:
      case HplsqlParser::T_GET:
      case HplsqlParser::T_GLOBAL:
      case HplsqlParser::T_GO:
      case HplsqlParser::T_GRANT:
      case HplsqlParser::T_GROUP:
      case HplsqlParser::T_HANDLER:
      case HplsqlParser::T_HASH:
      case HplsqlParser::T_HAVING:
      case HplsqlParser::T_HDFS:
      case HplsqlParser::T_HIVE:
      case HplsqlParser::T_HOST:
      case HplsqlParser::T_IDENTITY:
      case HplsqlParser::T_IF:
      case HplsqlParser::T_IGNORE:
      case HplsqlParser::T_IMMEDIATE:
      case HplsqlParser::T_IN:
      case HplsqlParser::T_INCLUDE:
      case HplsqlParser::T_INDEX:
      case HplsqlParser::T_INITRANS:
      case HplsqlParser::T_INNER:
      case HplsqlParser::T_INOUT:
      case HplsqlParser::T_INSERT:
      case HplsqlParser::T_INT:
      case HplsqlParser::T_INT2:
      case HplsqlParser::T_INT4:
      case HplsqlParser::T_INT8:
      case HplsqlParser::T_INTEGER:
      case HplsqlParser::T_INTERSECT:
      case HplsqlParser::T_INTERVAL:
      case HplsqlParser::T_INTO:
      case HplsqlParser::T_INVOKER:
      case HplsqlParser::T_IS:
      case HplsqlParser::T_ISOPEN:
      case HplsqlParser::T_ITEMS:
      case HplsqlParser::T_JOIN:
      case HplsqlParser::T_KEEP:
      case HplsqlParser::T_KEY:
      case HplsqlParser::T_KEYS:
      case HplsqlParser::T_LANGUAGE:
      case HplsqlParser::T_LEAVE:
      case HplsqlParser::T_LEFT:
      case HplsqlParser::T_LIKE:
      case HplsqlParser::T_LIMIT:
      case HplsqlParser::T_LINES:
      case HplsqlParser::T_LOCAL:
      case HplsqlParser::T_LOCATION:
      case HplsqlParser::T_LOCATOR:
      case HplsqlParser::T_LOCATORS:
      case HplsqlParser::T_LOCKS:
      case HplsqlParser::T_LOG:
      case HplsqlParser::T_LOGGED:
      case HplsqlParser::T_LOGGING:
      case HplsqlParser::T_LOOP:
      case HplsqlParser::T_MAP:
      case HplsqlParser::T_MATCHED:
      case HplsqlParser::T_MAX:
      case HplsqlParser::T_MAXTRANS:
      case HplsqlParser::T_MERGE:
      case HplsqlParser::T_MESSAGE_TEXT:
      case HplsqlParser::T_MICROSECOND:
      case HplsqlParser::T_MICROSECONDS:
      case HplsqlParser::T_MIN:
      case HplsqlParser::T_MULTISET:
      case HplsqlParser::T_NCHAR:
      case HplsqlParser::T_NEW:
      case HplsqlParser::T_NVARCHAR:
      case HplsqlParser::T_NO:
      case HplsqlParser::T_NOCOUNT:
      case HplsqlParser::T_NOCOMPRESS:
      case HplsqlParser::T_NOLOGGING:
      case HplsqlParser::T_NONE:
      case HplsqlParser::T_NOT:
      case HplsqlParser::T_NOTFOUND:
      case HplsqlParser::T_NUMERIC:
      case HplsqlParser::T_NUMBER:
      case HplsqlParser::T_OBJECT:
      case HplsqlParser::T_OFF:
      case HplsqlParser::T_ON:
      case HplsqlParser::T_ONLY:
      case HplsqlParser::T_OPEN:
      case HplsqlParser::T_OR:
      case HplsqlParser::T_ORDER:
      case HplsqlParser::T_OUT:
      case HplsqlParser::T_OUTER:
      case HplsqlParser::T_OVER:
      case HplsqlParser::T_OVERWRITE:
      case HplsqlParser::T_OWNER:
      case HplsqlParser::T_PACKAGE:
      case HplsqlParser::T_PARTITION:
      case HplsqlParser::T_PCTFREE:
      case HplsqlParser::T_PCTUSED:
      case HplsqlParser::T_PRECISION:
      case HplsqlParser::T_PRESERVE:
      case HplsqlParser::T_PRIMARY:
      case HplsqlParser::T_PRINT:
      case HplsqlParser::T_PROC:
      case HplsqlParser::T_PROCEDURE:
      case HplsqlParser::T_QUALIFY:
      case HplsqlParser::T_QUERY_BAND:
      case HplsqlParser::T_QUIT:
      case HplsqlParser::T_QUOTED_IDENTIFIER:
      case HplsqlParser::T_RAISE:
      case HplsqlParser::T_REAL:
      case HplsqlParser::T_REFERENCES:
      case HplsqlParser::T_REGEXP:
      case HplsqlParser::T_REPLACE:
      case HplsqlParser::T_RESIGNAL:
      case HplsqlParser::T_RESTRICT:
      case HplsqlParser::T_RESULT:
      case HplsqlParser::T_RESULT_SET_LOCATOR:
      case HplsqlParser::T_RETURN:
      case HplsqlParser::T_RETURNS:
      case HplsqlParser::T_REVERSE:
      case HplsqlParser::T_RIGHT:
      case HplsqlParser::T_RLIKE:
      case HplsqlParser::T_ROLE:
      case HplsqlParser::T_ROLLBACK:
      case HplsqlParser::T_ROW:
      case HplsqlParser::T_ROWS:
      case HplsqlParser::T_ROW_COUNT:
      case HplsqlParser::T_RR:
      case HplsqlParser::T_RS:
      case HplsqlParser::T_PWD:
      case HplsqlParser::T_TRIM:
      case HplsqlParser::T_SCHEMA:
      case HplsqlParser::T_SECOND:
      case HplsqlParser::T_SECONDS:
      case HplsqlParser::T_SECURITY:
      case HplsqlParser::T_SEGMENT:
      case HplsqlParser::T_SEL:
      case HplsqlParser::T_SELECT:
      case HplsqlParser::T_SET:
      case HplsqlParser::T_SESSION:
      case HplsqlParser::T_SESSIONS:
      case HplsqlParser::T_SETS:
      case HplsqlParser::T_SHARE:
      case HplsqlParser::T_SIGNAL:
      case HplsqlParser::T_SIMPLE_DOUBLE:
      case HplsqlParser::T_SIMPLE_FLOAT:
      case HplsqlParser::T_SMALLDATETIME:
      case HplsqlParser::T_SMALLINT:
      case HplsqlParser::T_SQL:
      case HplsqlParser::T_SQLEXCEPTION:
      case HplsqlParser::T_SQLINSERT:
      case HplsqlParser::T_SQLSTATE:
      case HplsqlParser::T_SQLWARNING:
      case HplsqlParser::T_STATS:
      case HplsqlParser::T_STATISTICS:
      case HplsqlParser::T_STEP:
      case HplsqlParser::T_STORAGE:
      case HplsqlParser::T_STORED:
      case HplsqlParser::T_STRING:
      case HplsqlParser::T_SUBDIR:
      case HplsqlParser::T_SUBSTRING:
      case HplsqlParser::T_SUM:
      case HplsqlParser::T_SYS_REFCURSOR:
      case HplsqlParser::T_TABLE:
      case HplsqlParser::T_TABLESPACE:
      case HplsqlParser::T_TEMPORARY:
      case HplsqlParser::T_TERMINATED:
      case HplsqlParser::T_TEXTIMAGE_ON:
      case HplsqlParser::T_THEN:
      case HplsqlParser::T_TIMESTAMP:
      case HplsqlParser::T_TITLE:
      case HplsqlParser::T_TO:
      case HplsqlParser::T_TOP:
      case HplsqlParser::T_TRANSACTION:
      case HplsqlParser::T_TRUE:
      case HplsqlParser::T_TRUNCATE:
      case HplsqlParser::T_UNIQUE:
      case HplsqlParser::T_UPDATE:
      case HplsqlParser::T_UR:
      case HplsqlParser::T_USE:
      case HplsqlParser::T_USING:
      case HplsqlParser::T_VALUE:
      case HplsqlParser::T_VALUES:
      case HplsqlParser::T_VAR:
      case HplsqlParser::T_VARCHAR:
      case HplsqlParser::T_VARCHAR2:
      case HplsqlParser::T_VARYING:
      case HplsqlParser::T_VOLATILE:
      case HplsqlParser::T_WHILE:
      case HplsqlParser::T_WITH:
      case HplsqlParser::T_WITHOUT:
      case HplsqlParser::T_WORK:
      case HplsqlParser::T_XACT_ABORT:
      case HplsqlParser::T_XML:
      case HplsqlParser::T_YES:
      case HplsqlParser::T_ACTIVITY_COUNT:
      case HplsqlParser::T_CUME_DIST:
      case HplsqlParser::T_CURRENT_DATE:
      case HplsqlParser::T_CURRENT_TIMESTAMP:
      case HplsqlParser::T_CURRENT_USER:
      case HplsqlParser::T_DENSE_RANK:
      case HplsqlParser::T_FIRST_VALUE:
      case HplsqlParser::T_LAG:
      case HplsqlParser::T_LAST_VALUE:
      case HplsqlParser::T_LEAD:
      case HplsqlParser::T_PART_COUNT:
      case HplsqlParser::T_PART_LOC:
      case HplsqlParser::T_RANK:
      case HplsqlParser::T_ROW_NUMBER:
      case HplsqlParser::T_STDEV:
      case HplsqlParser::T_SYSDATE:
      case HplsqlParser::T_VARIANCE:
      case HplsqlParser::T_USER: {
        setState(3282);
        non_reserved_words();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(3292);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 415, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3285);
        match(HplsqlParser::T__3);
        setState(3288);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case HplsqlParser::L_ID: {
            setState(3286);
            match(HplsqlParser::L_ID);
            break;
          }

          case HplsqlParser::T_ACTION:
          case HplsqlParser::T_ADD2:
          case HplsqlParser::T_ALL:
          case HplsqlParser::T_ALLOCATE:
          case HplsqlParser::T_ALTER:
          case HplsqlParser::T_AND:
          case HplsqlParser::T_ANSI_NULLS:
          case HplsqlParser::T_ANSI_PADDING:
          case HplsqlParser::T_AS:
          case HplsqlParser::T_ASC:
          case HplsqlParser::T_ASSOCIATE:
          case HplsqlParser::T_AT:
          case HplsqlParser::T_AUTO_INCREMENT:
          case HplsqlParser::T_AVG:
          case HplsqlParser::T_BATCHSIZE:
          case HplsqlParser::T_BEGIN:
          case HplsqlParser::T_BETWEEN:
          case HplsqlParser::T_BIGINT:
          case HplsqlParser::T_BINARY_DOUBLE:
          case HplsqlParser::T_BINARY_FLOAT:
          case HplsqlParser::T_BIT:
          case HplsqlParser::T_BODY:
          case HplsqlParser::T_BREAK:
          case HplsqlParser::T_BY:
          case HplsqlParser::T_BYTE:
          case HplsqlParser::T_CALL:
          case HplsqlParser::T_CALLER:
          case HplsqlParser::T_CASCADE:
          case HplsqlParser::T_CASE:
          case HplsqlParser::T_CASESPECIFIC:
          case HplsqlParser::T_CAST:
          case HplsqlParser::T_CHAR:
          case HplsqlParser::T_CHARACTER:
          case HplsqlParser::T_CHARSET:
          case HplsqlParser::T_CLIENT:
          case HplsqlParser::T_CLOSE:
          case HplsqlParser::T_CLUSTERED:
          case HplsqlParser::T_CMP:
          case HplsqlParser::T_COLLECT:
          case HplsqlParser::T_COLLECTION:
          case HplsqlParser::T_COLUMN:
          case HplsqlParser::T_COMMENT:
          case HplsqlParser::T_CONSTANT:
          case HplsqlParser::T_COMMIT:
          case HplsqlParser::T_COMPRESS:
          case HplsqlParser::T_CONCAT:
          case HplsqlParser::T_CONDITION:
          case HplsqlParser::T_CONSTRAINT:
          case HplsqlParser::T_CONTINUE:
          case HplsqlParser::T_COPY:
          case HplsqlParser::T_COUNT:
          case HplsqlParser::T_COUNT_BIG:
          case HplsqlParser::T_CREATE:
          case HplsqlParser::T_CREATION:
          case HplsqlParser::T_CREATOR:
          case HplsqlParser::T_CS:
          case HplsqlParser::T_CURRENT:
          case HplsqlParser::T_CURRENT_SCHEMA:
          case HplsqlParser::T_CURSOR:
          case HplsqlParser::T_DATABASE:
          case HplsqlParser::T_DATA:
          case HplsqlParser::T_DATE:
          case HplsqlParser::T_DATETIME:
          case HplsqlParser::T_DAY:
          case HplsqlParser::T_DAYS:
          case HplsqlParser::T_DEC:
          case HplsqlParser::T_DECIMAL:
          case HplsqlParser::T_DECLARE:
          case HplsqlParser::T_DEFAULT:
          case HplsqlParser::T_DEFERRED:
          case HplsqlParser::T_DEFINED:
          case HplsqlParser::T_DEFINER:
          case HplsqlParser::T_DEFINITION:
          case HplsqlParser::T_DELETE:
          case HplsqlParser::T_DELIMITED:
          case HplsqlParser::T_DELIMITER:
          case HplsqlParser::T_DESC:
          case HplsqlParser::T_DESCRIBE:
          case HplsqlParser::T_DIAGNOSTICS:
          case HplsqlParser::T_DIR:
          case HplsqlParser::T_DIRECTORY:
          case HplsqlParser::T_DISTINCT:
          case HplsqlParser::T_DISTRIBUTE:
          case HplsqlParser::T_DO:
          case HplsqlParser::T_DOUBLE:
          case HplsqlParser::T_DROP:
          case HplsqlParser::T_DYNAMIC:
          case HplsqlParser::T_ENABLE:
          case HplsqlParser::T_ENGINE:
          case HplsqlParser::T_ESCAPED:
          case HplsqlParser::T_EXCEPT:
          case HplsqlParser::T_EXEC:
          case HplsqlParser::T_EXECUTE:
          case HplsqlParser::T_EXCEPTION:
          case HplsqlParser::T_EXCLUSIVE:
          case HplsqlParser::T_EXISTS:
          case HplsqlParser::T_EXIT:
          case HplsqlParser::T_FALLBACK:
          case HplsqlParser::T_FALSE:
          case HplsqlParser::T_FETCH:
          case HplsqlParser::T_FIELDS:
          case HplsqlParser::T_FILE:
          case HplsqlParser::T_FILES:
          case HplsqlParser::T_FLOAT:
          case HplsqlParser::T_FOR:
          case HplsqlParser::T_FOREIGN:
          case HplsqlParser::T_FORMAT:
          case HplsqlParser::T_FOUND:
          case HplsqlParser::T_FROM:
          case HplsqlParser::T_FULL:
          case HplsqlParser::T_FUNCTION:
          case HplsqlParser::T_GET:
          case HplsqlParser::T_GLOBAL:
          case HplsqlParser::T_GO:
          case HplsqlParser::T_GRANT:
          case HplsqlParser::T_GROUP:
          case HplsqlParser::T_HANDLER:
          case HplsqlParser::T_HASH:
          case HplsqlParser::T_HAVING:
          case HplsqlParser::T_HDFS:
          case HplsqlParser::T_HIVE:
          case HplsqlParser::T_HOST:
          case HplsqlParser::T_IDENTITY:
          case HplsqlParser::T_IF:
          case HplsqlParser::T_IGNORE:
          case HplsqlParser::T_IMMEDIATE:
          case HplsqlParser::T_IN:
          case HplsqlParser::T_INCLUDE:
          case HplsqlParser::T_INDEX:
          case HplsqlParser::T_INITRANS:
          case HplsqlParser::T_INNER:
          case HplsqlParser::T_INOUT:
          case HplsqlParser::T_INSERT:
          case HplsqlParser::T_INT:
          case HplsqlParser::T_INT2:
          case HplsqlParser::T_INT4:
          case HplsqlParser::T_INT8:
          case HplsqlParser::T_INTEGER:
          case HplsqlParser::T_INTERSECT:
          case HplsqlParser::T_INTERVAL:
          case HplsqlParser::T_INTO:
          case HplsqlParser::T_INVOKER:
          case HplsqlParser::T_IS:
          case HplsqlParser::T_ISOPEN:
          case HplsqlParser::T_ITEMS:
          case HplsqlParser::T_JOIN:
          case HplsqlParser::T_KEEP:
          case HplsqlParser::T_KEY:
          case HplsqlParser::T_KEYS:
          case HplsqlParser::T_LANGUAGE:
          case HplsqlParser::T_LEAVE:
          case HplsqlParser::T_LEFT:
          case HplsqlParser::T_LIKE:
          case HplsqlParser::T_LIMIT:
          case HplsqlParser::T_LINES:
          case HplsqlParser::T_LOCAL:
          case HplsqlParser::T_LOCATION:
          case HplsqlParser::T_LOCATOR:
          case HplsqlParser::T_LOCATORS:
          case HplsqlParser::T_LOCKS:
          case HplsqlParser::T_LOG:
          case HplsqlParser::T_LOGGED:
          case HplsqlParser::T_LOGGING:
          case HplsqlParser::T_LOOP:
          case HplsqlParser::T_MAP:
          case HplsqlParser::T_MATCHED:
          case HplsqlParser::T_MAX:
          case HplsqlParser::T_MAXTRANS:
          case HplsqlParser::T_MERGE:
          case HplsqlParser::T_MESSAGE_TEXT:
          case HplsqlParser::T_MICROSECOND:
          case HplsqlParser::T_MICROSECONDS:
          case HplsqlParser::T_MIN:
          case HplsqlParser::T_MULTISET:
          case HplsqlParser::T_NCHAR:
          case HplsqlParser::T_NEW:
          case HplsqlParser::T_NVARCHAR:
          case HplsqlParser::T_NO:
          case HplsqlParser::T_NOCOUNT:
          case HplsqlParser::T_NOCOMPRESS:
          case HplsqlParser::T_NOLOGGING:
          case HplsqlParser::T_NONE:
          case HplsqlParser::T_NOT:
          case HplsqlParser::T_NOTFOUND:
          case HplsqlParser::T_NUMERIC:
          case HplsqlParser::T_NUMBER:
          case HplsqlParser::T_OBJECT:
          case HplsqlParser::T_OFF:
          case HplsqlParser::T_ON:
          case HplsqlParser::T_ONLY:
          case HplsqlParser::T_OPEN:
          case HplsqlParser::T_OR:
          case HplsqlParser::T_ORDER:
          case HplsqlParser::T_OUT:
          case HplsqlParser::T_OUTER:
          case HplsqlParser::T_OVER:
          case HplsqlParser::T_OVERWRITE:
          case HplsqlParser::T_OWNER:
          case HplsqlParser::T_PACKAGE:
          case HplsqlParser::T_PARTITION:
          case HplsqlParser::T_PCTFREE:
          case HplsqlParser::T_PCTUSED:
          case HplsqlParser::T_PRECISION:
          case HplsqlParser::T_PRESERVE:
          case HplsqlParser::T_PRIMARY:
          case HplsqlParser::T_PRINT:
          case HplsqlParser::T_PROC:
          case HplsqlParser::T_PROCEDURE:
          case HplsqlParser::T_QUALIFY:
          case HplsqlParser::T_QUERY_BAND:
          case HplsqlParser::T_QUIT:
          case HplsqlParser::T_QUOTED_IDENTIFIER:
          case HplsqlParser::T_RAISE:
          case HplsqlParser::T_REAL:
          case HplsqlParser::T_REFERENCES:
          case HplsqlParser::T_REGEXP:
          case HplsqlParser::T_REPLACE:
          case HplsqlParser::T_RESIGNAL:
          case HplsqlParser::T_RESTRICT:
          case HplsqlParser::T_RESULT:
          case HplsqlParser::T_RESULT_SET_LOCATOR:
          case HplsqlParser::T_RETURN:
          case HplsqlParser::T_RETURNS:
          case HplsqlParser::T_REVERSE:
          case HplsqlParser::T_RIGHT:
          case HplsqlParser::T_RLIKE:
          case HplsqlParser::T_ROLE:
          case HplsqlParser::T_ROLLBACK:
          case HplsqlParser::T_ROW:
          case HplsqlParser::T_ROWS:
          case HplsqlParser::T_ROW_COUNT:
          case HplsqlParser::T_RR:
          case HplsqlParser::T_RS:
          case HplsqlParser::T_PWD:
          case HplsqlParser::T_TRIM:
          case HplsqlParser::T_SCHEMA:
          case HplsqlParser::T_SECOND:
          case HplsqlParser::T_SECONDS:
          case HplsqlParser::T_SECURITY:
          case HplsqlParser::T_SEGMENT:
          case HplsqlParser::T_SEL:
          case HplsqlParser::T_SELECT:
          case HplsqlParser::T_SET:
          case HplsqlParser::T_SESSION:
          case HplsqlParser::T_SESSIONS:
          case HplsqlParser::T_SETS:
          case HplsqlParser::T_SHARE:
          case HplsqlParser::T_SIGNAL:
          case HplsqlParser::T_SIMPLE_DOUBLE:
          case HplsqlParser::T_SIMPLE_FLOAT:
          case HplsqlParser::T_SMALLDATETIME:
          case HplsqlParser::T_SMALLINT:
          case HplsqlParser::T_SQL:
          case HplsqlParser::T_SQLEXCEPTION:
          case HplsqlParser::T_SQLINSERT:
          case HplsqlParser::T_SQLSTATE:
          case HplsqlParser::T_SQLWARNING:
          case HplsqlParser::T_STATS:
          case HplsqlParser::T_STATISTICS:
          case HplsqlParser::T_STEP:
          case HplsqlParser::T_STORAGE:
          case HplsqlParser::T_STORED:
          case HplsqlParser::T_STRING:
          case HplsqlParser::T_SUBDIR:
          case HplsqlParser::T_SUBSTRING:
          case HplsqlParser::T_SUM:
          case HplsqlParser::T_SYS_REFCURSOR:
          case HplsqlParser::T_TABLE:
          case HplsqlParser::T_TABLESPACE:
          case HplsqlParser::T_TEMPORARY:
          case HplsqlParser::T_TERMINATED:
          case HplsqlParser::T_TEXTIMAGE_ON:
          case HplsqlParser::T_THEN:
          case HplsqlParser::T_TIMESTAMP:
          case HplsqlParser::T_TITLE:
          case HplsqlParser::T_TO:
          case HplsqlParser::T_TOP:
          case HplsqlParser::T_TRANSACTION:
          case HplsqlParser::T_TRUE:
          case HplsqlParser::T_TRUNCATE:
          case HplsqlParser::T_UNIQUE:
          case HplsqlParser::T_UPDATE:
          case HplsqlParser::T_UR:
          case HplsqlParser::T_USE:
          case HplsqlParser::T_USING:
          case HplsqlParser::T_VALUE:
          case HplsqlParser::T_VALUES:
          case HplsqlParser::T_VAR:
          case HplsqlParser::T_VARCHAR:
          case HplsqlParser::T_VARCHAR2:
          case HplsqlParser::T_VARYING:
          case HplsqlParser::T_VOLATILE:
          case HplsqlParser::T_WHILE:
          case HplsqlParser::T_WITH:
          case HplsqlParser::T_WITHOUT:
          case HplsqlParser::T_WORK:
          case HplsqlParser::T_XACT_ABORT:
          case HplsqlParser::T_XML:
          case HplsqlParser::T_YES:
          case HplsqlParser::T_ACTIVITY_COUNT:
          case HplsqlParser::T_CUME_DIST:
          case HplsqlParser::T_CURRENT_DATE:
          case HplsqlParser::T_CURRENT_TIMESTAMP:
          case HplsqlParser::T_CURRENT_USER:
          case HplsqlParser::T_DENSE_RANK:
          case HplsqlParser::T_FIRST_VALUE:
          case HplsqlParser::T_LAG:
          case HplsqlParser::T_LAST_VALUE:
          case HplsqlParser::T_LEAD:
          case HplsqlParser::T_PART_COUNT:
          case HplsqlParser::T_PART_LOC:
          case HplsqlParser::T_RANK:
          case HplsqlParser::T_ROW_NUMBER:
          case HplsqlParser::T_STDEV:
          case HplsqlParser::T_SYSDATE:
          case HplsqlParser::T_VARIANCE:
          case HplsqlParser::T_USER: {
            setState(3287);
            non_reserved_words();
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(3294);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 415, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringContext ------------------------------------------------------------------

HplsqlParser::StringContext::StringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t HplsqlParser::StringContext::getRuleIndex() const {
  return HplsqlParser::RuleString;
}

void HplsqlParser::StringContext::copyFrom(StringContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Double_quotedStringContext ------------------------------------------------------------------

tree::TerminalNode* HplsqlParser::Double_quotedStringContext::L_D_STRING() {
  return getToken(HplsqlParser::L_D_STRING, 0);
}

HplsqlParser::Double_quotedStringContext::Double_quotedStringContext(StringContext *ctx) { copyFrom(ctx); }

void HplsqlParser::Double_quotedStringContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDouble_quotedString(this);
}
void HplsqlParser::Double_quotedStringContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDouble_quotedString(this);
}

antlrcpp::Any HplsqlParser::Double_quotedStringContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitDouble_quotedString(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Single_quotedStringContext ------------------------------------------------------------------

tree::TerminalNode* HplsqlParser::Single_quotedStringContext::L_S_STRING() {
  return getToken(HplsqlParser::L_S_STRING, 0);
}

HplsqlParser::Single_quotedStringContext::Single_quotedStringContext(StringContext *ctx) { copyFrom(ctx); }

void HplsqlParser::Single_quotedStringContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingle_quotedString(this);
}
void HplsqlParser::Single_quotedStringContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingle_quotedString(this);
}

antlrcpp::Any HplsqlParser::Single_quotedStringContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitSingle_quotedString(this);
  else
    return visitor->visitChildren(this);
}
HplsqlParser::StringContext* HplsqlParser::string() {
  StringContext *_localctx = _tracker.createInstance<StringContext>(_ctx, getState());
  enterRule(_localctx, 438, HplsqlParser::RuleString);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3297);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case HplsqlParser::L_S_STRING: {
        _localctx = dynamic_cast<StringContext *>(_tracker.createInstance<HplsqlParser::Single_quotedStringContext>(_localctx));
        enterOuterAlt(_localctx, 1);
        setState(3295);
        match(HplsqlParser::L_S_STRING);
        break;
      }

      case HplsqlParser::L_D_STRING: {
        _localctx = dynamic_cast<StringContext *>(_tracker.createInstance<HplsqlParser::Double_quotedStringContext>(_localctx));
        enterOuterAlt(_localctx, 2);
        setState(3296);
        match(HplsqlParser::L_D_STRING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Int_numberContext ------------------------------------------------------------------

HplsqlParser::Int_numberContext::Int_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Int_numberContext::L_INT() {
  return getToken(HplsqlParser::L_INT, 0);
}

tree::TerminalNode* HplsqlParser::Int_numberContext::T_SUB() {
  return getToken(HplsqlParser::T_SUB, 0);
}

tree::TerminalNode* HplsqlParser::Int_numberContext::T_ADD() {
  return getToken(HplsqlParser::T_ADD, 0);
}


size_t HplsqlParser::Int_numberContext::getRuleIndex() const {
  return HplsqlParser::RuleInt_number;
}

void HplsqlParser::Int_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInt_number(this);
}

void HplsqlParser::Int_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInt_number(this);
}


antlrcpp::Any HplsqlParser::Int_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitInt_number(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Int_numberContext* HplsqlParser::int_number() {
  Int_numberContext *_localctx = _tracker.createInstance<Int_numberContext>(_ctx, getState());
  enterRule(_localctx, 440, HplsqlParser::RuleInt_number);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3300);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_ADD

    || _la == HplsqlParser::T_SUB) {
      setState(3299);
      _la = _input->LA(1);
      if (!(_la == HplsqlParser::T_ADD

      || _la == HplsqlParser::T_SUB)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3302);
    match(HplsqlParser::L_INT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dec_numberContext ------------------------------------------------------------------

HplsqlParser::Dec_numberContext::Dec_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Dec_numberContext::L_DEC() {
  return getToken(HplsqlParser::L_DEC, 0);
}

tree::TerminalNode* HplsqlParser::Dec_numberContext::T_SUB() {
  return getToken(HplsqlParser::T_SUB, 0);
}

tree::TerminalNode* HplsqlParser::Dec_numberContext::T_ADD() {
  return getToken(HplsqlParser::T_ADD, 0);
}


size_t HplsqlParser::Dec_numberContext::getRuleIndex() const {
  return HplsqlParser::RuleDec_number;
}

void HplsqlParser::Dec_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDec_number(this);
}

void HplsqlParser::Dec_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDec_number(this);
}


antlrcpp::Any HplsqlParser::Dec_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitDec_number(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Dec_numberContext* HplsqlParser::dec_number() {
  Dec_numberContext *_localctx = _tracker.createInstance<Dec_numberContext>(_ctx, getState());
  enterRule(_localctx, 442, HplsqlParser::RuleDec_number);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3305);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == HplsqlParser::T_ADD

    || _la == HplsqlParser::T_SUB) {
      setState(3304);
      _la = _input->LA(1);
      if (!(_la == HplsqlParser::T_ADD

      || _la == HplsqlParser::T_SUB)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3307);
    match(HplsqlParser::L_DEC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bool_literalContext ------------------------------------------------------------------

HplsqlParser::Bool_literalContext::Bool_literalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Bool_literalContext::T_TRUE() {
  return getToken(HplsqlParser::T_TRUE, 0);
}

tree::TerminalNode* HplsqlParser::Bool_literalContext::T_FALSE() {
  return getToken(HplsqlParser::T_FALSE, 0);
}


size_t HplsqlParser::Bool_literalContext::getRuleIndex() const {
  return HplsqlParser::RuleBool_literal;
}

void HplsqlParser::Bool_literalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBool_literal(this);
}

void HplsqlParser::Bool_literalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBool_literal(this);
}


antlrcpp::Any HplsqlParser::Bool_literalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitBool_literal(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Bool_literalContext* HplsqlParser::bool_literal() {
  Bool_literalContext *_localctx = _tracker.createInstance<Bool_literalContext>(_ctx, getState());
  enterRule(_localctx, 444, HplsqlParser::RuleBool_literal);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3309);
    _la = _input->LA(1);
    if (!(_la == HplsqlParser::T_FALSE || _la == HplsqlParser::T_TRUE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Null_constContext ------------------------------------------------------------------

HplsqlParser::Null_constContext::Null_constContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Null_constContext::T_NULL() {
  return getToken(HplsqlParser::T_NULL, 0);
}


size_t HplsqlParser::Null_constContext::getRuleIndex() const {
  return HplsqlParser::RuleNull_const;
}

void HplsqlParser::Null_constContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNull_const(this);
}

void HplsqlParser::Null_constContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNull_const(this);
}


antlrcpp::Any HplsqlParser::Null_constContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitNull_const(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Null_constContext* HplsqlParser::null_const() {
  Null_constContext *_localctx = _tracker.createInstance<Null_constContext>(_ctx, getState());
  enterRule(_localctx, 446, HplsqlParser::RuleNull_const);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3311);
    match(HplsqlParser::T_NULL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Non_reserved_wordsContext ------------------------------------------------------------------

HplsqlParser::Non_reserved_wordsContext::Non_reserved_wordsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ACTION() {
  return getToken(HplsqlParser::T_ACTION, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ACTIVITY_COUNT() {
  return getToken(HplsqlParser::T_ACTIVITY_COUNT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ADD2() {
  return getToken(HplsqlParser::T_ADD2, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ALL() {
  return getToken(HplsqlParser::T_ALL, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ALLOCATE() {
  return getToken(HplsqlParser::T_ALLOCATE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ALTER() {
  return getToken(HplsqlParser::T_ALTER, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_AND() {
  return getToken(HplsqlParser::T_AND, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ANSI_NULLS() {
  return getToken(HplsqlParser::T_ANSI_NULLS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ANSI_PADDING() {
  return getToken(HplsqlParser::T_ANSI_PADDING, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_AS() {
  return getToken(HplsqlParser::T_AS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ASC() {
  return getToken(HplsqlParser::T_ASC, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ASSOCIATE() {
  return getToken(HplsqlParser::T_ASSOCIATE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_AT() {
  return getToken(HplsqlParser::T_AT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_AUTO_INCREMENT() {
  return getToken(HplsqlParser::T_AUTO_INCREMENT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_AVG() {
  return getToken(HplsqlParser::T_AVG, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_BATCHSIZE() {
  return getToken(HplsqlParser::T_BATCHSIZE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_BEGIN() {
  return getToken(HplsqlParser::T_BEGIN, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_BETWEEN() {
  return getToken(HplsqlParser::T_BETWEEN, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_BIGINT() {
  return getToken(HplsqlParser::T_BIGINT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_BINARY_DOUBLE() {
  return getToken(HplsqlParser::T_BINARY_DOUBLE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_BINARY_FLOAT() {
  return getToken(HplsqlParser::T_BINARY_FLOAT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_BIT() {
  return getToken(HplsqlParser::T_BIT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_BODY() {
  return getToken(HplsqlParser::T_BODY, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_BREAK() {
  return getToken(HplsqlParser::T_BREAK, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_BY() {
  return getToken(HplsqlParser::T_BY, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_BYTE() {
  return getToken(HplsqlParser::T_BYTE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CALL() {
  return getToken(HplsqlParser::T_CALL, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CALLER() {
  return getToken(HplsqlParser::T_CALLER, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CASCADE() {
  return getToken(HplsqlParser::T_CASCADE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CASE() {
  return getToken(HplsqlParser::T_CASE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CASESPECIFIC() {
  return getToken(HplsqlParser::T_CASESPECIFIC, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CAST() {
  return getToken(HplsqlParser::T_CAST, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CHAR() {
  return getToken(HplsqlParser::T_CHAR, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CHARACTER() {
  return getToken(HplsqlParser::T_CHARACTER, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CHARSET() {
  return getToken(HplsqlParser::T_CHARSET, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CLIENT() {
  return getToken(HplsqlParser::T_CLIENT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CLOSE() {
  return getToken(HplsqlParser::T_CLOSE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CLUSTERED() {
  return getToken(HplsqlParser::T_CLUSTERED, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CMP() {
  return getToken(HplsqlParser::T_CMP, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_COLLECT() {
  return getToken(HplsqlParser::T_COLLECT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_COLLECTION() {
  return getToken(HplsqlParser::T_COLLECTION, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_COLUMN() {
  return getToken(HplsqlParser::T_COLUMN, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_COMMENT() {
  return getToken(HplsqlParser::T_COMMENT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_COMPRESS() {
  return getToken(HplsqlParser::T_COMPRESS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CONSTANT() {
  return getToken(HplsqlParser::T_CONSTANT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_COPY() {
  return getToken(HplsqlParser::T_COPY, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_COMMIT() {
  return getToken(HplsqlParser::T_COMMIT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CONCAT() {
  return getToken(HplsqlParser::T_CONCAT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CONDITION() {
  return getToken(HplsqlParser::T_CONDITION, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CONSTRAINT() {
  return getToken(HplsqlParser::T_CONSTRAINT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CONTINUE() {
  return getToken(HplsqlParser::T_CONTINUE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_COUNT() {
  return getToken(HplsqlParser::T_COUNT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_COUNT_BIG() {
  return getToken(HplsqlParser::T_COUNT_BIG, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CREATE() {
  return getToken(HplsqlParser::T_CREATE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CREATION() {
  return getToken(HplsqlParser::T_CREATION, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CREATOR() {
  return getToken(HplsqlParser::T_CREATOR, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CS() {
  return getToken(HplsqlParser::T_CS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CUME_DIST() {
  return getToken(HplsqlParser::T_CUME_DIST, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CURRENT() {
  return getToken(HplsqlParser::T_CURRENT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CURRENT_DATE() {
  return getToken(HplsqlParser::T_CURRENT_DATE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CURRENT_SCHEMA() {
  return getToken(HplsqlParser::T_CURRENT_SCHEMA, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CURRENT_TIMESTAMP() {
  return getToken(HplsqlParser::T_CURRENT_TIMESTAMP, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CURRENT_USER() {
  return getToken(HplsqlParser::T_CURRENT_USER, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_CURSOR() {
  return getToken(HplsqlParser::T_CURSOR, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DATA() {
  return getToken(HplsqlParser::T_DATA, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DATABASE() {
  return getToken(HplsqlParser::T_DATABASE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DATE() {
  return getToken(HplsqlParser::T_DATE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DATETIME() {
  return getToken(HplsqlParser::T_DATETIME, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DAY() {
  return getToken(HplsqlParser::T_DAY, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DAYS() {
  return getToken(HplsqlParser::T_DAYS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DEC() {
  return getToken(HplsqlParser::T_DEC, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DECIMAL() {
  return getToken(HplsqlParser::T_DECIMAL, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DECLARE() {
  return getToken(HplsqlParser::T_DECLARE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DEFAULT() {
  return getToken(HplsqlParser::T_DEFAULT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DEFERRED() {
  return getToken(HplsqlParser::T_DEFERRED, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DEFINED() {
  return getToken(HplsqlParser::T_DEFINED, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DEFINER() {
  return getToken(HplsqlParser::T_DEFINER, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DEFINITION() {
  return getToken(HplsqlParser::T_DEFINITION, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DELETE() {
  return getToken(HplsqlParser::T_DELETE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DELIMITED() {
  return getToken(HplsqlParser::T_DELIMITED, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DELIMITER() {
  return getToken(HplsqlParser::T_DELIMITER, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DENSE_RANK() {
  return getToken(HplsqlParser::T_DENSE_RANK, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DESC() {
  return getToken(HplsqlParser::T_DESC, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DESCRIBE() {
  return getToken(HplsqlParser::T_DESCRIBE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DIAGNOSTICS() {
  return getToken(HplsqlParser::T_DIAGNOSTICS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DIR() {
  return getToken(HplsqlParser::T_DIR, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DIRECTORY() {
  return getToken(HplsqlParser::T_DIRECTORY, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DISTINCT() {
  return getToken(HplsqlParser::T_DISTINCT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DISTRIBUTE() {
  return getToken(HplsqlParser::T_DISTRIBUTE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DO() {
  return getToken(HplsqlParser::T_DO, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DOUBLE() {
  return getToken(HplsqlParser::T_DOUBLE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DROP() {
  return getToken(HplsqlParser::T_DROP, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_DYNAMIC() {
  return getToken(HplsqlParser::T_DYNAMIC, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ENABLE() {
  return getToken(HplsqlParser::T_ENABLE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ENGINE() {
  return getToken(HplsqlParser::T_ENGINE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ESCAPED() {
  return getToken(HplsqlParser::T_ESCAPED, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_EXCEPT() {
  return getToken(HplsqlParser::T_EXCEPT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_EXEC() {
  return getToken(HplsqlParser::T_EXEC, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_EXECUTE() {
  return getToken(HplsqlParser::T_EXECUTE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_EXCEPTION() {
  return getToken(HplsqlParser::T_EXCEPTION, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_EXCLUSIVE() {
  return getToken(HplsqlParser::T_EXCLUSIVE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_EXISTS() {
  return getToken(HplsqlParser::T_EXISTS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_EXIT() {
  return getToken(HplsqlParser::T_EXIT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_FALLBACK() {
  return getToken(HplsqlParser::T_FALLBACK, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_FALSE() {
  return getToken(HplsqlParser::T_FALSE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_FETCH() {
  return getToken(HplsqlParser::T_FETCH, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_FIELDS() {
  return getToken(HplsqlParser::T_FIELDS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_FILE() {
  return getToken(HplsqlParser::T_FILE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_FILES() {
  return getToken(HplsqlParser::T_FILES, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_FIRST_VALUE() {
  return getToken(HplsqlParser::T_FIRST_VALUE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_FLOAT() {
  return getToken(HplsqlParser::T_FLOAT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_FOR() {
  return getToken(HplsqlParser::T_FOR, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_FOREIGN() {
  return getToken(HplsqlParser::T_FOREIGN, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_FORMAT() {
  return getToken(HplsqlParser::T_FORMAT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_FOUND() {
  return getToken(HplsqlParser::T_FOUND, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_FROM() {
  return getToken(HplsqlParser::T_FROM, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_FULL() {
  return getToken(HplsqlParser::T_FULL, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_FUNCTION() {
  return getToken(HplsqlParser::T_FUNCTION, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_GET() {
  return getToken(HplsqlParser::T_GET, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_GLOBAL() {
  return getToken(HplsqlParser::T_GLOBAL, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_GO() {
  return getToken(HplsqlParser::T_GO, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_GRANT() {
  return getToken(HplsqlParser::T_GRANT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_GROUP() {
  return getToken(HplsqlParser::T_GROUP, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_HANDLER() {
  return getToken(HplsqlParser::T_HANDLER, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_HASH() {
  return getToken(HplsqlParser::T_HASH, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_HAVING() {
  return getToken(HplsqlParser::T_HAVING, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_HDFS() {
  return getToken(HplsqlParser::T_HDFS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_HIVE() {
  return getToken(HplsqlParser::T_HIVE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_HOST() {
  return getToken(HplsqlParser::T_HOST, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_IDENTITY() {
  return getToken(HplsqlParser::T_IDENTITY, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_IF() {
  return getToken(HplsqlParser::T_IF, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_IGNORE() {
  return getToken(HplsqlParser::T_IGNORE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_IMMEDIATE() {
  return getToken(HplsqlParser::T_IMMEDIATE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_IN() {
  return getToken(HplsqlParser::T_IN, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_INCLUDE() {
  return getToken(HplsqlParser::T_INCLUDE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_INDEX() {
  return getToken(HplsqlParser::T_INDEX, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_INITRANS() {
  return getToken(HplsqlParser::T_INITRANS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_INNER() {
  return getToken(HplsqlParser::T_INNER, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_INOUT() {
  return getToken(HplsqlParser::T_INOUT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_INSERT() {
  return getToken(HplsqlParser::T_INSERT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_INT() {
  return getToken(HplsqlParser::T_INT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_INT2() {
  return getToken(HplsqlParser::T_INT2, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_INT4() {
  return getToken(HplsqlParser::T_INT4, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_INT8() {
  return getToken(HplsqlParser::T_INT8, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_INTEGER() {
  return getToken(HplsqlParser::T_INTEGER, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_INTERSECT() {
  return getToken(HplsqlParser::T_INTERSECT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_INTERVAL() {
  return getToken(HplsqlParser::T_INTERVAL, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_INTO() {
  return getToken(HplsqlParser::T_INTO, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_INVOKER() {
  return getToken(HplsqlParser::T_INVOKER, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ITEMS() {
  return getToken(HplsqlParser::T_ITEMS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_IS() {
  return getToken(HplsqlParser::T_IS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ISOPEN() {
  return getToken(HplsqlParser::T_ISOPEN, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_JOIN() {
  return getToken(HplsqlParser::T_JOIN, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_KEEP() {
  return getToken(HplsqlParser::T_KEEP, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_KEY() {
  return getToken(HplsqlParser::T_KEY, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_KEYS() {
  return getToken(HplsqlParser::T_KEYS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_LAG() {
  return getToken(HplsqlParser::T_LAG, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_LANGUAGE() {
  return getToken(HplsqlParser::T_LANGUAGE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_LAST_VALUE() {
  return getToken(HplsqlParser::T_LAST_VALUE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_LEAD() {
  return getToken(HplsqlParser::T_LEAD, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_LEAVE() {
  return getToken(HplsqlParser::T_LEAVE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_LEFT() {
  return getToken(HplsqlParser::T_LEFT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_LIKE() {
  return getToken(HplsqlParser::T_LIKE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_LIMIT() {
  return getToken(HplsqlParser::T_LIMIT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_LINES() {
  return getToken(HplsqlParser::T_LINES, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_LOCAL() {
  return getToken(HplsqlParser::T_LOCAL, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_LOCATION() {
  return getToken(HplsqlParser::T_LOCATION, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_LOCATOR() {
  return getToken(HplsqlParser::T_LOCATOR, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_LOCATORS() {
  return getToken(HplsqlParser::T_LOCATORS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_LOCKS() {
  return getToken(HplsqlParser::T_LOCKS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_LOG() {
  return getToken(HplsqlParser::T_LOG, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_LOGGED() {
  return getToken(HplsqlParser::T_LOGGED, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_LOGGING() {
  return getToken(HplsqlParser::T_LOGGING, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_LOOP() {
  return getToken(HplsqlParser::T_LOOP, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_MAP() {
  return getToken(HplsqlParser::T_MAP, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_MATCHED() {
  return getToken(HplsqlParser::T_MATCHED, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_MAX() {
  return getToken(HplsqlParser::T_MAX, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_MAXTRANS() {
  return getToken(HplsqlParser::T_MAXTRANS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_MERGE() {
  return getToken(HplsqlParser::T_MERGE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_MESSAGE_TEXT() {
  return getToken(HplsqlParser::T_MESSAGE_TEXT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_MICROSECOND() {
  return getToken(HplsqlParser::T_MICROSECOND, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_MICROSECONDS() {
  return getToken(HplsqlParser::T_MICROSECONDS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_MIN() {
  return getToken(HplsqlParser::T_MIN, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_MULTISET() {
  return getToken(HplsqlParser::T_MULTISET, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_NCHAR() {
  return getToken(HplsqlParser::T_NCHAR, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_NEW() {
  return getToken(HplsqlParser::T_NEW, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_NVARCHAR() {
  return getToken(HplsqlParser::T_NVARCHAR, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_NO() {
  return getToken(HplsqlParser::T_NO, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_NOCOMPRESS() {
  return getToken(HplsqlParser::T_NOCOMPRESS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_NOCOUNT() {
  return getToken(HplsqlParser::T_NOCOUNT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_NOLOGGING() {
  return getToken(HplsqlParser::T_NOLOGGING, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_NONE() {
  return getToken(HplsqlParser::T_NONE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_NOT() {
  return getToken(HplsqlParser::T_NOT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_NOTFOUND() {
  return getToken(HplsqlParser::T_NOTFOUND, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_NUMERIC() {
  return getToken(HplsqlParser::T_NUMERIC, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_NUMBER() {
  return getToken(HplsqlParser::T_NUMBER, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_OBJECT() {
  return getToken(HplsqlParser::T_OBJECT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_OFF() {
  return getToken(HplsqlParser::T_OFF, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ON() {
  return getToken(HplsqlParser::T_ON, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ONLY() {
  return getToken(HplsqlParser::T_ONLY, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_OPEN() {
  return getToken(HplsqlParser::T_OPEN, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_OR() {
  return getToken(HplsqlParser::T_OR, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ORDER() {
  return getToken(HplsqlParser::T_ORDER, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_OUT() {
  return getToken(HplsqlParser::T_OUT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_OUTER() {
  return getToken(HplsqlParser::T_OUTER, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_OVER() {
  return getToken(HplsqlParser::T_OVER, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_OVERWRITE() {
  return getToken(HplsqlParser::T_OVERWRITE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_OWNER() {
  return getToken(HplsqlParser::T_OWNER, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_PACKAGE() {
  return getToken(HplsqlParser::T_PACKAGE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_PART_COUNT() {
  return getToken(HplsqlParser::T_PART_COUNT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_PART_LOC() {
  return getToken(HplsqlParser::T_PART_LOC, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_PARTITION() {
  return getToken(HplsqlParser::T_PARTITION, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_PCTFREE() {
  return getToken(HplsqlParser::T_PCTFREE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_PCTUSED() {
  return getToken(HplsqlParser::T_PCTUSED, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_PRECISION() {
  return getToken(HplsqlParser::T_PRECISION, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_PRESERVE() {
  return getToken(HplsqlParser::T_PRESERVE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_PRIMARY() {
  return getToken(HplsqlParser::T_PRIMARY, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_PRINT() {
  return getToken(HplsqlParser::T_PRINT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_PROC() {
  return getToken(HplsqlParser::T_PROC, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_PROCEDURE() {
  return getToken(HplsqlParser::T_PROCEDURE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_PWD() {
  return getToken(HplsqlParser::T_PWD, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_QUALIFY() {
  return getToken(HplsqlParser::T_QUALIFY, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_QUERY_BAND() {
  return getToken(HplsqlParser::T_QUERY_BAND, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_QUIT() {
  return getToken(HplsqlParser::T_QUIT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_QUOTED_IDENTIFIER() {
  return getToken(HplsqlParser::T_QUOTED_IDENTIFIER, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_RAISE() {
  return getToken(HplsqlParser::T_RAISE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_RANK() {
  return getToken(HplsqlParser::T_RANK, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_REAL() {
  return getToken(HplsqlParser::T_REAL, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_REFERENCES() {
  return getToken(HplsqlParser::T_REFERENCES, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_REGEXP() {
  return getToken(HplsqlParser::T_REGEXP, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_RR() {
  return getToken(HplsqlParser::T_RR, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_REPLACE() {
  return getToken(HplsqlParser::T_REPLACE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_RESIGNAL() {
  return getToken(HplsqlParser::T_RESIGNAL, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_RESTRICT() {
  return getToken(HplsqlParser::T_RESTRICT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_RESULT() {
  return getToken(HplsqlParser::T_RESULT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_RESULT_SET_LOCATOR() {
  return getToken(HplsqlParser::T_RESULT_SET_LOCATOR, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_RETURN() {
  return getToken(HplsqlParser::T_RETURN, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_RETURNS() {
  return getToken(HplsqlParser::T_RETURNS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_REVERSE() {
  return getToken(HplsqlParser::T_REVERSE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_RIGHT() {
  return getToken(HplsqlParser::T_RIGHT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_RLIKE() {
  return getToken(HplsqlParser::T_RLIKE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_RS() {
  return getToken(HplsqlParser::T_RS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ROLE() {
  return getToken(HplsqlParser::T_ROLE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ROLLBACK() {
  return getToken(HplsqlParser::T_ROLLBACK, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ROW() {
  return getToken(HplsqlParser::T_ROW, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ROWS() {
  return getToken(HplsqlParser::T_ROWS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ROW_COUNT() {
  return getToken(HplsqlParser::T_ROW_COUNT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_ROW_NUMBER() {
  return getToken(HplsqlParser::T_ROW_NUMBER, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SCHEMA() {
  return getToken(HplsqlParser::T_SCHEMA, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SECOND() {
  return getToken(HplsqlParser::T_SECOND, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SECONDS() {
  return getToken(HplsqlParser::T_SECONDS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SECURITY() {
  return getToken(HplsqlParser::T_SECURITY, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SEGMENT() {
  return getToken(HplsqlParser::T_SEGMENT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SEL() {
  return getToken(HplsqlParser::T_SEL, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SELECT() {
  return getToken(HplsqlParser::T_SELECT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SESSION() {
  return getToken(HplsqlParser::T_SESSION, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SESSIONS() {
  return getToken(HplsqlParser::T_SESSIONS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SET() {
  return getToken(HplsqlParser::T_SET, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SETS() {
  return getToken(HplsqlParser::T_SETS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SHARE() {
  return getToken(HplsqlParser::T_SHARE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SIGNAL() {
  return getToken(HplsqlParser::T_SIGNAL, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SIMPLE_DOUBLE() {
  return getToken(HplsqlParser::T_SIMPLE_DOUBLE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SIMPLE_FLOAT() {
  return getToken(HplsqlParser::T_SIMPLE_FLOAT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SMALLDATETIME() {
  return getToken(HplsqlParser::T_SMALLDATETIME, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SMALLINT() {
  return getToken(HplsqlParser::T_SMALLINT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SQL() {
  return getToken(HplsqlParser::T_SQL, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SQLEXCEPTION() {
  return getToken(HplsqlParser::T_SQLEXCEPTION, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SQLINSERT() {
  return getToken(HplsqlParser::T_SQLINSERT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SQLSTATE() {
  return getToken(HplsqlParser::T_SQLSTATE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SQLWARNING() {
  return getToken(HplsqlParser::T_SQLWARNING, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_STATS() {
  return getToken(HplsqlParser::T_STATS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_STATISTICS() {
  return getToken(HplsqlParser::T_STATISTICS, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_STEP() {
  return getToken(HplsqlParser::T_STEP, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_STDEV() {
  return getToken(HplsqlParser::T_STDEV, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_STORAGE() {
  return getToken(HplsqlParser::T_STORAGE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_STORED() {
  return getToken(HplsqlParser::T_STORED, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_STRING() {
  return getToken(HplsqlParser::T_STRING, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SUBDIR() {
  return getToken(HplsqlParser::T_SUBDIR, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SUBSTRING() {
  return getToken(HplsqlParser::T_SUBSTRING, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SUM() {
  return getToken(HplsqlParser::T_SUM, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SYSDATE() {
  return getToken(HplsqlParser::T_SYSDATE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_SYS_REFCURSOR() {
  return getToken(HplsqlParser::T_SYS_REFCURSOR, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_TABLE() {
  return getToken(HplsqlParser::T_TABLE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_TABLESPACE() {
  return getToken(HplsqlParser::T_TABLESPACE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_TEMPORARY() {
  return getToken(HplsqlParser::T_TEMPORARY, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_TERMINATED() {
  return getToken(HplsqlParser::T_TERMINATED, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_TEXTIMAGE_ON() {
  return getToken(HplsqlParser::T_TEXTIMAGE_ON, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_THEN() {
  return getToken(HplsqlParser::T_THEN, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_TIMESTAMP() {
  return getToken(HplsqlParser::T_TIMESTAMP, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_TITLE() {
  return getToken(HplsqlParser::T_TITLE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_TO() {
  return getToken(HplsqlParser::T_TO, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_TOP() {
  return getToken(HplsqlParser::T_TOP, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_TRANSACTION() {
  return getToken(HplsqlParser::T_TRANSACTION, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_TRIM() {
  return getToken(HplsqlParser::T_TRIM, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_TRUE() {
  return getToken(HplsqlParser::T_TRUE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_TRUNCATE() {
  return getToken(HplsqlParser::T_TRUNCATE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_UNIQUE() {
  return getToken(HplsqlParser::T_UNIQUE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_UPDATE() {
  return getToken(HplsqlParser::T_UPDATE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_UR() {
  return getToken(HplsqlParser::T_UR, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_USE() {
  return getToken(HplsqlParser::T_USE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_USER() {
  return getToken(HplsqlParser::T_USER, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_USING() {
  return getToken(HplsqlParser::T_USING, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_VALUE() {
  return getToken(HplsqlParser::T_VALUE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_VALUES() {
  return getToken(HplsqlParser::T_VALUES, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_VAR() {
  return getToken(HplsqlParser::T_VAR, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_VARCHAR() {
  return getToken(HplsqlParser::T_VARCHAR, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_VARCHAR2() {
  return getToken(HplsqlParser::T_VARCHAR2, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_VARYING() {
  return getToken(HplsqlParser::T_VARYING, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_VARIANCE() {
  return getToken(HplsqlParser::T_VARIANCE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_VOLATILE() {
  return getToken(HplsqlParser::T_VOLATILE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_WHILE() {
  return getToken(HplsqlParser::T_WHILE, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_WITH() {
  return getToken(HplsqlParser::T_WITH, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_WITHOUT() {
  return getToken(HplsqlParser::T_WITHOUT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_WORK() {
  return getToken(HplsqlParser::T_WORK, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_XACT_ABORT() {
  return getToken(HplsqlParser::T_XACT_ABORT, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_XML() {
  return getToken(HplsqlParser::T_XML, 0);
}

tree::TerminalNode* HplsqlParser::Non_reserved_wordsContext::T_YES() {
  return getToken(HplsqlParser::T_YES, 0);
}


size_t HplsqlParser::Non_reserved_wordsContext::getRuleIndex() const {
  return HplsqlParser::RuleNon_reserved_words;
}

void HplsqlParser::Non_reserved_wordsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNon_reserved_words(this);
}

void HplsqlParser::Non_reserved_wordsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<HplsqlListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNon_reserved_words(this);
}


antlrcpp::Any HplsqlParser::Non_reserved_wordsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<HplsqlVisitor*>(visitor))
    return parserVisitor->visitNon_reserved_words(this);
  else
    return visitor->visitChildren(this);
}

HplsqlParser::Non_reserved_wordsContext* HplsqlParser::non_reserved_words() {
  Non_reserved_wordsContext *_localctx = _tracker.createInstance<Non_reserved_wordsContext>(_ctx, getState());
  enterRule(_localctx, 448, HplsqlParser::RuleNon_reserved_words);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3313);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << HplsqlParser::T_ACTION)
      | (1ULL << HplsqlParser::T_ADD2)
      | (1ULL << HplsqlParser::T_ALL)
      | (1ULL << HplsqlParser::T_ALLOCATE)
      | (1ULL << HplsqlParser::T_ALTER)
      | (1ULL << HplsqlParser::T_AND)
      | (1ULL << HplsqlParser::T_ANSI_NULLS)
      | (1ULL << HplsqlParser::T_ANSI_PADDING)
      | (1ULL << HplsqlParser::T_AS)
      | (1ULL << HplsqlParser::T_ASC)
      | (1ULL << HplsqlParser::T_ASSOCIATE)
      | (1ULL << HplsqlParser::T_AT)
      | (1ULL << HplsqlParser::T_AUTO_INCREMENT)
      | (1ULL << HplsqlParser::T_AVG)
      | (1ULL << HplsqlParser::T_BATCHSIZE)
      | (1ULL << HplsqlParser::T_BEGIN)
      | (1ULL << HplsqlParser::T_BETWEEN)
      | (1ULL << HplsqlParser::T_BIGINT)
      | (1ULL << HplsqlParser::T_BINARY_DOUBLE)
      | (1ULL << HplsqlParser::T_BINARY_FLOAT)
      | (1ULL << HplsqlParser::T_BIT)
      | (1ULL << HplsqlParser::T_BODY)
      | (1ULL << HplsqlParser::T_BREAK)
      | (1ULL << HplsqlParser::T_BY)
      | (1ULL << HplsqlParser::T_BYTE)
      | (1ULL << HplsqlParser::T_CALL)
      | (1ULL << HplsqlParser::T_CALLER)
      | (1ULL << HplsqlParser::T_CASCADE)
      | (1ULL << HplsqlParser::T_CASE)
      | (1ULL << HplsqlParser::T_CASESPECIFIC)
      | (1ULL << HplsqlParser::T_CAST)
      | (1ULL << HplsqlParser::T_CHAR)
      | (1ULL << HplsqlParser::T_CHARACTER)
      | (1ULL << HplsqlParser::T_CHARSET)
      | (1ULL << HplsqlParser::T_CLIENT)
      | (1ULL << HplsqlParser::T_CLOSE)
      | (1ULL << HplsqlParser::T_CLUSTERED)
      | (1ULL << HplsqlParser::T_CMP)
      | (1ULL << HplsqlParser::T_COLLECT)
      | (1ULL << HplsqlParser::T_COLLECTION)
      | (1ULL << HplsqlParser::T_COLUMN)
      | (1ULL << HplsqlParser::T_COMMENT)
      | (1ULL << HplsqlParser::T_CONSTANT)
      | (1ULL << HplsqlParser::T_COMMIT)
      | (1ULL << HplsqlParser::T_COMPRESS)
      | (1ULL << HplsqlParser::T_CONCAT)
      | (1ULL << HplsqlParser::T_CONDITION)
      | (1ULL << HplsqlParser::T_CONSTRAINT)
      | (1ULL << HplsqlParser::T_CONTINUE)
      | (1ULL << HplsqlParser::T_COPY)
      | (1ULL << HplsqlParser::T_COUNT)
      | (1ULL << HplsqlParser::T_COUNT_BIG)
      | (1ULL << HplsqlParser::T_CREATE)
      | (1ULL << HplsqlParser::T_CREATION)
      | (1ULL << HplsqlParser::T_CREATOR)
      | (1ULL << HplsqlParser::T_CS)
      | (1ULL << HplsqlParser::T_CURRENT))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (HplsqlParser::T_CURRENT_SCHEMA - 64))
      | (1ULL << (HplsqlParser::T_CURSOR - 64))
      | (1ULL << (HplsqlParser::T_DATABASE - 64))
      | (1ULL << (HplsqlParser::T_DATA - 64))
      | (1ULL << (HplsqlParser::T_DATE - 64))
      | (1ULL << (HplsqlParser::T_DATETIME - 64))
      | (1ULL << (HplsqlParser::T_DAY - 64))
      | (1ULL << (HplsqlParser::T_DAYS - 64))
      | (1ULL << (HplsqlParser::T_DEC - 64))
      | (1ULL << (HplsqlParser::T_DECIMAL - 64))
      | (1ULL << (HplsqlParser::T_DECLARE - 64))
      | (1ULL << (HplsqlParser::T_DEFAULT - 64))
      | (1ULL << (HplsqlParser::T_DEFERRED - 64))
      | (1ULL << (HplsqlParser::T_DEFINED - 64))
      | (1ULL << (HplsqlParser::T_DEFINER - 64))
      | (1ULL << (HplsqlParser::T_DEFINITION - 64))
      | (1ULL << (HplsqlParser::T_DELETE - 64))
      | (1ULL << (HplsqlParser::T_DELIMITED - 64))
      | (1ULL << (HplsqlParser::T_DELIMITER - 64))
      | (1ULL << (HplsqlParser::T_DESC - 64))
      | (1ULL << (HplsqlParser::T_DESCRIBE - 64))
      | (1ULL << (HplsqlParser::T_DIAGNOSTICS - 64))
      | (1ULL << (HplsqlParser::T_DIR - 64))
      | (1ULL << (HplsqlParser::T_DIRECTORY - 64))
      | (1ULL << (HplsqlParser::T_DISTINCT - 64))
      | (1ULL << (HplsqlParser::T_DISTRIBUTE - 64))
      | (1ULL << (HplsqlParser::T_DO - 64))
      | (1ULL << (HplsqlParser::T_DOUBLE - 64))
      | (1ULL << (HplsqlParser::T_DROP - 64))
      | (1ULL << (HplsqlParser::T_DYNAMIC - 64))
      | (1ULL << (HplsqlParser::T_ENABLE - 64))
      | (1ULL << (HplsqlParser::T_ENGINE - 64))
      | (1ULL << (HplsqlParser::T_ESCAPED - 64))
      | (1ULL << (HplsqlParser::T_EXCEPT - 64))
      | (1ULL << (HplsqlParser::T_EXEC - 64))
      | (1ULL << (HplsqlParser::T_EXECUTE - 64))
      | (1ULL << (HplsqlParser::T_EXCEPTION - 64))
      | (1ULL << (HplsqlParser::T_EXCLUSIVE - 64))
      | (1ULL << (HplsqlParser::T_EXISTS - 64))
      | (1ULL << (HplsqlParser::T_EXIT - 64))
      | (1ULL << (HplsqlParser::T_FALLBACK - 64))
      | (1ULL << (HplsqlParser::T_FALSE - 64))
      | (1ULL << (HplsqlParser::T_FETCH - 64))
      | (1ULL << (HplsqlParser::T_FIELDS - 64))
      | (1ULL << (HplsqlParser::T_FILE - 64))
      | (1ULL << (HplsqlParser::T_FILES - 64))
      | (1ULL << (HplsqlParser::T_FLOAT - 64))
      | (1ULL << (HplsqlParser::T_FOR - 64))
      | (1ULL << (HplsqlParser::T_FOREIGN - 64))
      | (1ULL << (HplsqlParser::T_FORMAT - 64))
      | (1ULL << (HplsqlParser::T_FOUND - 64))
      | (1ULL << (HplsqlParser::T_FROM - 64))
      | (1ULL << (HplsqlParser::T_FULL - 64))
      | (1ULL << (HplsqlParser::T_FUNCTION - 64))
      | (1ULL << (HplsqlParser::T_GET - 64))
      | (1ULL << (HplsqlParser::T_GLOBAL - 64))
      | (1ULL << (HplsqlParser::T_GO - 64))
      | (1ULL << (HplsqlParser::T_GRANT - 64))
      | (1ULL << (HplsqlParser::T_GROUP - 64))
      | (1ULL << (HplsqlParser::T_HANDLER - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (HplsqlParser::T_HASH - 128))
      | (1ULL << (HplsqlParser::T_HAVING - 128))
      | (1ULL << (HplsqlParser::T_HDFS - 128))
      | (1ULL << (HplsqlParser::T_HIVE - 128))
      | (1ULL << (HplsqlParser::T_HOST - 128))
      | (1ULL << (HplsqlParser::T_IDENTITY - 128))
      | (1ULL << (HplsqlParser::T_IF - 128))
      | (1ULL << (HplsqlParser::T_IGNORE - 128))
      | (1ULL << (HplsqlParser::T_IMMEDIATE - 128))
      | (1ULL << (HplsqlParser::T_IN - 128))
      | (1ULL << (HplsqlParser::T_INCLUDE - 128))
      | (1ULL << (HplsqlParser::T_INDEX - 128))
      | (1ULL << (HplsqlParser::T_INITRANS - 128))
      | (1ULL << (HplsqlParser::T_INNER - 128))
      | (1ULL << (HplsqlParser::T_INOUT - 128))
      | (1ULL << (HplsqlParser::T_INSERT - 128))
      | (1ULL << (HplsqlParser::T_INT - 128))
      | (1ULL << (HplsqlParser::T_INT2 - 128))
      | (1ULL << (HplsqlParser::T_INT4 - 128))
      | (1ULL << (HplsqlParser::T_INT8 - 128))
      | (1ULL << (HplsqlParser::T_INTEGER - 128))
      | (1ULL << (HplsqlParser::T_INTERSECT - 128))
      | (1ULL << (HplsqlParser::T_INTERVAL - 128))
      | (1ULL << (HplsqlParser::T_INTO - 128))
      | (1ULL << (HplsqlParser::T_INVOKER - 128))
      | (1ULL << (HplsqlParser::T_IS - 128))
      | (1ULL << (HplsqlParser::T_ISOPEN - 128))
      | (1ULL << (HplsqlParser::T_ITEMS - 128))
      | (1ULL << (HplsqlParser::T_JOIN - 128))
      | (1ULL << (HplsqlParser::T_KEEP - 128))
      | (1ULL << (HplsqlParser::T_KEY - 128))
      | (1ULL << (HplsqlParser::T_KEYS - 128))
      | (1ULL << (HplsqlParser::T_LANGUAGE - 128))
      | (1ULL << (HplsqlParser::T_LEAVE - 128))
      | (1ULL << (HplsqlParser::T_LEFT - 128))
      | (1ULL << (HplsqlParser::T_LIKE - 128))
      | (1ULL << (HplsqlParser::T_LIMIT - 128))
      | (1ULL << (HplsqlParser::T_LINES - 128))
      | (1ULL << (HplsqlParser::T_LOCAL - 128))
      | (1ULL << (HplsqlParser::T_LOCATION - 128))
      | (1ULL << (HplsqlParser::T_LOCATOR - 128))
      | (1ULL << (HplsqlParser::T_LOCATORS - 128))
      | (1ULL << (HplsqlParser::T_LOCKS - 128))
      | (1ULL << (HplsqlParser::T_LOG - 128))
      | (1ULL << (HplsqlParser::T_LOGGED - 128))
      | (1ULL << (HplsqlParser::T_LOGGING - 128))
      | (1ULL << (HplsqlParser::T_LOOP - 128))
      | (1ULL << (HplsqlParser::T_MAP - 128))
      | (1ULL << (HplsqlParser::T_MATCHED - 128))
      | (1ULL << (HplsqlParser::T_MAX - 128))
      | (1ULL << (HplsqlParser::T_MAXTRANS - 128))
      | (1ULL << (HplsqlParser::T_MERGE - 128))
      | (1ULL << (HplsqlParser::T_MESSAGE_TEXT - 128))
      | (1ULL << (HplsqlParser::T_MICROSECOND - 128))
      | (1ULL << (HplsqlParser::T_MICROSECONDS - 128))
      | (1ULL << (HplsqlParser::T_MIN - 128))
      | (1ULL << (HplsqlParser::T_MULTISET - 128))
      | (1ULL << (HplsqlParser::T_NCHAR - 128))
      | (1ULL << (HplsqlParser::T_NEW - 128))
      | (1ULL << (HplsqlParser::T_NVARCHAR - 128))
      | (1ULL << (HplsqlParser::T_NO - 128))
      | (1ULL << (HplsqlParser::T_NOCOUNT - 128))
      | (1ULL << (HplsqlParser::T_NOCOMPRESS - 128))
      | (1ULL << (HplsqlParser::T_NOLOGGING - 128)))) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & ((1ULL << (HplsqlParser::T_NONE - 192))
      | (1ULL << (HplsqlParser::T_NOT - 192))
      | (1ULL << (HplsqlParser::T_NOTFOUND - 192))
      | (1ULL << (HplsqlParser::T_NUMERIC - 192))
      | (1ULL << (HplsqlParser::T_NUMBER - 192))
      | (1ULL << (HplsqlParser::T_OBJECT - 192))
      | (1ULL << (HplsqlParser::T_OFF - 192))
      | (1ULL << (HplsqlParser::T_ON - 192))
      | (1ULL << (HplsqlParser::T_ONLY - 192))
      | (1ULL << (HplsqlParser::T_OPEN - 192))
      | (1ULL << (HplsqlParser::T_OR - 192))
      | (1ULL << (HplsqlParser::T_ORDER - 192))
      | (1ULL << (HplsqlParser::T_OUT - 192))
      | (1ULL << (HplsqlParser::T_OUTER - 192))
      | (1ULL << (HplsqlParser::T_OVER - 192))
      | (1ULL << (HplsqlParser::T_OVERWRITE - 192))
      | (1ULL << (HplsqlParser::T_OWNER - 192))
      | (1ULL << (HplsqlParser::T_PACKAGE - 192))
      | (1ULL << (HplsqlParser::T_PARTITION - 192))
      | (1ULL << (HplsqlParser::T_PCTFREE - 192))
      | (1ULL << (HplsqlParser::T_PCTUSED - 192))
      | (1ULL << (HplsqlParser::T_PRECISION - 192))
      | (1ULL << (HplsqlParser::T_PRESERVE - 192))
      | (1ULL << (HplsqlParser::T_PRIMARY - 192))
      | (1ULL << (HplsqlParser::T_PRINT - 192))
      | (1ULL << (HplsqlParser::T_PROC - 192))
      | (1ULL << (HplsqlParser::T_PROCEDURE - 192))
      | (1ULL << (HplsqlParser::T_QUALIFY - 192))
      | (1ULL << (HplsqlParser::T_QUERY_BAND - 192))
      | (1ULL << (HplsqlParser::T_QUIT - 192))
      | (1ULL << (HplsqlParser::T_QUOTED_IDENTIFIER - 192))
      | (1ULL << (HplsqlParser::T_RAISE - 192))
      | (1ULL << (HplsqlParser::T_REAL - 192))
      | (1ULL << (HplsqlParser::T_REFERENCES - 192))
      | (1ULL << (HplsqlParser::T_REGEXP - 192))
      | (1ULL << (HplsqlParser::T_REPLACE - 192))
      | (1ULL << (HplsqlParser::T_RESIGNAL - 192))
      | (1ULL << (HplsqlParser::T_RESTRICT - 192))
      | (1ULL << (HplsqlParser::T_RESULT - 192))
      | (1ULL << (HplsqlParser::T_RESULT_SET_LOCATOR - 192))
      | (1ULL << (HplsqlParser::T_RETURN - 192))
      | (1ULL << (HplsqlParser::T_RETURNS - 192))
      | (1ULL << (HplsqlParser::T_REVERSE - 192))
      | (1ULL << (HplsqlParser::T_RIGHT - 192))
      | (1ULL << (HplsqlParser::T_RLIKE - 192))
      | (1ULL << (HplsqlParser::T_ROLE - 192))
      | (1ULL << (HplsqlParser::T_ROLLBACK - 192))
      | (1ULL << (HplsqlParser::T_ROW - 192))
      | (1ULL << (HplsqlParser::T_ROWS - 192))
      | (1ULL << (HplsqlParser::T_ROW_COUNT - 192))
      | (1ULL << (HplsqlParser::T_RR - 192))
      | (1ULL << (HplsqlParser::T_RS - 192))
      | (1ULL << (HplsqlParser::T_PWD - 192))
      | (1ULL << (HplsqlParser::T_TRIM - 192))
      | (1ULL << (HplsqlParser::T_SCHEMA - 192))
      | (1ULL << (HplsqlParser::T_SECOND - 192))
      | (1ULL << (HplsqlParser::T_SECONDS - 192))
      | (1ULL << (HplsqlParser::T_SECURITY - 192))
      | (1ULL << (HplsqlParser::T_SEGMENT - 192))
      | (1ULL << (HplsqlParser::T_SEL - 192))
      | (1ULL << (HplsqlParser::T_SELECT - 192)))) != 0) || ((((_la - 256) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 256)) & ((1ULL << (HplsqlParser::T_SET - 256))
      | (1ULL << (HplsqlParser::T_SESSION - 256))
      | (1ULL << (HplsqlParser::T_SESSIONS - 256))
      | (1ULL << (HplsqlParser::T_SETS - 256))
      | (1ULL << (HplsqlParser::T_SHARE - 256))
      | (1ULL << (HplsqlParser::T_SIGNAL - 256))
      | (1ULL << (HplsqlParser::T_SIMPLE_DOUBLE - 256))
      | (1ULL << (HplsqlParser::T_SIMPLE_FLOAT - 256))
      | (1ULL << (HplsqlParser::T_SMALLDATETIME - 256))
      | (1ULL << (HplsqlParser::T_SMALLINT - 256))
      | (1ULL << (HplsqlParser::T_SQL - 256))
      | (1ULL << (HplsqlParser::T_SQLEXCEPTION - 256))
      | (1ULL << (HplsqlParser::T_SQLINSERT - 256))
      | (1ULL << (HplsqlParser::T_SQLSTATE - 256))
      | (1ULL << (HplsqlParser::T_SQLWARNING - 256))
      | (1ULL << (HplsqlParser::T_STATS - 256))
      | (1ULL << (HplsqlParser::T_STATISTICS - 256))
      | (1ULL << (HplsqlParser::T_STEP - 256))
      | (1ULL << (HplsqlParser::T_STORAGE - 256))
      | (1ULL << (HplsqlParser::T_STORED - 256))
      | (1ULL << (HplsqlParser::T_STRING - 256))
      | (1ULL << (HplsqlParser::T_SUBDIR - 256))
      | (1ULL << (HplsqlParser::T_SUBSTRING - 256))
      | (1ULL << (HplsqlParser::T_SUM - 256))
      | (1ULL << (HplsqlParser::T_SYS_REFCURSOR - 256))
      | (1ULL << (HplsqlParser::T_TABLE - 256))
      | (1ULL << (HplsqlParser::T_TABLESPACE - 256))
      | (1ULL << (HplsqlParser::T_TEMPORARY - 256))
      | (1ULL << (HplsqlParser::T_TERMINATED - 256))
      | (1ULL << (HplsqlParser::T_TEXTIMAGE_ON - 256))
      | (1ULL << (HplsqlParser::T_THEN - 256))
      | (1ULL << (HplsqlParser::T_TIMESTAMP - 256))
      | (1ULL << (HplsqlParser::T_TITLE - 256))
      | (1ULL << (HplsqlParser::T_TO - 256))
      | (1ULL << (HplsqlParser::T_TOP - 256))
      | (1ULL << (HplsqlParser::T_TRANSACTION - 256))
      | (1ULL << (HplsqlParser::T_TRUE - 256))
      | (1ULL << (HplsqlParser::T_TRUNCATE - 256))
      | (1ULL << (HplsqlParser::T_UNIQUE - 256))
      | (1ULL << (HplsqlParser::T_UPDATE - 256))
      | (1ULL << (HplsqlParser::T_UR - 256))
      | (1ULL << (HplsqlParser::T_USE - 256))
      | (1ULL << (HplsqlParser::T_USING - 256))
      | (1ULL << (HplsqlParser::T_VALUE - 256))
      | (1ULL << (HplsqlParser::T_VALUES - 256))
      | (1ULL << (HplsqlParser::T_VAR - 256))
      | (1ULL << (HplsqlParser::T_VARCHAR - 256))
      | (1ULL << (HplsqlParser::T_VARCHAR2 - 256))
      | (1ULL << (HplsqlParser::T_VARYING - 256))
      | (1ULL << (HplsqlParser::T_VOLATILE - 256))
      | (1ULL << (HplsqlParser::T_WHILE - 256))
      | (1ULL << (HplsqlParser::T_WITH - 256))
      | (1ULL << (HplsqlParser::T_WITHOUT - 256))
      | (1ULL << (HplsqlParser::T_WORK - 256))
      | (1ULL << (HplsqlParser::T_XACT_ABORT - 256))
      | (1ULL << (HplsqlParser::T_XML - 256))
      | (1ULL << (HplsqlParser::T_YES - 256))
      | (1ULL << (HplsqlParser::T_ACTIVITY_COUNT - 256)))) != 0) || ((((_la - 320) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 320)) & ((1ULL << (HplsqlParser::T_CUME_DIST - 320))
      | (1ULL << (HplsqlParser::T_CURRENT_DATE - 320))
      | (1ULL << (HplsqlParser::T_CURRENT_TIMESTAMP - 320))
      | (1ULL << (HplsqlParser::T_CURRENT_USER - 320))
      | (1ULL << (HplsqlParser::T_DENSE_RANK - 320))
      | (1ULL << (HplsqlParser::T_FIRST_VALUE - 320))
      | (1ULL << (HplsqlParser::T_LAG - 320))
      | (1ULL << (HplsqlParser::T_LAST_VALUE - 320))
      | (1ULL << (HplsqlParser::T_LEAD - 320))
      | (1ULL << (HplsqlParser::T_PART_COUNT - 320))
      | (1ULL << (HplsqlParser::T_PART_LOC - 320))
      | (1ULL << (HplsqlParser::T_RANK - 320))
      | (1ULL << (HplsqlParser::T_ROW_NUMBER - 320))
      | (1ULL << (HplsqlParser::T_STDEV - 320))
      | (1ULL << (HplsqlParser::T_SYSDATE - 320))
      | (1ULL << (HplsqlParser::T_VARIANCE - 320))
      | (1ULL << (HplsqlParser::T_USER - 320)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool HplsqlParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 4: return block_endSempred(dynamic_cast<Block_endContext *>(context), predicateIndex);
    case 11: return expr_stmtSempred(dynamic_cast<Expr_stmtContext *>(context), predicateIndex);
    case 74: return create_routine_paramsSempred(dynamic_cast<Create_routine_paramsContext *>(context), predicateIndex);
    case 151: return select_list_aliasSempred(dynamic_cast<Select_list_aliasContext *>(context), predicateIndex);
    case 162: return from_alias_clauseSempred(dynamic_cast<From_alias_clauseContext *>(context), predicateIndex);
    case 180: return delete_aliasSempred(dynamic_cast<Delete_aliasContext *>(context), predicateIndex);
    case 182: return bool_exprSempred(dynamic_cast<Bool_exprContext *>(context), predicateIndex);
    case 190: return exprSempred(dynamic_cast<ExprContext *>(context), predicateIndex);
    case 207: return func_paramSempred(dynamic_cast<Func_paramContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool HplsqlParser::block_endSempred(Block_endContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return strcasecmp(_input->LT(2)->getText().data(), "TRANSACTION");

  default:
    break;
  }
  return true;
}

bool HplsqlParser::expr_stmtSempred(Expr_stmtContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 1: return strcasecmp(_input->LT(1)->getText().data(), "GO");

  default:
    break;
  }
  return true;
}

bool HplsqlParser::create_routine_paramsSempred(Create_routine_paramsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 2: return strcasecmp(_input->LT(1)->getText().data(), "IS") &&
            strcasecmp(_input->LT(1)->getText().data(), "AS") &&
            strcasecmp(_input->LT(1)->getText().data(), "DYNAMIC") && strcasecmp(_input->LT(2)->getText().data(), "RESULT")
            ;

  default:
    break;
  }
  return true;
}

bool HplsqlParser::select_list_aliasSempred(Select_list_aliasContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 3: return strcasecmp(_input->LT(1)->getText().data(), "INTO") && strcasecmp(_input->LT(1)->getText().data(), "FROM");

  default:
    break;
  }
  return true;
}

bool HplsqlParser::from_alias_clauseSempred(From_alias_clauseContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 4: return strcasecmp(_input->LT(1)->getText().data(), "EXEC") &&
            strcasecmp(_input->LT(1)->getText().data(), "EXECUTE") && 
            strcasecmp(_input->LT(1)->getText().data(), "INNER") &&
            strcasecmp(_input->LT(1)->getText().data(), "LEFT") &&
            strcasecmp(_input->LT(1)->getText().data(), "GROUP") &&
            strcasecmp(_input->LT(1)->getText().data(), "ORDER") &&
            strcasecmp(_input->LT(1)->getText().data(), "LIMIT") &&
            strcasecmp(_input->LT(1)->getText().data(), "WITH");

  default:
    break;
  }
  return true;
}

bool HplsqlParser::delete_aliasSempred(Delete_aliasContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 5: return strcasecmp(_input->LT(1)->getText().data(), "ALL");

  default:
    break;
  }
  return true;
}

bool HplsqlParser::bool_exprSempred(Bool_exprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 6: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool HplsqlParser::exprSempred(ExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 7: return precpred(_ctx, 14);
    case 8: return precpred(_ctx, 13);
    case 9: return precpred(_ctx, 12);
    case 10: return precpred(_ctx, 11);
    case 11: return precpred(_ctx, 15);

  default:
    break;
  }
  return true;
}

bool HplsqlParser::func_paramSempred(Func_paramContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 12: return strcasecmp(_input->LT(1)->getText().data(), "INTO");

  default:
    break;
  }
  return true;
}

// Static vars and initialization.
std::vector<dfa::DFA> HplsqlParser::_decisionToDFA;
atn::PredictionContextCache HplsqlParser::_sharedContextCache;

// We own the ATN which in turn owns the ATN states.
atn::ATN HplsqlParser::_atn;
std::vector<uint16_t> HplsqlParser::_serializedATN;

std::vector<std::string> HplsqlParser::_ruleNames = {
  "program", "block", "begin_end_block", "single_block_stmt", "block_end", 
  "proc_block", "stmt", "semicolon_stmt", "exception_block", "exception_block_item", 
  "null_stmt", "expr_stmt", "assignment_stmt", "assignment_stmt_item", "assignment_stmt_single_item", 
  "assignment_stmt_multiple_item", "assignment_stmt_select_item", "allocate_cursor_stmt", 
  "associate_locator_stmt", "begin_transaction_stmt", "break_stmt", "call_stmt", 
  "declare_stmt", "declare_block", "declare_block_inplace", "declare_stmt_item", 
  "declare_var_item", "declare_condition_item", "declare_cursor_item", "cursor_with_return", 
  "cursor_without_return", "declare_handler_item", "declare_temporary_table_item", 
  "create_table_stmt", "create_local_temp_table_stmt", "create_table_definition", 
  "create_table_columns", "create_table_columns_item", "column_name", "create_table_column_inline_cons", 
  "create_table_column_cons", "create_table_fk_action", "create_table_preoptions", 
  "create_table_preoptions_item", "create_table_preoptions_td_item", "create_table_options", 
  "create_table_options_item", "create_table_options_ora_item", "create_table_options_db2_item", 
  "create_table_options_td_item", "create_table_options_hive_item", "create_table_hive_row_format", 
  "create_table_hive_row_format_fields", "create_table_options_mssql_item", 
  "create_table_options_mysql_item", "alter_table_stmt", "alter_table_item", 
  "alter_table_add_constraint", "alter_table_add_constraint_item", "dtype", 
  "dtype_len", "dtype_attr", "dtype_default", "create_database_stmt", "create_database_option", 
  "create_function_stmt", "create_function_return", "create_package_stmt", 
  "package_spec", "package_spec_item", "create_package_body_stmt", "package_body", 
  "package_body_item", "create_procedure_stmt", "create_routine_params", 
  "create_routine_param_item", "create_routine_options", "create_routine_option", 
  "drop_stmt", "end_transaction_stmt", "exec_stmt", "if_stmt", "if_plsql_stmt", 
  "if_tsql_stmt", "if_bteq_stmt", "elseif_block", "else_block", "include_stmt", 
  "insert_stmt", "insert_stmt_cols", "insert_stmt_rows", "insert_stmt_row", 
  "insert_directory_stmt", "exit_stmt", "get_diag_stmt", "get_diag_stmt_item", 
  "get_diag_stmt_exception_item", "get_diag_stmt_rowcount_item", "grant_stmt", 
  "grant_stmt_item", "leave_stmt", "map_object_stmt", "open_stmt", "fetch_stmt", 
  "collect_stats_stmt", "collect_stats_clause", "close_stmt", "cmp_stmt", 
  "cmp_source", "copy_from_local_stmt", "copy_stmt", "copy_source", "copy_target", 
  "copy_option", "copy_file_option", "commit_stmt", "create_index_stmt", 
  "create_index_col", "index_storage_clause", "index_mssql_storage_clause", 
  "print_stmt", "quit_stmt", "raise_stmt", "resignal_stmt", "return_stmt", 
  "rollback_stmt", "set_session_option", "set_current_schema_option", "set_mssql_session_option", 
  "set_teradata_session_option", "signal_stmt", "truncate_stmt", "use_stmt", 
  "values_into_stmt", "while_stmt", "for_cursor_stmt", "for_range_stmt", 
  "label", "using_clause", "select_stmt", "cte_select_stmt", "cte_select_stmt_item", 
  "cte_select_cols", "fullselect_stmt", "fullselect_stmt_item", "fullselect_set_clause", 
  "subselect_stmt", "select_list", "select_list_set", "select_list_limit", 
  "select_list_item", "select_list_alias", "select_list_asterisk", "into_clause", 
  "from_clause", "from_table_clause", "from_table_name_clause", "from_subselect_clause", 
  "from_join_clause", "from_join_type_clause", "from_table_values_clause", 
  "from_table_values_row", "from_alias_clause", "table_name", "where_clause", 
  "group_by_clause", "having_clause", "qualify_clause", "order_by_clause", 
  "select_options", "select_options_item", "update_stmt", "update_assignment", 
  "update_table", "update_upsert", "merge_stmt", "merge_table", "merge_condition", 
  "merge_action", "delete_stmt", "delete_alias", "describe_stmt", "bool_expr", 
  "bool_expr_atom", "bool_expr_unary", "bool_expr_single_in", "bool_expr_multi_in", 
  "bool_expr_binary", "bool_expr_logical_operator", "bool_expr_binary_operator", 
  "expr", "expr_atom", "expr_interval", "interval_item", "expr_concat", 
  "expr_concat_item", "expr_case", "expr_case_simple", "expr_case_searched", 
  "expr_cursor_attribute", "expr_agg_window_func", "expr_func_all_distinct", 
  "expr_func_over_clause", "expr_func_partition_by_clause", "expr_spec_func", 
  "expr_func", "expr_func_params", "func_param", "expr_select", "expr_file", 
  "hive", "hive_item", "host", "host_cmd", "host_stmt", "file_name", "date_literal", 
  "timestamp_literal", "ident", "string", "int_number", "dec_number", "bool_literal", 
  "null_const", "non_reserved_words"
};

std::vector<std::string> HplsqlParser::_literalNames = {
  "", "'@'", "'#'", "'%'", "'.'", "'!'", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "'+'", "':'", "','", "'||'", "'/'", "'..'", "'='", 
  "'=='", "'<>'", "'!='", "'>'", "'>='", "'<'", "'<='", "'*'", "'{'", "'('", 
  "'['", "'}'", "')'", "']'", "';'", "'-'"
};

std::vector<std::string> HplsqlParser::_symbolicNames = {
  "", "", "", "", "", "", "T_ACTION", "T_ADD2", "T_ALL", "T_ALLOCATE", "T_ALTER", 
  "T_AND", "T_ANSI_NULLS", "T_ANSI_PADDING", "T_AS", "T_ASC", "T_ASSOCIATE", 
  "T_AT", "T_AUTO_INCREMENT", "T_AVG", "T_BATCHSIZE", "T_BEGIN", "T_BETWEEN", 
  "T_BIGINT", "T_BINARY_DOUBLE", "T_BINARY_FLOAT", "T_BINARY_INTEGER", "T_BIT", 
  "T_BODY", "T_BREAK", "T_BY", "T_BYTE", "T_CALL", "T_CALLER", "T_CASCADE", 
  "T_CASE", "T_CASESPECIFIC", "T_CAST", "T_CHAR", "T_CHARACTER", "T_CHARSET", 
  "T_CLIENT", "T_CLOSE", "T_CLUSTERED", "T_CMP", "T_COLLECT", "T_COLLECTION", 
  "T_COLUMN", "T_COMMENT", "T_CONSTANT", "T_COMMIT", "T_COMPRESS", "T_CONCAT", 
  "T_CONDITION", "T_CONSTRAINT", "T_CONTINUE", "T_COPY", "T_COUNT", "T_COUNT_BIG", 
  "T_CREATE", "T_CREATION", "T_CREATOR", "T_CS", "T_CURRENT", "T_CURRENT_SCHEMA", 
  "T_CURSOR", "T_DATABASE", "T_DATA", "T_DATE", "T_DATETIME", "T_DAY", "T_DAYS", 
  "T_DEC", "T_DECIMAL", "T_DECLARE", "T_DEFAULT", "T_DEFERRED", "T_DEFINED", 
  "T_DEFINER", "T_DEFINITION", "T_DELETE", "T_DELIMITED", "T_DELIMITER", 
  "T_DESC", "T_DESCRIBE", "T_DIAGNOSTICS", "T_DIR", "T_DIRECTORY", "T_DISTINCT", 
  "T_DISTRIBUTE", "T_DO", "T_DOUBLE", "T_DROP", "T_DYNAMIC", "T_ELSE", "T_ELSEIF", 
  "T_ELSIF", "T_ENABLE", "T_END", "T_ENGINE", "T_ESCAPED", "T_EXCEPT", "T_EXEC", 
  "T_EXECUTE", "T_EXCEPTION", "T_EXCLUSIVE", "T_EXISTS", "T_EXIT", "T_FALLBACK", 
  "T_FALSE", "T_FETCH", "T_FIELDS", "T_FILE", "T_FILES", "T_FLOAT", "T_FOR", 
  "T_FOREIGN", "T_FORMAT", "T_FOUND", "T_FROM", "T_FULL", "T_FUNCTION", 
  "T_GET", "T_GLOBAL", "T_GO", "T_GRANT", "T_GROUP", "T_HANDLER", "T_HASH", 
  "T_HAVING", "T_HDFS", "T_HIVE", "T_HOST", "T_IDENTITY", "T_IF", "T_IGNORE", 
  "T_IMMEDIATE", "T_IN", "T_INCLUDE", "T_INDEX", "T_INITRANS", "T_INNER", 
  "T_INOUT", "T_INSERT", "T_INT", "T_INT2", "T_INT4", "T_INT8", "T_INTEGER", 
  "T_INTERSECT", "T_INTERVAL", "T_INTO", "T_INVOKER", "T_IS", "T_ISOPEN", 
  "T_ITEMS", "T_JOIN", "T_KEEP", "T_KEY", "T_KEYS", "T_LANGUAGE", "T_LEAVE", 
  "T_LEFT", "T_LIKE", "T_LIMIT", "T_LINES", "T_LOCAL", "T_LOCATION", "T_LOCATOR", 
  "T_LOCATORS", "T_LOCKS", "T_LOG", "T_LOGGED", "T_LOGGING", "T_LOOP", "T_MAP", 
  "T_MATCHED", "T_MAX", "T_MAXTRANS", "T_MERGE", "T_MESSAGE_TEXT", "T_MICROSECOND", 
  "T_MICROSECONDS", "T_MIN", "T_MULTISET", "T_NCHAR", "T_NEW", "T_NVARCHAR", 
  "T_NO", "T_NOCOUNT", "T_NOCOMPRESS", "T_NOLOGGING", "T_NONE", "T_NOT", 
  "T_NOTFOUND", "T_NULL", "T_NUMERIC", "T_NUMBER", "T_OBJECT", "T_OFF", 
  "T_ON", "T_ONLY", "T_OPEN", "T_OR", "T_ORDER", "T_OUT", "T_OUTER", "T_OVER", 
  "T_OVERWRITE", "T_OWNER", "T_PACKAGE", "T_PARTITION", "T_PCTFREE", "T_PCTUSED", 
  "T_PLS_INTEGER", "T_PRECISION", "T_PRESERVE", "T_PRIMARY", "T_PRINT", 
  "T_PROC", "T_PROCEDURE", "T_QUALIFY", "T_QUERY_BAND", "T_QUIT", "T_QUOTED_IDENTIFIER", 
  "T_RAISE", "T_REAL", "T_REFERENCES", "T_REGEXP", "T_REPLACE", "T_RESIGNAL", 
  "T_RESTRICT", "T_RESULT", "T_RESULT_SET_LOCATOR", "T_RETURN", "T_RETURNS", 
  "T_REVERSE", "T_RIGHT", "T_RLIKE", "T_ROLE", "T_ROLLBACK", "T_ROW", "T_ROWS", 
  "T_ROWTYPE", "T_ROW_COUNT", "T_RR", "T_RS", "T_PWD", "T_TRIM", "T_SCHEMA", 
  "T_SECOND", "T_SECONDS", "T_SECURITY", "T_SEGMENT", "T_SEL", "T_SELECT", 
  "T_SET", "T_SESSION", "T_SESSIONS", "T_SETS", "T_SHARE", "T_SIGNAL", "T_SIMPLE_DOUBLE", 
  "T_SIMPLE_FLOAT", "T_SIMPLE_INTEGER", "T_SMALLDATETIME", "T_SMALLINT", 
  "T_SQL", "T_SQLEXCEPTION", "T_SQLINSERT", "T_SQLSTATE", "T_SQLWARNING", 
  "T_STATS", "T_STATISTICS", "T_STEP", "T_STORAGE", "T_STORED", "T_STRING", 
  "T_SUBDIR", "T_SUBSTRING", "T_SUM", "T_SYS_REFCURSOR", "T_TABLE", "T_TABLESPACE", 
  "T_TEMPORARY", "T_TERMINATED", "T_TEXTIMAGE_ON", "T_THEN", "T_TIMESTAMP", 
  "T_TINYINT", "T_TITLE", "T_TO", "T_TOP", "T_TRANSACTION", "T_TRUE", "T_TRUNCATE", 
  "T_TYPE", "T_UNION", "T_UNIQUE", "T_UPDATE", "T_UR", "T_USE", "T_USING", 
  "T_VALUE", "T_VALUES", "T_VAR", "T_VARCHAR", "T_VARCHAR2", "T_VARYING", 
  "T_VOLATILE", "T_WHEN", "T_WHERE", "T_WHILE", "T_WITH", "T_WITHOUT", "T_WORK", 
  "T_XACT_ABORT", "T_XML", "T_YES", "T_ACTIVITY_COUNT", "T_CUME_DIST", "T_CURRENT_DATE", 
  "T_CURRENT_TIMESTAMP", "T_CURRENT_USER", "T_DENSE_RANK", "T_FIRST_VALUE", 
  "T_LAG", "T_LAST_VALUE", "T_LEAD", "T_MAX_PART_STRING", "T_MIN_PART_STRING", 
  "T_MAX_PART_INT", "T_MIN_PART_INT", "T_MAX_PART_DATE", "T_MIN_PART_DATE", 
  "T_PART_COUNT", "T_PART_LOC", "T_RANK", "T_ROW_NUMBER", "T_STDEV", "T_SYSDATE", 
  "T_VARIANCE", "T_USER", "T_ADD", "T_COLON", "T_COMMA", "T_PIPE", "T_DIV", 
  "T_DOT2", "T_EQUAL", "T_EQUAL2", "T_NOTEQUAL", "T_NOTEQUAL2", "T_GREATER", 
  "T_GREATEREQUAL", "T_LESS", "T_LESSEQUAL", "T_MUL", "T_OPEN_B", "T_OPEN_P", 
  "T_OPEN_SB", "T_CLOSE_B", "T_CLOSE_P", "T_CLOSE_SB", "T_SEMICOLON", "T_SUB", 
  "L_ID", "L_S_STRING", "L_D_STRING", "L_INT", "L_DEC", "L_WS", "L_M_COMMENT", 
  "L_S_COMMENT", "L_FILE", "L_LABEL"
};

dfa::Vocabulary HplsqlParser::_vocabulary(_literalNames, _symbolicNames);

std::vector<std::string> HplsqlParser::_tokenNames;

HplsqlParser::Initializer::Initializer() {
	for (size_t i = 0; i < _symbolicNames.size(); ++i) {
		std::string name = _vocabulary.getLiteralName(i);
		if (name.empty()) {
			name = _vocabulary.getSymbolicName(i);
		}

		if (name.empty()) {
			_tokenNames.push_back("<INVALID>");
		} else {
      _tokenNames.push_back(name);
    }
	}

  static const uint16_t serializedATNSegment0[] = {
    0x3, 0x608b, 0xa72a, 0x8133, 0xb9ed, 0x417c, 0x3be7, 0x7786, 0x5964, 
       0x3, 0x179, 0xcf6, 0x4, 0x2, 0x9, 0x2, 0x4, 0x3, 0x9, 0x3, 0x4, 0x4, 
       0x9, 0x4, 0x4, 0x5, 0x9, 0x5, 0x4, 0x6, 0x9, 0x6, 0x4, 0x7, 0x9, 
       0x7, 0x4, 0x8, 0x9, 0x8, 0x4, 0x9, 0x9, 0x9, 0x4, 0xa, 0x9, 0xa, 
       0x4, 0xb, 0x9, 0xb, 0x4, 0xc, 0x9, 0xc, 0x4, 0xd, 0x9, 0xd, 0x4, 
       0xe, 0x9, 0xe, 0x4, 0xf, 0x9, 0xf, 0x4, 0x10, 0x9, 0x10, 0x4, 0x11, 
       0x9, 0x11, 0x4, 0x12, 0x9, 0x12, 0x4, 0x13, 0x9, 0x13, 0x4, 0x14, 
       0x9, 0x14, 0x4, 0x15, 0x9, 0x15, 0x4, 0x16, 0x9, 0x16, 0x4, 0x17, 
       0x9, 0x17, 0x4, 0x18, 0x9, 0x18, 0x4, 0x19, 0x9, 0x19, 0x4, 0x1a, 
       0x9, 0x1a, 0x4, 0x1b, 0x9, 0x1b, 0x4, 0x1c, 0x9, 0x1c, 0x4, 0x1d, 
       0x9, 0x1d, 0x4, 0x1e, 0x9, 0x1e, 0x4, 0x1f, 0x9, 0x1f, 0x4, 0x20, 
       0x9, 0x20, 0x4, 0x21, 0x9, 0x21, 0x4, 0x22, 0x9, 0x22, 0x4, 0x23, 
       0x9, 0x23, 0x4, 0x24, 0x9, 0x24, 0x4, 0x25, 0x9, 0x25, 0x4, 0x26, 
       0x9, 0x26, 0x4, 0x27, 0x9, 0x27, 0x4, 0x28, 0x9, 0x28, 0x4, 0x29, 
       0x9, 0x29, 0x4, 0x2a, 0x9, 0x2a, 0x4, 0x2b, 0x9, 0x2b, 0x4, 0x2c, 
       0x9, 0x2c, 0x4, 0x2d, 0x9, 0x2d, 0x4, 0x2e, 0x9, 0x2e, 0x4, 0x2f, 
       0x9, 0x2f, 0x4, 0x30, 0x9, 0x30, 0x4, 0x31, 0x9, 0x31, 0x4, 0x32, 
       0x9, 0x32, 0x4, 0x33, 0x9, 0x33, 0x4, 0x34, 0x9, 0x34, 0x4, 0x35, 
       0x9, 0x35, 0x4, 0x36, 0x9, 0x36, 0x4, 0x37, 0x9, 0x37, 0x4, 0x38, 
       0x9, 0x38, 0x4, 0x39, 0x9, 0x39, 0x4, 0x3a, 0x9, 0x3a, 0x4, 0x3b, 
       0x9, 0x3b, 0x4, 0x3c, 0x9, 0x3c, 0x4, 0x3d, 0x9, 0x3d, 0x4, 0x3e, 
       0x9, 0x3e, 0x4, 0x3f, 0x9, 0x3f, 0x4, 0x40, 0x9, 0x40, 0x4, 0x41, 
       0x9, 0x41, 0x4, 0x42, 0x9, 0x42, 0x4, 0x43, 0x9, 0x43, 0x4, 0x44, 
       0x9, 0x44, 0x4, 0x45, 0x9, 0x45, 0x4, 0x46, 0x9, 0x46, 0x4, 0x47, 
       0x9, 0x47, 0x4, 0x48, 0x9, 0x48, 0x4, 0x49, 0x9, 0x49, 0x4, 0x4a, 
       0x9, 0x4a, 0x4, 0x4b, 0x9, 0x4b, 0x4, 0x4c, 0x9, 0x4c, 0x4, 0x4d, 
       0x9, 0x4d, 0x4, 0x4e, 0x9, 0x4e, 0x4, 0x4f, 0x9, 0x4f, 0x4, 0x50, 
       0x9, 0x50, 0x4, 0x51, 0x9, 0x51, 0x4, 0x52, 0x9, 0x52, 0x4, 0x53, 
       0x9, 0x53, 0x4, 0x54, 0x9, 0x54, 0x4, 0x55, 0x9, 0x55, 0x4, 0x56, 
       0x9, 0x56, 0x4, 0x57, 0x9, 0x57, 0x4, 0x58, 0x9, 0x58, 0x4, 0x59, 
       0x9, 0x59, 0x4, 0x5a, 0x9, 0x5a, 0x4, 0x5b, 0x9, 0x5b, 0x4, 0x5c, 
       0x9, 0x5c, 0x4, 0x5d, 0x9, 0x5d, 0x4, 0x5e, 0x9, 0x5e, 0x4, 0x5f, 
       0x9, 0x5f, 0x4, 0x60, 0x9, 0x60, 0x4, 0x61, 0x9, 0x61, 0x4, 0x62, 
       0x9, 0x62, 0x4, 0x63, 0x9, 0x63, 0x4, 0x64, 0x9, 0x64, 0x4, 0x65, 
       0x9, 0x65, 0x4, 0x66, 0x9, 0x66, 0x4, 0x67, 0x9, 0x67, 0x4, 0x68, 
       0x9, 0x68, 0x4, 0x69, 0x9, 0x69, 0x4, 0x6a, 0x9, 0x6a, 0x4, 0x6b, 
       0x9, 0x6b, 0x4, 0x6c, 0x9, 0x6c, 0x4, 0x6d, 0x9, 0x6d, 0x4, 0x6e, 
       0x9, 0x6e, 0x4, 0x6f, 0x9, 0x6f, 0x4, 0x70, 0x9, 0x70, 0x4, 0x71, 
       0x9, 0x71, 0x4, 0x72, 0x9, 0x72, 0x4, 0x73, 0x9, 0x73, 0x4, 0x74, 
       0x9, 0x74, 0x4, 0x75, 0x9, 0x75, 0x4, 0x76, 0x9, 0x76, 0x4, 0x77, 
       0x9, 0x77, 0x4, 0x78, 0x9, 0x78, 0x4, 0x79, 0x9, 0x79, 0x4, 0x7a, 
       0x9, 0x7a, 0x4, 0x7b, 0x9, 0x7b, 0x4, 0x7c, 0x9, 0x7c, 0x4, 0x7d, 
       0x9, 0x7d, 0x4, 0x7e, 0x9, 0x7e, 0x4, 0x7f, 0x9, 0x7f, 0x4, 0x80, 
       0x9, 0x80, 0x4, 0x81, 0x9, 0x81, 0x4, 0x82, 0x9, 0x82, 0x4, 0x83, 
       0x9, 0x83, 0x4, 0x84, 0x9, 0x84, 0x4, 0x85, 0x9, 0x85, 0x4, 0x86, 
       0x9, 0x86, 0x4, 0x87, 0x9, 0x87, 0x4, 0x88, 0x9, 0x88, 0x4, 0x89, 
       0x9, 0x89, 0x4, 0x8a, 0x9, 0x8a, 0x4, 0x8b, 0x9, 0x8b, 0x4, 0x8c, 
       0x9, 0x8c, 0x4, 0x8d, 0x9, 0x8d, 0x4, 0x8e, 0x9, 0x8e, 0x4, 0x8f, 
       0x9, 0x8f, 0x4, 0x90, 0x9, 0x90, 0x4, 0x91, 0x9, 0x91, 0x4, 0x92, 
       0x9, 0x92, 0x4, 0x93, 0x9, 0x93, 0x4, 0x94, 0x9, 0x94, 0x4, 0x95, 
       0x9, 0x95, 0x4, 0x96, 0x9, 0x96, 0x4, 0x97, 0x9, 0x97, 0x4, 0x98, 
       0x9, 0x98, 0x4, 0x99, 0x9, 0x99, 0x4, 0x9a, 0x9, 0x9a, 0x4, 0x9b, 
       0x9, 0x9b, 0x4, 0x9c, 0x9, 0x9c, 0x4, 0x9d, 0x9, 0x9d, 0x4, 0x9e, 
       0x9, 0x9e, 0x4, 0x9f, 0x9, 0x9f, 0x4, 0xa0, 0x9, 0xa0, 0x4, 0xa1, 
       0x9, 0xa1, 0x4, 0xa2, 0x9, 0xa2, 0x4, 0xa3, 0x9, 0xa3, 0x4, 0xa4, 
       0x9, 0xa4, 0x4, 0xa5, 0x9, 0xa5, 0x4, 0xa6, 0x9, 0xa6, 0x4, 0xa7, 
       0x9, 0xa7, 0x4, 0xa8, 0x9, 0xa8, 0x4, 0xa9, 0x9, 0xa9, 0x4, 0xaa, 
       0x9, 0xaa, 0x4, 0xab, 0x9, 0xab, 0x4, 0xac, 0x9, 0xac, 0x4, 0xad, 
       0x9, 0xad, 0x4, 0xae, 0x9, 0xae, 0x4, 0xaf, 0x9, 0xaf, 0x4, 0xb0, 
       0x9, 0xb0, 0x4, 0xb1, 0x9, 0xb1, 0x4, 0xb2, 0x9, 0xb2, 0x4, 0xb3, 
       0x9, 0xb3, 0x4, 0xb4, 0x9, 0xb4, 0x4, 0xb5, 0x9, 0xb5, 0x4, 0xb6, 
       0x9, 0xb6, 0x4, 0xb7, 0x9, 0xb7, 0x4, 0xb8, 0x9, 0xb8, 0x4, 0xb9, 
       0x9, 0xb9, 0x4, 0xba, 0x9, 0xba, 0x4, 0xbb, 0x9, 0xbb, 0x4, 0xbc, 
       0x9, 0xbc, 0x4, 0xbd, 0x9, 0xbd, 0x4, 0xbe, 0x9, 0xbe, 0x4, 0xbf, 
       0x9, 0xbf, 0x4, 0xc0, 0x9, 0xc0, 0x4, 0xc1, 0x9, 0xc1, 0x4, 0xc2, 
       0x9, 0xc2, 0x4, 0xc3, 0x9, 0xc3, 0x4, 0xc4, 0x9, 0xc4, 0x4, 0xc5, 
       0x9, 0xc5, 0x4, 0xc6, 0x9, 0xc6, 0x4, 0xc7, 0x9, 0xc7, 0x4, 0xc8, 
       0x9, 0xc8, 0x4, 0xc9, 0x9, 0xc9, 0x4, 0xca, 0x9, 0xca, 0x4, 0xcb, 
       0x9, 0xcb, 0x4, 0xcc, 0x9, 0xcc, 0x4, 0xcd, 0x9, 0xcd, 0x4, 0xce, 
       0x9, 0xce, 0x4, 0xcf, 0x9, 0xcf, 0x4, 0xd0, 0x9, 0xd0, 0x4, 0xd1, 
       0x9, 0xd1, 0x4, 0xd2, 0x9, 0xd2, 0x4, 0xd3, 0x9, 0xd3, 0x4, 0xd4, 
       0x9, 0xd4, 0x4, 0xd5, 0x9, 0xd5, 0x4, 0xd6, 0x9, 0xd6, 0x4, 0xd7, 
       0x9, 0xd7, 0x4, 0xd8, 0x9, 0xd8, 0x4, 0xd9, 0x9, 0xd9, 0x4, 0xda, 
       0x9, 0xda, 0x4, 0xdb, 0x9, 0xdb, 0x4, 0xdc, 0x9, 0xdc, 0x4, 0xdd, 
       0x9, 0xdd, 0x4, 0xde, 0x9, 0xde, 0x4, 0xdf, 0x9, 0xdf, 0x4, 0xe0, 
       0x9, 0xe0, 0x4, 0xe1, 0x9, 0xe1, 0x4, 0xe2, 0x9, 0xe2, 0x3, 0x2, 
       0x3, 0x2, 0x3, 0x3, 0x3, 0x3, 0x5, 0x3, 0x1c9, 0xa, 0x3, 0x3, 0x3, 
       0x5, 0x3, 0x1cc, 0xa, 0x3, 0x6, 0x3, 0x1ce, 0xa, 0x3, 0xd, 0x3, 0xe, 
       0x3, 0x1cf, 0x3, 0x4, 0x5, 0x4, 0x1d3, 0xa, 0x4, 0x3, 0x4, 0x3, 0x4, 
       0x3, 0x4, 0x5, 0x4, 0x1d8, 0xa, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x5, 
       0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x1df, 0xa, 0x5, 0x3, 0x5, 0x3, 0x5, 
       0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x1e5, 0xa, 0x5, 0x5, 0x5, 0x1e7, 0xa, 
       0x5, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 0x7, 0x3, 0x7, 0x6, 0x7, 
       0x1ee, 0xa, 0x7, 0xd, 0x7, 0xe, 0x7, 0x1ef, 0x3, 0x7, 0x5, 0x7, 0x1f3, 
       0xa, 0x7, 0x5, 0x7, 0x1f5, 0xa, 0x7, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 
       0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 
       0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 
       0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 
       0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 
       0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 
       0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 
       0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 
       0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 
       0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x5, 0x8, 0x233, 
       0xa, 0x8, 0x3, 0x9, 0x3, 0x9, 0x3, 0xa, 0x3, 0xa, 0x6, 0xa, 0x239, 
       0xa, 0xa, 0xd, 0xa, 0xe, 0xa, 0x23a, 0x3, 0xb, 0x3, 0xb, 0x3, 0xb, 
       0x3, 0xb, 0x3, 0xb, 0x3, 0xb, 0x3, 0xc, 0x3, 0xc, 0x3, 0xd, 0x3, 
       0xd, 0x3, 0xd, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x5, 0xe, 0x24b, 0xa, 
       0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x7, 0xe, 0x250, 0xa, 0xe, 0xc, 
       0xe, 0xe, 0xe, 0x253, 0xb, 0xe, 0x5, 0xe, 0x255, 0xa, 0xe, 0x3, 0xf, 
       0x3, 0xf, 0x3, 0xf, 0x5, 0xf, 0x25a, 0xa, 0xf, 0x3, 0x10, 0x3, 0x10, 
       0x5, 0x10, 0x25e, 0xa, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 
       0x10, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x5, 0x10, 0x267, 0xa, 0x10, 
       0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x5, 0x10, 0x26c, 0xa, 0x10, 0x3, 
       0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x7, 0x11, 0x272, 0xa, 0x11, 
       0xc, 0x11, 0xe, 0x11, 0x275, 0xb, 0x11, 0x3, 0x11, 0x3, 0x11, 0x5, 
       0x11, 0x279, 0xa, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 
       0x3, 0x11, 0x7, 0x11, 0x280, 0xa, 0x11, 0xc, 0x11, 0xe, 0x11, 0x283, 
       0xb, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 
       0x3, 0x12, 0x3, 0x12, 0x7, 0x12, 0x28c, 0xa, 0x12, 0xc, 0x12, 0xe, 
       0x12, 0x28f, 0xb, 0x12, 0x3, 0x12, 0x3, 0x12, 0x5, 0x12, 0x293, 0xa, 
       0x12, 0x3, 0x12, 0x5, 0x12, 0x296, 0xa, 0x12, 0x3, 0x12, 0x3, 0x12, 
       0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 
       0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x5, 0x13, 0x2a4, 0xa, 
       0x13, 0x3, 0x13, 0x3, 0x13, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x5, 
       0x14, 0x2ab, 0xa, 0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 
       0x3, 0x14, 0x7, 0x14, 0x2b2, 0xa, 0x14, 0xc, 0x14, 0xe, 0x14, 0x2b5, 
       0xb, 0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 
       0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x16, 0x3, 0x16, 0x3, 0x17, 
       0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 0x5, 0x17, 0x2c5, 0xa, 0x17, 0x3, 
       0x17, 0x3, 0x17, 0x5, 0x17, 0x2c9, 0xa, 0x17, 0x3, 0x18, 0x3, 0x18, 
       0x3, 0x18, 0x3, 0x18, 0x7, 0x18, 0x2cf, 0xa, 0x18, 0xc, 0x18, 0xe, 
       0x18, 0x2d2, 0xb, 0x18, 0x3, 0x19, 0x3, 0x19, 0x3, 0x19, 0x3, 0x19, 
       0x3, 0x19, 0x3, 0x19, 0x7, 0x19, 0x2da, 0xa, 0x19, 0xc, 0x19, 0xe, 
       0x19, 0x2dd, 0xb, 0x19, 0x3, 0x1a, 0x3, 0x1a, 0x3, 0x1a, 0x3, 0x1a, 
       0x3, 0x1a, 0x7, 0x1a, 0x2e4, 0xa, 0x1a, 0xc, 0x1a, 0xe, 0x1a, 0x2e7, 
       0xb, 0x1a, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 
       0x5, 0x1b, 0x2ee, 0xa, 0x1b, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x7, 
       0x1c, 0x2f3, 0xa, 0x1c, 0xc, 0x1c, 0xe, 0x1c, 0x2f6, 0xb, 0x1c, 0x3, 
       0x1c, 0x5, 0x1c, 0x2f9, 0xa, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x5, 0x1c, 
       0x2fd, 0xa, 0x1c, 0x3, 0x1c, 0x7, 0x1c, 0x300, 0xa, 0x1c, 0xc, 0x1c, 
       0xe, 0x1c, 0x303, 0xb, 0x1c, 0x3, 0x1c, 0x5, 0x1c, 0x306, 0xa, 0x1c, 
       0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x5, 0x1c, 0x30b, 0xa, 0x1c, 0x3, 
       0x1c, 0x3, 0x1c, 0x5, 0x1c, 0x30f, 0xa, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 
       0x5, 0x1c, 0x313, 0xa, 0x1c, 0x3, 0x1d, 0x3, 0x1d, 0x3, 0x1d, 0x3, 
       0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x5, 0x1e, 0x31d, 
       0xa, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x5, 0x1e, 0x321, 0xa, 0x1e, 0x3, 
       0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x5, 0x1e, 0x326, 0xa, 0x1e, 0x3, 0x1f, 
       0x3, 0x1f, 0x3, 0x1f, 0x5, 0x1f, 0x32b, 0xa, 0x1f, 0x3, 0x1f, 0x3, 
       0x1f, 0x5, 0x1f, 0x32f, 0xa, 0x1f, 0x3, 0x20, 0x3, 0x20, 0x3, 0x20, 
       0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 
       0x3, 0x21, 0x3, 0x21, 0x5, 0x21, 0x33c, 0xa, 0x21, 0x3, 0x21, 0x3, 
       0x21, 0x3, 0x22, 0x5, 0x22, 0x341, 0xa, 0x22, 0x3, 0x22, 0x3, 0x22, 
       0x3, 0x22, 0x3, 0x22, 0x5, 0x22, 0x347, 0xa, 0x22, 0x3, 0x22, 0x3, 
       0x22, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x5, 
       0x23, 0x350, 0xa, 0x23, 0x3, 0x23, 0x3, 0x23, 0x5, 0x23, 0x354, 0xa, 
       0x23, 0x3, 0x23, 0x3, 0x23, 0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 
       0x24, 0x5, 0x24, 0x35c, 0xa, 0x24, 0x3, 0x24, 0x5, 0x24, 0x35f, 0xa, 
       0x24, 0x3, 0x24, 0x3, 0x24, 0x3, 0x24, 0x5, 0x24, 0x364, 0xa, 0x24, 
       0x3, 0x24, 0x3, 0x24, 0x3, 0x25, 0x5, 0x25, 0x369, 0xa, 0x25, 0x3, 
       0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x5, 0x25, 0x370, 
       0xa, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 
       0x5, 0x25, 0x377, 0xa, 0x25, 0x3, 0x25, 0x5, 0x25, 0x37a, 0xa, 0x25, 
       0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 0x7, 0x26, 0x37f, 0xa, 0x26, 0xc, 
       0x26, 0xe, 0x26, 0x382, 0xb, 0x26, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 
       0x5, 0x27, 0x387, 0xa, 0x27, 0x3, 0x27, 0x7, 0x27, 0x38a, 0xa, 0x27, 
       0xc, 0x27, 0xe, 0x27, 0x38d, 0xb, 0x27, 0x3, 0x27, 0x7, 0x27, 0x390, 
       0xa, 0x27, 0xc, 0x27, 0xe, 0x27, 0x393, 0xb, 0x27, 0x3, 0x27, 0x3, 
       0x27, 0x5, 0x27, 0x397, 0xa, 0x27, 0x3, 0x27, 0x5, 0x27, 0x39a, 0xa, 
       0x27, 0x3, 0x28, 0x3, 0x28, 0x3, 0x29, 0x3, 0x29, 0x5, 0x29, 0x3a0, 
       0xa, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 
       0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x7, 0x29, 
       0x3ac, 0xa, 0x29, 0xc, 0x29, 0xe, 0x29, 0x3af, 0xb, 0x29, 0x3, 0x29, 
       0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x3, 0x29, 0x7, 0x29, 0x3b6, 0xa, 
       0x29, 0xc, 0x29, 0xe, 0x29, 0x3b9, 0xb, 0x29, 0x3, 0x29, 0x3, 0x29, 
       0x3, 0x29, 0x5, 0x29, 0x3be, 0xa, 0x29, 0x3, 0x2a, 0x3, 0x2a, 0x3, 
       0x2a, 0x5, 0x2a, 0x3c3, 0xa, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 
       0x5, 0x2a, 0x3c8, 0xa, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x5, 
       0x2a, 0x3cd, 0xa, 0x2a, 0x7, 0x2a, 0x3cf, 0xa, 0x2a, 0xc, 0x2a, 0xe, 
       0x2a, 0x3d2, 0xb, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x5, 0x2a, 0x3d6, 0xa, 
       0x2a, 0x3, 0x2a, 0x5, 0x2a, 0x3d9, 0xa, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 
       0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x7, 0x2a, 0x3e1, 0xa, 
       0x2a, 0xc, 0x2a, 0xe, 0x2a, 0x3e4, 0xb, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 
       0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x7, 0x2a, 
       0x3ed, 0xa, 0x2a, 0xc, 0x2a, 0xe, 0x2a, 0x3f0, 0xb, 0x2a, 0x3, 0x2a, 
       0x3, 0x2a, 0x7, 0x2a, 0x3f4, 0xa, 0x2a, 0xc, 0x2a, 0xe, 0x2a, 0x3f7, 
       0xb, 0x2a, 0x5, 0x2a, 0x3f9, 0xa, 0x2a, 0x3, 0x2b, 0x3, 0x2b, 0x3, 
       0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 
       0x2b, 0x3, 0x2b, 0x5, 0x2b, 0x405, 0xa, 0x2b, 0x3, 0x2c, 0x6, 0x2c, 
       0x408, 0xa, 0x2c, 0xd, 0x2c, 0xe, 0x2c, 0x409, 0x3, 0x2d, 0x3, 0x2d, 
       0x3, 0x2d, 0x5, 0x2d, 0x40f, 0xa, 0x2d, 0x3, 0x2e, 0x5, 0x2e, 0x412, 
       0xa, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2f, 0x6, 0x2f, 0x417, 0xa, 
       0x2f, 0xd, 0x2f, 0xe, 0x2f, 0x418, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 
       0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 
       0x3, 0x30, 0x5, 0x30, 0x425, 0xa, 0x30, 0x3, 0x31, 0x3, 0x31, 0x3, 
       0x31, 0x3, 0x31, 0x3, 0x31, 0x3, 0x31, 0x3, 0x31, 0x3, 0x31, 0x3, 
       0x31, 0x3, 0x31, 0x3, 0x31, 0x6, 0x31, 0x432, 0xa, 0x31, 0xd, 0x31, 
       0xe, 0x31, 0x433, 0x3, 0x31, 0x3, 0x31, 0x3, 0x31, 0x5, 0x31, 0x439, 
       0xa, 0x31, 0x3, 0x32, 0x5, 0x32, 0x43c, 0xa, 0x32, 0x3, 0x32, 0x3, 
       0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 
       0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 0x7, 0x32, 0x449, 0xa, 0x32, 
       0xc, 0x32, 0xe, 0x32, 0x44c, 0xb, 0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 
       0x32, 0x5, 0x32, 0x451, 0xa, 0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 
       0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 
       0x5, 0x32, 0x45c, 0xa, 0x32, 0x3, 0x33, 0x5, 0x33, 0x45f, 0xa, 0x33, 
       0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 
       0x7, 0x33, 0x467, 0xa, 0x33, 0xc, 0x33, 0xe, 0x33, 0x46a, 0xb, 0x33, 
       0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x5, 0x33, 0x470, 0xa, 
       0x33, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x5, 0x34, 0x476, 
       0xa, 0x34, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 0x7, 0x35, 
       0x47c, 0xa, 0x35, 0xc, 0x35, 0xe, 0x35, 0x47f, 0xb, 0x35, 0x3, 0x36, 
       0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 
       0x5, 0x36, 0x488, 0xa, 0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 
       0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 
       0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 
       0x36, 0x3, 0x36, 0x3, 0x36, 0x5, 0x36, 0x49c, 0xa, 0x36, 0x3, 0x37, 
       0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x5, 0x37, 0x4a2, 0xa, 0x37, 0x3, 
       0x38, 0x3, 0x38, 0x5, 0x38, 0x4a6, 0xa, 0x38, 0x3, 0x38, 0x3, 0x38, 
       0x3, 0x38, 0x5, 0x38, 0x4ab, 0xa, 0x38, 0x3, 0x38, 0x3, 0x38, 0x5, 
       0x38, 0x4af, 0xa, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x5, 0x38, 
       0x4b4, 0xa, 0x38, 0x3, 0x38, 0x5, 0x38, 0x4b7, 0xa, 0x38, 0x3, 0x38, 
       0x3, 0x38, 0x3, 0x38, 0x5, 0x38, 0x4bc, 0xa, 0x38, 0x3, 0x38, 0x5, 
       0x38, 0x4bf, 0xa, 0x38, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 
       0x3, 0x39, 0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 
       0x5, 0x3b, 0x4cb, 0xa, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3c, 0x3, 
       0x3c, 0x3, 0x3c, 0x5, 0x3c, 0x4d2, 0xa, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 
       0x3, 0x3c, 0x5, 0x3c, 0x4d7, 0xa, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 
       0x3c, 0x5, 0x3c, 0x4dc, 0xa, 0x3c, 0x7, 0x3c, 0x4de, 0xa, 0x3c, 0xc, 
       0x3c, 0xe, 0x3c, 0x4e1, 0xb, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x5, 0x3c, 
       0x4e5, 0xa, 0x3c, 0x3, 0x3c, 0x5, 0x3c, 0x4e8, 0xa, 0x3c, 0x3, 0x3c, 
       0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x7, 0x3c, 
       0x4f0, 0xa, 0x3c, 0xc, 0x3c, 0xe, 0x3c, 0x4f3, 0xb, 0x3c, 0x3, 0x3c, 
       0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 
       0x7, 0x3c, 0x4fc, 0xa, 0x3c, 0xc, 0x3c, 0xe, 0x3c, 0x4ff, 0xb, 0x3c, 
       0x3, 0x3c, 0x3, 0x3c, 0x7, 0x3c, 0x503, 0xa, 0x3c, 0xc, 0x3c, 0xe, 
       0x3c, 0x506, 0xb, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 
       0x3, 0x3c, 0x5, 0x3c, 0x50d, 0xa, 0x3c, 0x3, 0x3d, 0x3, 0x3d, 0x3, 
       0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 
       0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x5, 0x3d, 0x51b, 0xa, 0x3d, 
       0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x5, 0x3d, 
       0x53a, 0xa, 0x3d, 0x5, 0x3d, 0x53c, 0xa, 0x3d, 0x3, 0x3e, 0x3, 0x3e, 
       0x3, 0x3e, 0x5, 0x3e, 0x541, 0xa, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x5, 
       0x3e, 0x545, 0xa, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3f, 0x5, 0x3f, 
       0x54a, 0xa, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 
       0x3f, 0x5, 0x3f, 0x551, 0xa, 0x3f, 0x3, 0x3f, 0x5, 0x3f, 0x554, 0xa, 
       0x3f, 0x3, 0x40, 0x5, 0x40, 0x557, 0xa, 0x40, 0x3, 0x40, 0x3, 0x40, 
       0x3, 0x40, 0x5, 0x40, 0x55c, 0xa, 0x40, 0x3, 0x40, 0x3, 0x40, 0x5, 
       0x40, 0x560, 0xa, 0x40, 0x5, 0x40, 0x562, 0xa, 0x40, 0x3, 0x41, 0x3, 
       0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x5, 0x41, 0x569, 0xa, 0x41, 
       0x3, 0x41, 0x3, 0x41, 0x7, 0x41, 0x56d, 0xa, 0x41, 0xc, 0x41, 0xe, 
       0x41, 0x570, 0xb, 0x41, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 
       0x5, 0x42, 0x576, 0xa, 0x42, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 0x3, 
       0x43, 0x5, 0x43, 0x57c, 0xa, 0x43, 0x3, 0x43, 0x5, 0x43, 0x57f, 0xa, 
       0x43, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 0x5, 0x43, 0x584, 0xa, 0x43, 
       0x3, 0x43, 0x3, 0x43, 0x5, 0x43, 0x588, 0xa, 0x43, 0x3, 0x43, 0x5, 
       0x43, 0x58b, 0xa, 0x43, 0x3, 0x43, 0x3, 0x43, 0x3, 0x44, 0x3, 0x44, 
       0x3, 0x44, 0x5, 0x44, 0x592, 0xa, 0x44, 0x3, 0x45, 0x3, 0x45, 0x3, 
       0x45, 0x3, 0x45, 0x5, 0x45, 0x598, 0xa, 0x45, 0x3, 0x45, 0x5, 0x45, 
       0x59b, 0xa, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 
       0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x5, 0x45, 0x5a5, 0xa, 0x45, 
       0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x7, 0x46, 
       0x5ac, 0xa, 0x46, 0xc, 0x46, 0xe, 0x46, 0x5af, 0xb, 0x46, 0x3, 0x47, 
       0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 0x5, 0x47, 0x5b5, 0xa, 0x47, 0x3, 
       0x47, 0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 0x5, 0x47, 0x5bc, 
       0xa, 0x47, 0x5, 0x47, 0x5be, 0xa, 0x47, 0x3, 0x48, 0x3, 0x48, 0x3, 
       0x48, 0x3, 0x48, 0x5, 0x48, 0x5c4, 0xa, 0x48, 0x3, 0x48, 0x5, 0x48, 
       0x5c7, 0xa, 0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 
       0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x5, 0x48, 0x5d2, 
       0xa, 0x48, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 
       0x7, 0x49, 0x5d9, 0xa, 0x49, 0xc, 0x49, 0xe, 0x49, 0x5dc, 0xb, 0x49, 
       0x3, 0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x5, 0x4a, 0x5e1, 0xa, 0x4a, 0x3, 
       0x4b, 0x3, 0x4b, 0x3, 0x4b, 0x3, 0x4b, 0x5, 0x4b, 0x5e7, 0xa, 0x4b, 
       0x3, 0x4b, 0x5, 0x4b, 0x5ea, 0xa, 0x4b, 0x3, 0x4b, 0x3, 0x4b, 0x3, 
       0x4b, 0x5, 0x4b, 0x5ef, 0xa, 0x4b, 0x3, 0x4b, 0x5, 0x4b, 0x5f2, 0xa, 
       0x4b, 0x3, 0x4b, 0x5, 0x4b, 0x5f5, 0xa, 0x4b, 0x3, 0x4b, 0x5, 0x4b, 
       0x5f8, 0xa, 0x4b, 0x3, 0x4b, 0x5, 0x4b, 0x5fb, 0xa, 0x4b, 0x3, 0x4b, 
       0x3, 0x4b, 0x3, 0x4b, 0x3, 0x4b, 0x5, 0x4b, 0x601, 0xa, 0x4b, 0x3, 
       0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x7, 
       0x4c, 0x609, 0xa, 0x4c, 0xc, 0x4c, 0xe, 0x4c, 0x60c, 0xb, 0x4c, 0x3, 
       0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x7, 
       0x4c, 0x614, 0xa, 0x4c, 0xc, 0x4c, 0xe, 0x4c, 0x617, 0xb, 0x4c, 0x5, 
       0x4c, 0x619, 0xa, 0x4c, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 
       0x3, 0x4d, 0x5, 0x4d, 0x620, 0xa, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x3, 
       0x4d, 0x5, 0x4d, 0x625, 0xa, 0x4d, 0x3, 0x4d, 0x7, 0x4d, 0x628, 0xa, 
       0x4d, 0xc, 0x4d, 0xe, 0x4d, 0x62b, 0xb, 0x4d, 0x3, 0x4d, 0x5, 0x4d, 
       0x62e, 0xa, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x3, 
       0x4d, 0x3, 0x4d, 0x5, 0x4d, 0x636, 0xa, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 
       0x5, 0x4d, 0x63a, 0xa, 0x4d, 0x3, 0x4d, 0x7, 0x4d, 0x63d, 0xa, 0x4d, 
       0xc, 0x4d, 0xe, 0x4d, 0x640, 0xb, 0x4d, 0x3, 0x4d, 0x5, 0x4d, 0x643, 
       0xa, 0x4d, 0x5, 0x4d, 0x645, 0xa, 0x4d, 0x3, 0x4e, 0x6, 0x4e, 0x648, 
       0xa, 0x4e, 0xd, 0x4e, 0xe, 0x4e, 0x649, 0x3, 0x4f, 0x3, 0x4f, 0x3, 
       0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x5, 0x4f, 0x652, 0xa, 0x4f, 
       0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x5, 0x4f, 0x657, 0xa, 0x4f, 0x3, 
       0x50, 0x3, 0x50, 0x3, 0x50, 0x3, 0x50, 0x5, 0x50, 0x65d, 0xa, 0x50, 
       0x3, 0x50, 0x3, 0x50, 0x3, 0x50, 0x3, 0x50, 0x3, 0x50, 0x5, 0x50, 
       0x664, 0xa, 0x50, 0x3, 0x50, 0x5, 0x50, 0x667, 0xa, 0x50, 0x3, 0x51, 
       0x3, 0x51, 0x3, 0x51, 0x3, 0x52, 0x3, 0x52, 0x5, 0x52, 0x66e, 0xa, 
       0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 
       0x52, 0x5, 0x52, 0x676, 0xa, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 0x52, 
       0x3, 0x52, 0x7, 0x52, 0x67c, 0xa, 0x52, 0xc, 0x52, 0xe, 0x52, 0x67f, 
       0xb, 0x52, 0x5, 0x52, 0x681, 0xa, 0x52, 0x3, 0x52, 0x5, 0x52, 0x684, 
       0xa, 0x52, 0x3, 0x53, 0x3, 0x53, 0x3, 0x53, 0x5, 0x53, 0x689, 0xa, 
       0x53, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x7, 
       0x54, 0x690, 0xa, 0x54, 0xc, 0x54, 0xe, 0x54, 0x693, 0xb, 0x54, 0x3, 
       0x54, 0x5, 0x54, 0x696, 0xa, 0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 
       0x3, 0x55, 0x3, 0x55, 0x3, 0x55, 0x3, 0x55, 0x3, 0x55, 0x5, 0x55, 
       0x6a0, 0xa, 0x55, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 
       0x56, 0x3, 0x56, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 0x57, 0x3, 
       0x57, 0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 0x59, 0x3, 0x59, 0x3, 
       0x59, 0x5, 0x59, 0x6b3, 0xa, 0x59, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 
       0x3, 0x5a, 0x3, 0x5a, 0x5, 0x5a, 0x6ba, 0xa, 0x5a, 0x5, 0x5a, 0x6bc, 
       0xa, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x5, 0x5a, 0x6c0, 0xa, 0x5a, 0x3, 
       0x5a, 0x3, 0x5a, 0x5, 0x5a, 0x6c4, 0xa, 0x5a, 0x3, 0x5b, 0x3, 0x5b, 
       0x3, 0x5b, 0x3, 0x5b, 0x7, 0x5b, 0x6ca, 0xa, 0x5b, 0xc, 0x5b, 0xe, 
       0x5b, 0x6cd, 0xb, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5c, 0x3, 0x5c, 
       0x3, 0x5c, 0x3, 0x5c, 0x7, 0x5c, 0x6d5, 0xa, 0x5c, 0xc, 0x5c, 0xe, 
       0x5c, 0x6d8, 0xb, 0x5c, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 
       0x7, 0x5d, 0x6de, 0xa, 0x5d, 0xc, 0x5d, 0xe, 0x5d, 0x6e1, 0xb, 0x5d, 
       0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x5, 0x5e, 
       0x6e8, 0xa, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x3, 
       0x5f, 0x3, 0x5f, 0x5, 0x5f, 0x6f0, 0xa, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 
       0x5, 0x5f, 0x6f4, 0xa, 0x5f, 0x3, 0x60, 0x3, 0x60, 0x3, 0x60, 0x3, 
       0x60, 0x3, 0x61, 0x3, 0x61, 0x5, 0x61, 0x6fc, 0xa, 0x61, 0x3, 0x62, 
       0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 0x63, 
       0x3, 0x63, 0x3, 0x63, 0x3, 0x63, 0x3, 0x64, 0x3, 0x64, 0x3, 0x64, 
       0x3, 0x64, 0x7, 0x64, 0x70c, 0xa, 0x64, 0xc, 0x64, 0xe, 0x64, 0x70f, 
       0xb, 0x64, 0x3, 0x64, 0x3, 0x64, 0x3, 0x64, 0x3, 0x64, 0x3, 0x65, 
       0x3, 0x65, 0x3, 0x65, 0x3, 0x65, 0x3, 0x65, 0x3, 0x66, 0x3, 0x66, 
       0x5, 0x66, 0x71c, 0xa, 0x66, 0x3, 0x67, 0x3, 0x67, 0x3, 0x67, 0x3, 
       0x67, 0x3, 0x67, 0x5, 0x67, 0x723, 0xa, 0x67, 0x3, 0x67, 0x3, 0x67, 
       0x5, 0x67, 0x727, 0xa, 0x67, 0x3, 0x68, 0x3, 0x68, 0x3, 0x68, 0x3, 
       0x68, 0x3, 0x68, 0x5, 0x68, 0x72e, 0xa, 0x68, 0x5, 0x68, 0x730, 0xa, 
       0x68, 0x3, 0x69, 0x3, 0x69, 0x5, 0x69, 0x734, 0xa, 0x69, 0x3, 0x69, 
       0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x7, 0x69, 0x73b, 0xa, 
       0x69, 0xc, 0x69, 0xe, 0x69, 0x73e, 0xb, 0x69, 0x3, 0x6a, 0x3, 0x6a, 
       0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x5, 0x6a, 0x745, 0xa, 0x6a, 0x3, 
       0x6b, 0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6b, 0x7, 0x6b, 0x74c, 
       0xa, 0x6b, 0xc, 0x6b, 0xe, 0x6b, 0x74f, 0xb, 0x6b, 0x3, 0x6b, 0x3, 
       0x6b, 0x3, 0x6c, 0x3, 0x6c, 0x3, 0x6c, 0x3, 0x6d, 0x3, 0x6d, 0x3, 
       0x6d, 0x3, 0x6d, 0x3, 0x6d, 0x3, 0x6d, 0x3, 0x6e, 0x3, 0x6e, 0x5, 
       0x6e, 0x75e, 0xa, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 
       0x5, 0x6e, 0x764, 0xa, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x5, 0x6e, 0x768, 
       0xa, 0x6e, 0x3, 0x6f, 0x3, 0x6f, 0x3, 0x6f, 0x3, 0x6f, 0x3, 0x6f, 
       0x3, 0x6f, 0x7, 0x6f, 0x770, 0xa, 0x6f, 0xc, 0x6f, 0xe, 0x6f, 0x773, 
       0xb, 0x6f, 0x3, 0x6f, 0x3, 0x6f, 0x3, 0x6f, 0x7, 0x6f, 0x778, 0xa, 
       0x6f, 0xc, 0x6f, 0xe, 0x6f, 0x77b, 0xb, 0x6f, 0x3, 0x70, 0x3, 0x70, 
       0x3, 0x70, 0x3, 0x70, 0x3, 0x70, 0x3, 0x70, 0x5, 0x70, 0x783, 0xa, 
       0x70, 0x3, 0x70, 0x3, 0x70, 0x5, 0x70, 0x787, 0xa, 0x70, 0x3, 0x70, 
       0x3, 0x70, 0x7, 0x70, 0x78b, 0xa, 0x70, 0xc, 0x70, 0xe, 0x70, 0x78e, 
       0xb, 0x70, 0x3, 0x71, 0x3, 0x71, 0x5, 0x71, 0x792, 0xa, 0x71, 0x3, 
       0x72, 0x3, 0x72, 0x5, 0x72, 0x796, 0xa, 0x72, 0x3, 0x73, 0x3, 0x73, 
       0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 
       0x5, 0x73, 0x7a0, 0xa, 0x73, 0x3, 0x74, 0x3, 0x74, 0x3, 0x75, 0x3, 
       0x75, 0x5, 0x75, 0x7a6, 0xa, 0x75, 0x3, 0x76, 0x3, 0x76, 0x5, 0x76, 
       0x7aa, 0xa, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 
       0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x7, 0x76, 0x7b4, 0xa, 0x76, 
       0xc, 0x76, 0xe, 0x76, 0x7b7, 0xb, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 
       0x77, 0x3, 0x77, 0x5, 0x77, 0x7bd, 0xa, 0x77, 0x3, 0x78, 0x3, 0x78, 
       0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 
       0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x7, 0x79, 0x7cb, 0xa, 
       0x79, 0xc, 0x79, 0xe, 0x79, 0x7ce, 0xb, 0x79, 0x3, 0x79, 0x3, 0x79, 
       0x7, 0x79, 0x7d2, 0xa, 0x79, 0xc, 0x79, 0xe, 0x79, 0x7d5, 0xb, 0x79, 
       0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 
       0x3, 0x7a, 0x5, 0x7a, 0x7de, 0xa, 0x7a, 0x3, 0x7b, 0x5, 0x7b, 0x7e1, 
       0xa, 0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x5, 0x7b, 0x7e5, 0xa, 0x7b, 0x3, 
       0x7c, 0x3, 0x7c, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x5, 0x7d, 0x7ec, 
       0xa, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 
       0x5, 0x7d, 0x7f3, 0xa, 0x7d, 0x5, 0x7d, 0x7f5, 0xa, 0x7d, 0x3, 0x7e, 
       0x3, 0x7e, 0x5, 0x7e, 0x7f9, 0xa, 0x7e, 0x3, 0x7f, 0x3, 0x7f, 0x5, 
       0x7f, 0x7fd, 0xa, 0x7f, 0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 0x5, 0x80, 
       0x802, 0xa, 0x80, 0x3, 0x81, 0x5, 0x81, 0x805, 0xa, 0x81, 0x3, 0x81, 
       0x3, 0x81, 0x5, 0x81, 0x809, 0xa, 0x81, 0x3, 0x81, 0x5, 0x81, 0x80c, 
       0xa, 0x81, 0x3, 0x81, 0x3, 0x81, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 
       0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x5, 0x83, 0x817, 0xa, 
       0x83, 0x3, 0x83, 0x5, 0x83, 0x81a, 0xa, 0x83, 0x3, 0x83, 0x3, 0x83, 
       0x3, 0x83, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x85, 0x3, 0x85, 
       0x5, 0x85, 0x824, 0xa, 0x85, 0x3, 0x85, 0x3, 0x85, 0x3, 0x86, 0x3, 
       0x86, 0x3, 0x86, 0x3, 0x87, 0x3, 0x87, 0x5, 0x87, 0x82d, 0xa, 0x87, 
       0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 0x7, 0x87, 0x832, 0xa, 0x87, 0xc, 
       0x87, 0xe, 0x87, 0x835, 0xb, 0x87, 0x3, 0x87, 0x5, 0x87, 0x838, 0xa, 
       0x87, 0x3, 0x87, 0x3, 0x87, 0x5, 0x87, 0x83c, 0xa, 0x87, 0x3, 0x87, 
       0x3, 0x87, 0x3, 0x87, 0x7, 0x87, 0x841, 0xa, 0x87, 0xc, 0x87, 0xe, 
       0x87, 0x844, 0xb, 0x87, 0x3, 0x87, 0x5, 0x87, 0x847, 0xa, 0x87, 0x3, 
       0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x5, 
       0x88, 0x84f, 0xa, 0x88, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 
       0x5, 0x89, 0x855, 0xa, 0x89, 0x3, 0x89, 0x3, 0x89, 0x5, 0x89, 0x859, 
       0xa, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 
       0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x5, 0x8a, 0x864, 0xa, 
       0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x5, 
       0x8a, 0x86b, 0xa, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 
       0x3, 0x8a, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 
       0x3, 0x8b, 0x5, 0x8b, 0x878, 0xa, 0x8b, 0x3, 0x8c, 0x3, 0x8c, 0x3, 
       0x8c, 0x3, 0x8c, 0x7, 0x8c, 0x87e, 0xa, 0x8c, 0xc, 0x8c, 0xe, 0x8c, 
       0x881, 0xb, 0x8c, 0x3, 0x8d, 0x5, 0x8d, 0x884, 0xa, 0x8d, 0x3, 0x8d, 
       0x3, 0x8d, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x7, 0x8e, 
       0x88c, 0xa, 0x8e, 0xc, 0x8e, 0xe, 0x8e, 0x88f, 0xb, 0x8e, 0x3, 0x8f, 
       0x3, 0x8f, 0x5, 0x8f, 0x893, 0xa, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x3, 
       0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x3, 0x90, 0x3, 0x90, 0x3, 0x90, 0x3, 
       0x90, 0x7, 0x90, 0x89e, 0xa, 0x90, 0xc, 0x90, 0xe, 0x90, 0x8a1, 0xb, 
       0x90, 0x3, 0x90, 0x3, 0x90, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x3, 
       0x91, 0x7, 0x91, 0x8a9, 0xa, 0x91, 0xc, 0x91, 0xe, 0x91, 0x8ac, 0xb, 
       0x91, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x3, 0x92, 0x5, 
       0x92, 0x8b3, 0xa, 0x92, 0x3, 0x93, 0x3, 0x93, 0x5, 0x93, 0x8b7, 0xa, 
       0x93, 0x3, 0x93, 0x3, 0x93, 0x5, 0x93, 0x8bb, 0xa, 0x93, 0x3, 0x93, 
       0x3, 0x93, 0x5, 0x93, 0x8bf, 0xa, 0x93, 0x5, 0x93, 0x8c1, 0xa, 0x93, 
       0x3, 0x94, 0x3, 0x94, 0x3, 0x94, 0x5, 0x94, 0x8c6, 0xa, 0x94, 0x3, 
       0x94, 0x5, 0x94, 0x8c9, 0xa, 0x94, 0x3, 0x94, 0x5, 0x94, 0x8cc, 0xa, 
       0x94, 0x3, 0x94, 0x5, 0x94, 0x8cf, 0xa, 0x94, 0x3, 0x94, 0x3, 0x94, 
       0x5, 0x94, 0x8d3, 0xa, 0x94, 0x3, 0x94, 0x5, 0x94, 0x8d6, 0xa, 0x94, 
       0x3, 0x94, 0x5, 0x94, 0x8d9, 0xa, 0x94, 0x3, 0x95, 0x5, 0x95, 0x8dc, 
       0xa, 0x95, 0x3, 0x95, 0x5, 0x95, 0x8df, 0xa, 0x95, 0x3, 0x95, 0x3, 
       0x95, 0x3, 0x95, 0x7, 0x95, 0x8e4, 0xa, 0x95, 0xc, 0x95, 0xe, 0x95, 
       0x8e7, 0xb, 0x95, 0x3, 0x96, 0x3, 0x96, 0x3, 0x97, 0x3, 0x97, 0x3, 
       0x97, 0x3, 0x98, 0x3, 0x98, 0x3, 0x98, 0x5, 0x98, 0x8f1, 0xa, 0x98, 
       0x3, 0x98, 0x3, 0x98, 0x5, 0x98, 0x8f5, 0xa, 0x98, 0x3, 0x98, 0x5, 
       0x98, 0x8f8, 0xa, 0x98, 0x3, 0x99, 0x3, 0x99, 0x5, 0x99, 0x8fc, 0xa, 
       0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x5, 
       0x99, 0x903, 0xa, 0x99, 0x3, 0x9a, 0x3, 0x9a, 0x5, 0x9a, 0x907, 0xa, 
       0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 0x3, 
       0x9b, 0x7, 0x9b, 0x90f, 0xa, 0x9b, 0xc, 0x9b, 0xe, 0x9b, 0x912, 0xb, 
       0x9b, 0x3, 0x9c, 0x3, 0x9c, 0x3, 0x9c, 0x7, 0x9c, 0x917, 0xa, 0x9c, 
       0xc, 0x9c, 0xe, 0x9c, 0x91a, 0xb, 0x9c, 0x3, 0x9d, 0x3, 0x9d, 0x3, 
       0x9d, 0x5, 0x9d, 0x91f, 0xa, 0x9d, 0x3, 0x9e, 0x3, 0x9e, 0x5, 0x9e, 
       0x923, 0xa, 0x9e, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x5, 
       0x9f, 0x929, 0xa, 0x9f, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 
       0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 0x5, 0xa0, 0x932, 0xa, 0xa0, 0x3, 
       0xa1, 0x5, 0xa1, 0x935, 0xa, 0xa1, 0x3, 0xa1, 0x3, 0xa1, 0x3, 0xa1, 
       0x5, 0xa1, 0x93a, 0xa, 0xa1, 0x3, 0xa1, 0x5, 0xa1, 0x93d, 0xa, 0xa1, 
       0x3, 0xa2, 0x3, 0xa2, 0x3, 0xa2, 0x3, 0xa2, 0x3, 0xa2, 0x3, 0xa2, 
       0x7, 0xa2, 0x945, 0xa, 0xa2, 0xc, 0xa2, 0xe, 0xa2, 0x948, 0xb, 0xa2, 
       0x3, 0xa2, 0x3, 0xa2, 0x5, 0xa2, 0x94c, 0xa, 0xa2, 0x3, 0xa3, 0x3, 
       0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x7, 0xa3, 0x953, 0xa, 0xa3, 
       0xc, 0xa3, 0xe, 0xa3, 0x956, 0xb, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x5, 
       0xa3, 0x95a, 0xa, 0xa3, 0x3, 0xa4, 0x3, 0xa4, 0x5, 0xa4, 0x95e, 0xa, 
       0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x7, 
       0xa4, 0x965, 0xa, 0xa4, 0xc, 0xa4, 0xe, 0xa4, 0x968, 0xb, 0xa4, 0x3, 
       0xa4, 0x5, 0xa4, 0x96b, 0xa, 0xa4, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa6, 
       0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa7, 0x3, 0xa7, 0x3, 0xa7, 0x3, 0xa7, 
       0x3, 0xa7, 0x7, 0xa7, 0x977, 0xa, 0xa7, 0xc, 0xa7, 0xe, 0xa7, 0x97a, 
       0xb, 0xa7, 0x3, 0xa8, 0x3, 0xa8, 0x3, 0xa8, 0x3, 0xa9, 0x3, 0xa9, 
       0x3, 0xa9, 0x3, 0xaa, 0x3, 0xaa, 0x3, 0xaa, 0x3, 0xaa, 0x5, 0xaa, 
       0x986, 0xa, 0xaa, 0x3, 0xaa, 0x3, 0xaa, 0x3, 0xaa, 0x5, 0xaa, 0x98b, 
       0xa, 0xaa, 0x7, 0xaa, 0x98d, 0xa, 0xaa, 0xc, 0xaa, 0xe, 0xaa, 0x990, 
       0xb, 0xaa, 0x3, 0xab, 0x6, 0xab, 0x993, 0xa, 0xab, 0xd, 0xab, 0xe, 
       0xab, 0x994, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 
       0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 0x5, 0xac, 0x9a0, 0xa, 
       0xac, 0x5, 0xac, 0x9a2, 0xa, 0xac, 0x3, 0xad, 0x3, 0xad, 0x3, 0xad, 
       0x3, 0xad, 0x3, 0xad, 0x5, 0xad, 0x9a9, 0xa, 0xad, 0x3, 0xad, 0x5, 
       0xad, 0x9ac, 0xa, 0xad, 0x3, 0xae, 0x3, 0xae, 0x3, 0xae, 0x7, 0xae, 
       0x9b1, 0xa, 0xae, 0xc, 0xae, 0xe, 0xae, 0x9b4, 0xb, 0xae, 0x3, 0xaf, 
       0x3, 0xaf, 0x5, 0xaf, 0x9b8, 0xa, 0xaf, 0x3, 0xaf, 0x3, 0xaf, 0x3, 
       0xaf, 0x3, 0xaf, 0x5, 0xaf, 0x9be, 0xa, 0xaf, 0x3, 0xaf, 0x5, 0xaf, 
       0x9c1, 0xa, 0xaf, 0x3, 0xaf, 0x5, 0xaf, 0x9c4, 0xa, 0xaf, 0x3, 0xb0, 
       0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 
       0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x6, 0xb1, 0x9d1, 0xa, 
       0xb1, 0xd, 0xb1, 0xe, 0xb1, 0x9d2, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 
       0x3, 0xb2, 0x3, 0xb2, 0x5, 0xb2, 0x9da, 0xa, 0xb2, 0x3, 0xb2, 0x5, 
       0xb2, 0x9dd, 0xa, 0xb2, 0x3, 0xb2, 0x5, 0xb2, 0x9e0, 0xa, 0xb2, 0x3, 
       0xb3, 0x3, 0xb3, 0x5, 0xb3, 0x9e4, 0xa, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 
       0x3, 0xb3, 0x5, 0xb3, 0x9e9, 0xa, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x3, 
       0xb3, 0x3, 0xb3, 0x5, 0xb3, 0x9ef, 0xa, 0xb3, 0x3, 0xb4, 0x3, 0xb4, 
       0x5, 0xb4, 0x9f3, 0xa, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 
       0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x3, 0xb4, 0x7, 0xb4, 0x9fc, 0xa, 0xb4, 
       0xc, 0xb4, 0xe, 0xb4, 0x9ff, 0xb, 0xb4, 0x3, 0xb4, 0x5, 0xb4, 0xa02, 
       0xa, 0xb4, 0x3, 0xb4, 0x5, 0xb4, 0xa05, 0xa, 0xb4, 0x3, 0xb5, 0x3, 
       0xb5, 0x5, 0xb5, 0xa09, 0xa, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x5, 0xb5, 
       0xa0d, 0xa, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x5, 0xb5, 0xa11, 0xa, 0xb5, 
       0x3, 0xb6, 0x3, 0xb6, 0x5, 0xb6, 0xa15, 0xa, 0xb6, 0x3, 0xb6, 0x3, 
       0xb6, 0x3, 0xb7, 0x3, 0xb7, 0x5, 0xb7, 0xa1b, 0xa, 0xb7, 0x3, 0xb7, 
       0x3, 0xb7, 0x3, 0xb8, 0x3, 0xb8, 0x5, 0xb8, 0xa21, 0xa, 0xb8, 0x3, 
       0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x5, 0xb8, 0xa28, 
       0xa, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x7, 0xb8, 
       0xa2e, 0xa, 0xb8, 0xc, 0xb8, 0xe, 0xb8, 0xa31, 0xb, 0xb8, 0x3, 0xb9, 
       0x3, 0xb9, 0x3, 0xb9, 0x5, 0xb9, 0xa36, 0xa, 0xb9, 0x3, 0xba, 0x3, 
       0xba, 0x3, 0xba, 0x5, 0xba, 0xa3b, 0xa, 0xba, 0x3, 0xba, 0x3, 0xba, 
       0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 
       0x3, 0xba, 0x5, 0xba, 0xa46, 0xa, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 
       0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x3, 0xba, 0x5, 0xba, 0xa4f, 
       0xa, 0xba, 0x3, 0xbb, 0x3, 0xbb, 0x5, 0xbb, 0xa53, 0xa, 0xbb, 0x3, 
       0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x7, 0xbb, 0xa5a, 
       0xa, 0xbb, 0xc, 0xbb, 0xe, 0xbb, 0xa5d, 0xb, 0xbb, 0x3, 0xbb, 0x5, 
       0xbb, 0xa60, 0xa, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbc, 0x3, 0xbc, 
       0x3, 0xbc, 0x3, 0xbc, 0x7, 0xbc, 0xa68, 0xa, 0xbc, 0xc, 0xbc, 0xe, 
       0xbc, 0xa6b, 0xb, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x5, 0xbc, 0xa6f, 0xa, 
       0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 
       0xbd, 0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbe, 0x3, 0xbe, 0x3, 
       0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x3, 
       0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x5, 0xbf, 0xa85, 0xa, 0xbf, 0x3, 0xbf, 
       0x5, 0xbf, 0xa88, 0xa, 0xbf, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 
       0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 
       0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 
       0xc0, 0x3, 0xc0, 0x5, 0xc0, 0xa9b, 0xa, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 
       0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 
       0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 
       0x7, 0xc0, 0xaab, 0xa, 0xc0, 0xc, 0xc0, 0xe, 0xc0, 0xaae, 0xb, 0xc0, 
       0x3, 0xc1, 0x3, 0xc1, 0x3, 0xc1, 0x3, 0xc1, 0x3, 0xc1, 0x3, 0xc1, 
       0x3, 0xc1, 0x3, 0xc1, 0x5, 0xc1, 0xab8, 0xa, 0xc1, 0x3, 0xc2, 0x3, 
       0xc2, 0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc3, 0x3, 0xc3, 0x3, 0xc4, 0x3, 
       0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x7, 0xc4, 0xac5, 0xa, 0xc4, 
       0xc, 0xc4, 0xe, 0xc4, 0xac8, 0xb, 0xc4, 0x3, 0xc5, 0x3, 0xc5, 0x3, 
       0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x3, 
       0xc5, 0x5, 0xc5, 0xad3, 0xa, 0xc5, 0x3, 0xc6, 0x3, 0xc6, 0x5, 0xc6, 
       0xad7, 0xa, 0xc6, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x3, 
       0xc7, 0x3, 0xc7, 0x3, 0xc7, 0x6, 0xc7, 0xae0, 0xa, 0xc7, 0xd, 0xc7, 
       0xe, 0xc7, 0xae1, 0x3, 0xc7, 0x3, 0xc7, 0x5, 0xc7, 0xae6, 0xa, 0xc7, 
       0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 
       0x3, 0xc8, 0x3, 0xc8, 0x6, 0xc8, 0xaf0, 0xa, 0xc8, 0xd, 0xc8, 0xe, 
       0xc8, 0xaf1, 0x3, 0xc8, 0x3, 0xc8, 0x5, 0xc8, 0xaf6, 0xa, 0xc8, 0x3, 
       0xc8, 0x3, 0xc8, 0x3, 0xc9, 0x3, 0xc9, 0x3, 0xc9, 0x3, 0xc9, 0x3, 
       0xca, 0x3, 0xca, 0x3, 0xca, 0x5, 0xca, 0xb01, 0xa, 0xca, 0x3, 0xca, 
       0x3, 0xca, 0x3, 0xca, 0x5, 0xca, 0xb06, 0xa, 0xca, 0x3, 0xca, 0x3, 
       0xca, 0x3, 0xca, 0x5, 0xca, 0xb0b, 0xa, 0xca, 0x3, 0xca, 0x3, 0xca, 
       0x5, 0xca, 0xb0f, 0xa, 0xca, 0x3, 0xca, 0x3, 0xca, 0x5, 0xca, 0xb13, 
       0xa, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x5, 0xca, 0xb18, 0xa, 
       0xca, 0x3, 0xca, 0x3, 0xca, 0x5, 0xca, 0xb1c, 0xa, 0xca, 0x3, 0xca, 
       0x3, 0xca, 0x5, 0xca, 0xb20, 0xa, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 
       0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 
       0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 
       0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 
       0xca, 0x5, 0xca, 0xb37, 0xa, 0xca, 0x5, 0xca, 0xb39, 0xa, 0xca, 0x3, 
       0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 
       0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 
       0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x5, 0xca, 0xb4b, 0xa, 0xca, 
       0x5, 0xca, 0xb4d, 0xa, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 
       0xca, 0x3, 0xca, 0x3, 0xca, 0x5, 0xca, 0xb55, 0xa, 0xca, 0x3, 0xca, 
       0x3, 0xca, 0x3, 0xca, 0x5, 0xca, 0xb5a, 0xa, 0xca, 0x3, 0xca, 0x3, 
       0xca, 0x3, 0xca, 0x5, 0xca, 0xb5f, 0xa, 0xca, 0x3, 0xca, 0x3, 0xca, 
       0x3, 0xca, 0x5, 0xca, 0xb64, 0xa, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 
       0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 
       0xca, 0x3, 0xca, 0x3, 0xca, 0x5, 0xca, 0xb71, 0xa, 0xca, 0x3, 0xca, 
       0x3, 0xca, 0x3, 0xca, 0x5, 0xca, 0xb76, 0xa, 0xca, 0x3, 0xca, 0x3, 
       0xca, 0x3, 0xca, 0x5, 0xca, 0xb7b, 0xa, 0xca, 0x3, 0xca, 0x3, 0xca, 
       0x3, 0xca, 0x5, 0xca, 0xb80, 0xa, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 
       0xca, 0x5, 0xca, 0xb85, 0xa, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 
       0x5, 0xca, 0xb8a, 0xa, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x5, 
       0xca, 0xb8f, 0xa, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x5, 0xca, 
       0xb94, 0xa, 0xca, 0x5, 0xca, 0xb96, 0xa, 0xca, 0x3, 0xcb, 0x3, 0xcb, 
       0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcc, 0x5, 0xcc, 0xb9d, 0xa, 0xcc, 0x3, 
       0xcc, 0x5, 0xcc, 0xba0, 0xa, 0xcc, 0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcd, 
       0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x3, 0xcd, 0x7, 0xcd, 0xba9, 0xa, 
       0xcd, 0xc, 0xcd, 0xe, 0xcd, 0xbac, 0xb, 0xcd, 0x3, 0xce, 0x3, 0xce, 
       0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x5, 0xce, 
       0xbb5, 0xa, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 
       0xce, 0x3, 0xce, 0x5, 0xce, 0xbbd, 0xa, 0xce, 0x3, 0xce, 0x3, 0xce, 
       0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x5, 0xce, 
       0xbc6, 0xa, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x5, 
       0xce, 0xbcc, 0xa, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 
       0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 
       0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x7, 0xce, 0xbdb, 0xa, 0xce, 0xc, 
       0xce, 0xe, 0xce, 0xbde, 0xb, 0xce, 0x5, 0xce, 0xbe0, 0xa, 0xce, 0x3, 
       0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 
       0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x7, 
       0xce, 0xbee, 0xa, 0xce, 0xc, 0xce, 0xe, 0xce, 0xbf1, 0xb, 0xce, 0x5, 
       0xce, 0xbf3, 0xa, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 
       0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 
       0x3, 0xce, 0x3, 0xce, 0x7, 0xce, 0xc01, 0xa, 0xce, 0xc, 0xce, 0xe, 
       0xce, 0xc04, 0xb, 0xce, 0x5, 0xce, 0xc06, 0xa, 0xce, 0x3, 0xce, 0x3, 
       0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 
       0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x7, 0xce, 0xc14, 
       0xa, 0xce, 0xc, 0xce, 0xe, 0xce, 0xc17, 0xb, 0xce, 0x5, 0xce, 0xc19, 
       0xa, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 
       0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 
       0x3, 0xce, 0x7, 0xce, 0xc27, 0xa, 0xce, 0xc, 0xce, 0xe, 0xce, 0xc2a, 
       0xb, 0xce, 0x5, 0xce, 0xc2c, 0xa, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 
       0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 
       0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x7, 0xce, 0xc3a, 0xa, 0xce, 
       0xc, 0xce, 0xe, 0xce, 0xc3d, 0xb, 0xce, 0x5, 0xce, 0xc3f, 0xa, 0xce, 
       0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 
       0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x7, 0xce, 0xc4b, 0xa, 
       0xce, 0xc, 0xce, 0xe, 0xce, 0xc4e, 0xb, 0xce, 0x3, 0xce, 0x3, 0xce, 
       0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 
       0x3, 0xce, 0x3, 0xce, 0x6, 0xce, 0xc5a, 0xa, 0xce, 0xd, 0xce, 0xe, 
       0xce, 0xc5b, 0x3, 0xce, 0x3, 0xce, 0x5, 0xce, 0xc60, 0xa, 0xce, 0x3, 
       0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 
       0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 
       0xce, 0x3, 0xce, 0x5, 0xce, 0xc70, 0xa, 0xce, 0x3, 0xce, 0x3, 0xce, 
       0x3, 0xce, 0x3, 0xce, 0x5, 0xce, 0xc76, 0xa, 0xce, 0x3, 0xcf, 0x3, 
       0xcf, 0x3, 0xcf, 0x5, 0xcf, 0xc7b, 0xa, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 
       0x3, 0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x7, 0xd0, 0xc82, 0xa, 0xd0, 0xc, 
       0xd0, 0xe, 0xd0, 0xc85, 0xb, 0xd0, 0x3, 0xd1, 0x3, 0xd1, 0x3, 0xd1, 
       0x3, 0xd1, 0x5, 0xd1, 0xc8b, 0xa, 0xd1, 0x5, 0xd1, 0xc8d, 0xa, 0xd1, 
       0x3, 0xd1, 0x3, 0xd1, 0x3, 0xd2, 0x3, 0xd2, 0x5, 0xd2, 0xc93, 0xa, 
       0xd2, 0x3, 0xd3, 0x3, 0xd3, 0x5, 0xd3, 0xc97, 0xa, 0xd3, 0x3, 0xd4, 
       0x3, 0xd4, 0x7, 0xd4, 0xc9b, 0xa, 0xd4, 0xc, 0xd4, 0xe, 0xd4, 0xc9e, 
       0xb, 0xd4, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 
       0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 
       0x3, 0xd5, 0x5, 0xd5, 0xcac, 0xa, 0xd5, 0x3, 0xd6, 0x3, 0xd6, 0x3, 
       0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x5, 0xd6, 0xcb3, 0xa, 0xd6, 0x3, 0xd7, 
       0x7, 0xd7, 0xcb6, 0xa, 0xd7, 0xc, 0xd7, 0xe, 0xd7, 0xcb9, 0xb, 0xd7, 
       0x3, 0xd8, 0x3, 0xd8, 0x3, 0xd8, 0x3, 0xd9, 0x3, 0xd9, 0x3, 0xd9, 
       0x3, 0xd9, 0x5, 0xd9, 0xcc2, 0xa, 0xd9, 0x3, 0xd9, 0x3, 0xd9, 0x3, 
       0xd9, 0x7, 0xd9, 0xcc7, 0xa, 0xd9, 0xc, 0xd9, 0xe, 0xd9, 0xcca, 0xb, 
       0xd9, 0x5, 0xd9, 0xccc, 0xa, 0xd9, 0x3, 0xda, 0x3, 0xda, 0x3, 0xda, 
       0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdc, 0x3, 0xdc, 0x5, 0xdc, 
       0xcd6, 0xa, 0xdc, 0x3, 0xdc, 0x3, 0xdc, 0x3, 0xdc, 0x5, 0xdc, 0xcdb, 
       0xa, 0xdc, 0x7, 0xdc, 0xcdd, 0xa, 0xdc, 0xc, 0xdc, 0xe, 0xdc, 0xce0, 
       0xb, 0xdc, 0x3, 0xdd, 0x3, 0xdd, 0x5, 0xdd, 0xce4, 0xa, 0xdd, 0x3, 
       0xde, 0x5, 0xde, 0xce7, 0xa, 0xde, 0x3, 0xde, 0x3, 0xde, 0x3, 0xdf, 
       0x5, 0xdf, 0xcec, 0xa, 0xdf, 0x3, 0xdf, 0x3, 0xdf, 0x3, 0xe0, 0x3, 
       0xe0, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe2, 0x3, 0xe2, 0x3, 0xe2, 0x3, 
       0xcb7, 0x4, 0x16e, 0x17e, 0xe3, 0x2, 0x4, 0x6, 0x8, 0xa, 0xc, 0xe, 
       0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e, 0x20, 0x22, 0x24, 
       0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 
       0x3c, 0x3e, 0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 
       0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e, 0x60, 0x62, 0x64, 0x66, 
       0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 
       0x7e, 0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 
       0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e, 0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 
       0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe, 
       0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 
       0xd6, 0xd8, 0xda, 0xdc, 0xde, 0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 
       0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe, 0x100, 
       0x102, 0x104, 0x106, 0x108, 0x10a, 0x10c, 0x10e, 0x110, 0x112, 0x114, 
       0x116, 0x118, 0x11a, 0x11c, 0x11e, 0x120, 0x122, 0x124, 0x126, 0x128, 
       0x12a, 0x12c, 0x12e, 0x130, 0x132, 0x134, 0x136, 0x138, 0x13a, 0x13c, 
       0x13e, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14a, 0x14c, 0x14e, 0x150, 
       0x152, 0x154, 0x156, 0x158, 0x15a, 0x15c, 0x15e, 0x160, 0x162, 0x164, 
       0x166, 0x168, 0x16a, 0x16c, 0x16e, 0x170, 0x172, 0x174, 0x176, 0x178, 
       0x17a, 0x17c, 0x17e, 0x180, 0x182, 0x184, 0x186, 0x188, 0x18a, 0x18c, 
       0x18e, 0x190, 0x192, 0x194, 0x196, 0x198, 0x19a, 0x19c, 0x19e, 0x1a0, 
       0x1a2, 0x1a4, 0x1a6, 0x1a8, 0x1aa, 0x1ac, 0x1ae, 0x1b0, 0x1b2, 0x1b4, 
       0x1b6, 0x1b8, 0x1ba, 0x1bc, 0x1be, 0x1c0, 0x1c2, 0x2, 0x33, 0x5, 
       0x2, 0x3, 0x4, 0x15d, 0x15d, 0x16e, 0x16e, 0x4, 0x2, 0x64, 0x64, 
       0x138, 0x138, 0x3, 0x2, 0xaa, 0xab, 0x5, 0x2, 0x10, 0x10, 0x75, 0x75, 
       0x9b, 0x9b, 0x4, 0x2, 0x23, 0x23, 0x2b, 0x2b, 0x4, 0x2, 0x39, 0x39, 
       0x6d, 0x6d, 0x4, 0x2, 0xba, 0xba, 0x102, 0x102, 0x4, 0x2, 0x11, 0x11, 
       0x55, 0x55, 0x4, 0x2, 0x52, 0x52, 0x12d, 0x12d, 0x4, 0x2, 0x6e, 0x6e, 
       0xad, 0xad, 0x4, 0x2, 0x52, 0x52, 0xda, 0xda, 0x4, 0x2, 0x4e, 0x4e, 
       0x8a, 0x8a, 0x5, 0x2, 0x8e, 0x8e, 0xb4, 0xb4, 0xd6, 0xd7, 0x4, 0x2, 
       0xaf, 0xaf, 0xc1, 0xc1, 0x4, 0x2, 0xbe, 0xbe, 0x140, 0x140, 0x4, 
       0x2, 0xf5, 0xf5, 0x12a, 0x12a, 0x4, 0x2, 0xb3, 0xb3, 0x173, 0x173, 
       0x4, 0x2, 0x21, 0x21, 0x28, 0x28, 0x4, 0x2, 0x26, 0x26, 0x40, 0x40, 
       0x4, 0x2, 0x44, 0x44, 0xfb, 0xfb, 0x4, 0x2, 0x10, 0x10, 0x9b, 0x9b, 
       0x3, 0x2, 0xec, 0xed, 0x3, 0x2, 0xdd, 0xde, 0x6, 0x2, 0x3f, 0x3f, 
       0x50, 0x50, 0x9a, 0x9a, 0xd3, 0xd3, 0x3, 0x2, 0x68, 0x69, 0x3, 0x2, 
       0x61, 0x62, 0x3, 0x2, 0x112, 0x113, 0x4, 0x2, 0xf6, 0xf6, 0x11a, 
       0x11a, 0x5, 0x2, 0x52, 0x52, 0x89, 0x89, 0xd2, 0xd2, 0x6, 0x2, 0xe, 
       0xf, 0xbf, 0xbf, 0xe2, 0xe2, 0x13e, 0x13e, 0x3, 0x2, 0xc9, 0xca, 
       0x4, 0x2, 0x103, 0x103, 0x127, 0x127, 0x6, 0x2, 0x17, 0x17, 0x5c, 
       0x5c, 0xb0, 0xb0, 0x121, 0x121, 0x4, 0x2, 0xb0, 0xb0, 0x13a, 0x13a, 
       0x4, 0x2, 0x20, 0x20, 0x114, 0x114, 0x3, 0x2, 0x100, 0x101, 0x4, 
       0x2, 0xa, 0xa, 0x5a, 0x5a, 0x5, 0x2, 0x7a, 0x7a, 0xa4, 0xa4, 0xef, 
       0xef, 0x5, 0x2, 0x40, 0x40, 0xf7, 0xf8, 0x12e, 0x12e, 0x5, 0x2, 0x6b, 
       0x6b, 0x106, 0x106, 0x12d, 0x12d, 0x3, 0x2, 0x55, 0x56, 0x4, 0x2, 
       0xd, 0xd, 0xcd, 0xcd, 0x5, 0x2, 0xa5, 0xa5, 0xe6, 0xe6, 0xf0, 0xf0, 
       0x5, 0x2, 0x48, 0x49, 0xb7, 0xb8, 0xfc, 0xfd, 0x4, 0x2, 0x36, 0x36, 
       0x15c, 0x15c, 0x5, 0x2, 0x78, 0x78, 0x9c, 0x9c, 0xc4, 0xc4, 0x4, 
       0x2, 0x159, 0x159, 0x16f, 0x16f, 0x4, 0x2, 0x6f, 0x6f, 0x128, 0x128, 
       0xe, 0x2, 0x8, 0x1b, 0x1d, 0x5f, 0x63, 0x63, 0x65, 0xc4, 0xc6, 0xd7, 
       0xd9, 0xf4, 0xf6, 0x109, 0x10b, 0x122, 0x124, 0x129, 0x12c, 0x137, 
       0x13a, 0x14a, 0x151, 0x158, 0x2, 0xe9a, 0x2, 0x1c4, 0x3, 0x2, 0x2, 
       0x2, 0x4, 0x1cd, 0x3, 0x2, 0x2, 0x2, 0x6, 0x1d2, 0x3, 0x2, 0x2, 0x2, 
       0x8, 0x1e6, 0x3, 0x2, 0x2, 0x2, 0xa, 0x1e8, 0x3, 0x2, 0x2, 0x2, 0xc, 
       0x1f4, 0x3, 0x2, 0x2, 0x2, 0xe, 0x232, 0x3, 0x2, 0x2, 0x2, 0x10, 
       0x234, 0x3, 0x2, 0x2, 0x2, 0x12, 0x236, 0x3, 0x2, 0x2, 0x2, 0x14, 
       0x23c, 0x3, 0x2, 0x2, 0x2, 0x16, 0x242, 0x3, 0x2, 0x2, 0x2, 0x18, 
       0x244, 0x3, 0x2, 0x2, 0x2, 0x1a, 0x254, 0x3, 0x2, 0x2, 0x2, 0x1c, 
       0x259, 0x3, 0x2, 0x2, 0x2, 0x1e, 0x26b, 0x3, 0x2, 0x2, 0x2, 0x20, 
       0x26d, 0x3, 0x2, 0x2, 0x2, 0x22, 0x292, 0x3, 0x2, 0x2, 0x2, 0x24, 
       0x29c, 0x3, 0x2, 0x2, 0x2, 0x26, 0x2a7, 0x3, 0x2, 0x2, 0x2, 0x28, 
       0x2bb, 0x3, 0x2, 0x2, 0x2, 0x2a, 0x2be, 0x3, 0x2, 0x2, 0x2, 0x2c, 
       0x2c0, 0x3, 0x2, 0x2, 0x2, 0x2e, 0x2ca, 0x3, 0x2, 0x2, 0x2, 0x30, 
       0x2d3, 0x3, 0x2, 0x2, 0x2, 0x32, 0x2de, 0x3, 0x2, 0x2, 0x2, 0x34, 
       0x2ed, 0x3, 0x2, 0x2, 0x2, 0x36, 0x312, 0x3, 0x2, 0x2, 0x2, 0x38, 
       0x314, 0x3, 0x2, 0x2, 0x2, 0x3a, 0x31c, 0x3, 0x2, 0x2, 0x2, 0x3c, 
       0x327, 0x3, 0x2, 0x2, 0x2, 0x3e, 0x330, 0x3, 0x2, 0x2, 0x2, 0x40, 
       0x333, 0x3, 0x2, 0x2, 0x2, 0x42, 0x340, 0x3, 0x2, 0x2, 0x2, 0x44, 
       0x34a, 0x3, 0x2, 0x2, 0x2, 0x46, 0x357, 0x3, 0x2, 0x2, 0x2, 0x48, 
       0x376, 0x3, 0x2, 0x2, 0x2, 0x4a, 0x37b, 0x3, 0x2, 0x2, 0x2, 0x4c, 
       0x399, 0x3, 0x2, 0x2, 0x2, 0x4e, 0x39b, 0x3, 0x2, 0x2, 0x2, 0x50, 
       0x3bd, 0x3, 0x2, 0x2, 0x2, 0x52, 0x3f8, 0x3, 0x2, 0x2, 0x2, 0x54, 
       0x3fa, 0x3, 0x2, 0x2, 0x2, 0x56, 0x407, 0x3, 0x2, 0x2, 0x2, 0x58, 
       0x40e, 0x3, 0x2, 0x2, 0x2, 0x5a, 0x411, 0x3, 0x2, 0x2, 0x2, 0x5c, 
       0x416, 0x3, 0x2, 0x2, 0x2, 0x5e, 0x424, 0x3, 0x2, 0x2, 0x2, 0x60, 
       0x438, 0x3, 0x2, 0x2, 0x2, 0x62, 0x45b, 0x3, 0x2, 0x2, 0x2, 0x64, 
       0x46f, 0x3, 0x2, 0x2, 0x2, 0x66, 0x475, 0x3, 0x2, 0x2, 0x2, 0x68, 
       0x477, 0x3, 0x2, 0x2, 0x2, 0x6a, 0x49b, 0x3, 0x2, 0x2, 0x2, 0x6c, 
       0x4a1, 0x3, 0x2, 0x2, 0x2, 0x6e, 0x4be, 0x3, 0x2, 0x2, 0x2, 0x70, 
       0x4c0, 0x3, 0x2, 0x2, 0x2, 0x72, 0x4c5, 0x3, 0x2, 0x2, 0x2, 0x74, 
       0x4c7, 0x3, 0x2, 0x2, 0x2, 0x76, 0x50c, 0x3, 0x2, 0x2, 0x2, 0x78, 
       0x53b, 0x3, 0x2, 0x2, 0x2, 0x7a, 0x53d, 0x3, 0x2, 0x2, 0x2, 0x7c, 
       0x553, 0x3, 0x2, 0x2, 0x2, 0x7e, 0x561, 0x3, 0x2, 0x2, 0x2, 0x80, 
       0x563, 0x3, 0x2, 0x2, 0x2, 0x82, 0x575, 0x3, 0x2, 0x2, 0x2, 0x84, 
       0x57e, 0x3, 0x2, 0x2, 0x2, 0x86, 0x58e, 0x3, 0x2, 0x2, 0x2, 0x88, 
       0x59a, 0x3, 0x2, 0x2, 0x2, 0x8a, 0x5a6, 0x3, 0x2, 0x2, 0x2, 0x8c, 
       0x5bd, 0x3, 0x2, 0x2, 0x2, 0x8e, 0x5c6, 0x3, 0x2, 0x2, 0x2, 0x90, 
       0x5d3, 0x3, 0x2, 0x2, 0x2, 0x92, 0x5e0, 0x3, 0x2, 0x2, 0x2, 0x94, 
       0x5e9, 0x3, 0x2, 0x2, 0x2, 0x96, 0x618, 0x3, 0x2, 0x2, 0x2, 0x98, 
       0x644, 0x3, 0x2, 0x2, 0x2, 0x9a, 0x647, 0x3, 0x2, 0x2, 0x2, 0x9c, 
       0x656, 0x3, 0x2, 0x2, 0x2, 0x9e, 0x666, 0x3, 0x2, 0x2, 0x2, 0xa0, 
       0x668, 0x3, 0x2, 0x2, 0x2, 0xa2, 0x66b, 0x3, 0x2, 0x2, 0x2, 0xa4, 
       0x688, 0x3, 0x2, 0x2, 0x2, 0xa6, 0x68a, 0x3, 0x2, 0x2, 0x2, 0xa8, 
       0x69a, 0x3, 0x2, 0x2, 0x2, 0xaa, 0x6a1, 0x3, 0x2, 0x2, 0x2, 0xac, 
       0x6a7, 0x3, 0x2, 0x2, 0x2, 0xae, 0x6ac, 0x3, 0x2, 0x2, 0x2, 0xb0, 
       0x6af, 0x3, 0x2, 0x2, 0x2, 0xb2, 0x6b4, 0x3, 0x2, 0x2, 0x2, 0xb4, 
       0x6c5, 0x3, 0x2, 0x2, 0x2, 0xb6, 0x6d0, 0x3, 0x2, 0x2, 0x2, 0xb8, 
       0x6d9, 0x3, 0x2, 0x2, 0x2, 0xba, 0x6e4, 0x3, 0x2, 0x2, 0x2, 0xbc, 
       0x6ed, 0x3, 0x2, 0x2, 0x2, 0xbe, 0x6f5, 0x3, 0x2, 0x2, 0x2, 0xc0, 
       0x6fb, 0x3, 0x2, 0x2, 0x2, 0xc2, 0x6fd, 0x3, 0x2, 0x2, 0x2, 0xc4, 
       0x703, 0x3, 0x2, 0x2, 0x2, 0xc6, 0x707, 0x3, 0x2, 0x2, 0x2, 0xc8, 
       0x714, 0x3, 0x2, 0x2, 0x2, 0xca, 0x719, 0x3, 0x2, 0x2, 0x2, 0xcc, 
       0x71d, 0x3, 0x2, 0x2, 0x2, 0xce, 0x728, 0x3, 0x2, 0x2, 0x2, 0xd0, 
       0x731, 0x3, 0x2, 0x2, 0x2, 0xd2, 0x73f, 0x3, 0x2, 0x2, 0x2, 0xd4, 
       0x746, 0x3, 0x2, 0x2, 0x2, 0xd6, 0x752, 0x3, 0x2, 0x2, 0x2, 0xd8, 
       0x755, 0x3, 0x2, 0x2, 0x2, 0xda, 0x763, 0x3, 0x2, 0x2, 0x2, 0xdc, 
       0x769, 0x3, 0x2, 0x2, 0x2, 0xde, 0x77c, 0x3, 0x2, 0x2, 0x2, 0xe0, 
       0x791, 0x3, 0x2, 0x2, 0x2, 0xe2, 0x795, 0x3, 0x2, 0x2, 0x2, 0xe4, 
       0x79f, 0x3, 0x2, 0x2, 0x2, 0xe6, 0x7a1, 0x3, 0x2, 0x2, 0x2, 0xe8, 
       0x7a3, 0x3, 0x2, 0x2, 0x2, 0xea, 0x7a7, 0x3, 0x2, 0x2, 0x2, 0xec, 
       0x7ba, 0x3, 0x2, 0x2, 0x2, 0xee, 0x7be, 0x3, 0x2, 0x2, 0x2, 0xf0, 
       0x7c0, 0x3, 0x2, 0x2, 0x2, 0xf2, 0x7dd, 0x3, 0x2, 0x2, 0x2, 0xf4, 
       0x7e0, 0x3, 0x2, 0x2, 0x2, 0xf6, 0x7e6, 0x3, 0x2, 0x2, 0x2, 0xf8, 
       0x7e8, 0x3, 0x2, 0x2, 0x2, 0xfa, 0x7f6, 0x3, 0x2, 0x2, 0x2, 0xfc, 
       0x7fa, 0x3, 0x2, 0x2, 0x2, 0xfe, 0x801, 0x3, 0x2, 0x2, 0x2, 0x100, 
       0x808, 0x3, 0x2, 0x2, 0x2, 0x102, 0x80f, 0x3, 0x2, 0x2, 0x2, 0x104, 
       0x812, 0x3, 0x2, 0x2, 0x2, 0x106, 0x81e, 0x3, 0x2, 0x2, 0x2, 0x108, 
       0x821, 0x3, 0x2, 0x2, 0x2, 0x10a, 0x827, 0x3, 0x2, 0x2, 0x2, 0x10c, 
       0x82a, 0x3, 0x2, 0x2, 0x2, 0x10e, 0x848, 0x3, 0x2, 0x2, 0x2, 0x110, 
       0x850, 0x3, 0x2, 0x2, 0x2, 0x112, 0x85f, 0x3, 0x2, 0x2, 0x2, 0x114, 
       0x877, 0x3, 0x2, 0x2, 0x2, 0x116, 0x879, 0x3, 0x2, 0x2, 0x2, 0x118, 
       0x883, 0x3, 0x2, 0x2, 0x2, 0x11a, 0x887, 0x3, 0x2, 0x2, 0x2, 0x11c, 
       0x890, 0x3, 0x2, 0x2, 0x2, 0x11e, 0x899, 0x3, 0x2, 0x2, 0x2, 0x120, 
       0x8a4, 0x3, 0x2, 0x2, 0x2, 0x122, 0x8b2, 0x3, 0x2, 0x2, 0x2, 0x124, 
       0x8c0, 0x3, 0x2, 0x2, 0x2, 0x126, 0x8c2, 0x3, 0x2, 0x2, 0x2, 0x128, 
       0x8db, 0x3, 0x2, 0x2, 0x2, 0x12a, 0x8e8, 0x3, 0x2, 0x2, 0x2, 0x12c, 
       0x8ea, 0x3, 0x2, 0x2, 0x2, 0x12e, 0x8f7, 0x3, 0x2, 0x2, 0x2, 0x130, 
       0x902, 0x3, 0x2, 0x2, 0x2, 0x132, 0x906, 0x3, 0x2, 0x2, 0x2, 0x134, 
       0x90a, 0x3, 0x2, 0x2, 0x2, 0x136, 0x913, 0x3, 0x2, 0x2, 0x2, 0x138, 
       0x91e, 0x3, 0x2, 0x2, 0x2, 0x13a, 0x920, 0x3, 0x2, 0x2, 0x2, 0x13c, 
       0x924, 0x3, 0x2, 0x2, 0x2, 0x13e, 0x931, 0x3, 0x2, 0x2, 0x2, 0x140, 
       0x93c, 0x3, 0x2, 0x2, 0x2, 0x142, 0x93e, 0x3, 0x2, 0x2, 0x2, 0x144, 
       0x959, 0x3, 0x2, 0x2, 0x2, 0x146, 0x95b, 0x3, 0x2, 0x2, 0x2, 0x148, 
       0x96c, 0x3, 0x2, 0x2, 0x2, 0x14a, 0x96e, 0x3, 0x2, 0x2, 0x2, 0x14c, 
       0x971, 0x3, 0x2, 0x2, 0x2, 0x14e, 0x97b, 0x3, 0x2, 0x2, 0x2, 0x150, 
       0x97e, 0x3, 0x2, 0x2, 0x2, 0x152, 0x981, 0x3, 0x2, 0x2, 0x2, 0x154, 
       0x992, 0x3, 0x2, 0x2, 0x2, 0x156, 0x9a1, 0x3, 0x2, 0x2, 0x2, 0x158, 
       0x9a3, 0x3, 0x2, 0x2, 0x2, 0x15a, 0x9ad, 0x3, 0x2, 0x2, 0x2, 0x15c, 
       0x9bd, 0x3, 0x2, 0x2, 0x2, 0x15e, 0x9c5, 0x3, 0x2, 0x2, 0x2, 0x160, 
       0x9c8, 0x3, 0x2, 0x2, 0x2, 0x162, 0x9d9, 0x3, 0x2, 0x2, 0x2, 0x164, 
       0x9ee, 0x3, 0x2, 0x2, 0x2, 0x166, 0xa04, 0x3, 0x2, 0x2, 0x2, 0x168, 
       0xa06, 0x3, 0x2, 0x2, 0x2, 0x16a, 0xa12, 0x3, 0x2, 0x2, 0x2, 0x16c, 
       0xa18, 0x3, 0x2, 0x2, 0x2, 0x16e, 0xa27, 0x3, 0x2, 0x2, 0x2, 0x170, 
       0xa35, 0x3, 0x2, 0x2, 0x2, 0x172, 0xa4e, 0x3, 0x2, 0x2, 0x2, 0x174, 
       0xa50, 0x3, 0x2, 0x2, 0x2, 0x176, 0xa63, 0x3, 0x2, 0x2, 0x2, 0x178, 
       0xa75, 0x3, 0x2, 0x2, 0x2, 0x17a, 0xa79, 0x3, 0x2, 0x2, 0x2, 0x17c, 
       0xa87, 0x3, 0x2, 0x2, 0x2, 0x17e, 0xa9a, 0x3, 0x2, 0x2, 0x2, 0x180, 
       0xab7, 0x3, 0x2, 0x2, 0x2, 0x182, 0xab9, 0x3, 0x2, 0x2, 0x2, 0x184, 
       0xabd, 0x3, 0x2, 0x2, 0x2, 0x186, 0xabf, 0x3, 0x2, 0x2, 0x2, 0x188, 
       0xad2, 0x3, 0x2, 0x2, 0x2, 0x18a, 0xad6, 0x3, 0x2, 0x2, 0x2, 0x18c, 
       0xad8, 0x3, 0x2, 0x2, 0x2, 0x18e, 0xae9, 0x3, 0x2, 0x2, 0x2, 0x190, 
       0xaf9, 0x3, 0x2, 0x2, 0x2, 0x192, 0xb95, 0x3, 0x2, 0x2, 0x2, 0x194, 
       0xb97, 0x3, 0x2, 0x2, 0x2, 0x196, 0xb99, 0x3, 0x2, 0x2, 0x2, 0x198, 
       0xba3, 0x3, 0x2, 0x2, 0x2, 0x19a, 0xc75, 0x3, 0x2, 0x2, 0x2, 0x19c, 
       0xc77, 0x3, 0x2, 0x2, 0x2, 0x19e, 0xc7e, 0x3, 0x2, 0x2, 0x2, 0x1a0, 
       0xc86, 0x3, 0x2, 0x2, 0x2, 0x1a2, 0xc92, 0x3, 0x2, 0x2, 0x2, 0x1a4, 
       0xc96, 0x3, 0x2, 0x2, 0x2, 0x1a6, 0xc98, 0x3, 0x2, 0x2, 0x2, 0x1a8, 
       0xcab, 0x3, 0x2, 0x2, 0x2, 0x1aa, 0xcb2, 0x3, 0x2, 0x2, 0x2, 0x1ac, 
       0xcb7, 0x3, 0x2, 0x2, 0x2, 0x1ae, 0xcba, 0x3, 0x2, 0x2, 0x2, 0x1b0, 
       0xccb, 0x3, 0x2, 0x2, 0x2, 0x1b2, 0xccd, 0x3, 0x2, 0x2, 0x2, 0x1b4, 
       0xcd0, 0x3, 0x2, 0x2, 0x2, 0x1b6, 0xcd5, 0x3, 0x2, 0x2, 0x2, 0x1b8, 
       0xce3, 0x3, 0x2, 0x2, 0x2, 0x1ba, 0xce6, 0x3, 0x2, 0x2, 0x2, 0x1bc, 
       0xceb, 0x3, 0x2, 0x2, 0x2, 0x1be, 0xcef, 0x3, 0x2, 0x2, 0x2, 0x1c0, 
       0xcf1, 0x3, 0x2, 0x2, 0x2, 0x1c2, 0xcf3, 0x3, 0x2, 0x2, 0x2, 0x1c4, 
       0x1c5, 0x5, 0x4, 0x3, 0x2, 0x1c5, 0x3, 0x3, 0x2, 0x2, 0x2, 0x1c6, 
       0x1c9, 0x5, 0x6, 0x4, 0x2, 0x1c7, 0x1c9, 0x5, 0xe, 0x8, 0x2, 0x1c8, 
       0x1c6, 0x3, 0x2, 0x2, 0x2, 0x1c8, 0x1c7, 0x3, 0x2, 0x2, 0x2, 0x1c9, 
       0x1cb, 0x3, 0x2, 0x2, 0x2, 0x1ca, 0x1cc, 0x7, 0x7e, 0x2, 0x2, 0x1cb, 
       0x1ca, 0x3, 0x2, 0x2, 0x2, 0x1cb, 0x1cc, 0x3, 0x2, 0x2, 0x2, 0x1cc, 
       0x1ce, 0x3, 0x2, 0x2, 0x2, 0x1cd, 0x1c8, 0x3, 0x2, 0x2, 0x2, 0x1ce, 
       0x1cf, 0x3, 0x2, 0x2, 0x2, 0x1cf, 0x1cd, 0x3, 0x2, 0x2, 0x2, 0x1cf, 
       0x1d0, 0x3, 0x2, 0x2, 0x2, 0x1d0, 0x5, 0x3, 0x2, 0x2, 0x2, 0x1d1, 
       0x1d3, 0x5, 0x30, 0x19, 0x2, 0x1d2, 0x1d1, 0x3, 0x2, 0x2, 0x2, 0x1d2, 
       0x1d3, 0x3, 0x2, 0x2, 0x2, 0x1d3, 0x1d4, 0x3, 0x2, 0x2, 0x2, 0x1d4, 
       0x1d5, 0x7, 0x17, 0x2, 0x2, 0x1d5, 0x1d7, 0x5, 0x4, 0x3, 0x2, 0x1d6, 
       0x1d8, 0x5, 0x12, 0xa, 0x2, 0x1d7, 0x1d6, 0x3, 0x2, 0x2, 0x2, 0x1d7, 
       0x1d8, 0x3, 0x2, 0x2, 0x2, 0x1d8, 0x1d9, 0x3, 0x2, 0x2, 0x2, 0x1d9, 
       0x1da, 0x5, 0xa, 0x6, 0x2, 0x1da, 0x7, 0x3, 0x2, 0x2, 0x2, 0x1db, 
       0x1dc, 0x7, 0x17, 0x2, 0x2, 0x1dc, 0x1de, 0x5, 0x4, 0x3, 0x2, 0x1dd, 
       0x1df, 0x5, 0x12, 0xa, 0x2, 0x1de, 0x1dd, 0x3, 0x2, 0x2, 0x2, 0x1de, 
       0x1df, 0x3, 0x2, 0x2, 0x2, 0x1df, 0x1e0, 0x3, 0x2, 0x2, 0x2, 0x1e0, 
       0x1e1, 0x5, 0xa, 0x6, 0x2, 0x1e1, 0x1e7, 0x3, 0x2, 0x2, 0x2, 0x1e2, 
       0x1e4, 0x5, 0xe, 0x8, 0x2, 0x1e3, 0x1e5, 0x7, 0x16e, 0x2, 0x2, 0x1e4, 
       0x1e3, 0x3, 0x2, 0x2, 0x2, 0x1e4, 0x1e5, 0x3, 0x2, 0x2, 0x2, 0x1e5, 
       0x1e7, 0x3, 0x2, 0x2, 0x2, 0x1e6, 0x1db, 0x3, 0x2, 0x2, 0x2, 0x1e6, 
       0x1e2, 0x3, 0x2, 0x2, 0x2, 0x1e7, 0x9, 0x3, 0x2, 0x2, 0x2, 0x1e8, 
       0x1e9, 0x6, 0x6, 0x2, 0x2, 0x1e9, 0x1ea, 0x7, 0x64, 0x2, 0x2, 0x1ea, 
       0xb, 0x3, 0x2, 0x2, 0x2, 0x1eb, 0x1f5, 0x5, 0x6, 0x4, 0x2, 0x1ec, 
       0x1ee, 0x5, 0xe, 0x8, 0x2, 0x1ed, 0x1ec, 0x3, 0x2, 0x2, 0x2, 0x1ee, 
       0x1ef, 0x3, 0x2, 0x2, 0x2, 0x1ef, 0x1ed, 0x3, 0x2, 0x2, 0x2, 0x1ef, 
       0x1f0, 0x3, 0x2, 0x2, 0x2, 0x1f0, 0x1f2, 0x3, 0x2, 0x2, 0x2, 0x1f1, 
       0x1f3, 0x7, 0x7e, 0x2, 0x2, 0x1f2, 0x1f1, 0x3, 0x2, 0x2, 0x2, 0x1f2, 
       0x1f3, 0x3, 0x2, 0x2, 0x2, 0x1f3, 0x1f5, 0x3, 0x2, 0x2, 0x2, 0x1f4, 
       0x1eb, 0x3, 0x2, 0x2, 0x2, 0x1f4, 0x1ed, 0x3, 0x2, 0x2, 0x2, 0x1f5, 
       0xd, 0x3, 0x2, 0x2, 0x2, 0x1f6, 0x233, 0x5, 0x1a, 0xe, 0x2, 0x1f7, 
       0x233, 0x5, 0x24, 0x13, 0x2, 0x1f8, 0x233, 0x5, 0x70, 0x39, 0x2, 
       0x1f9, 0x233, 0x5, 0x26, 0x14, 0x2, 0x1fa, 0x233, 0x5, 0x28, 0x15, 
       0x2, 0x1fb, 0x233, 0x5, 0x2a, 0x16, 0x2, 0x1fc, 0x233, 0x5, 0x2c, 
       0x17, 0x2, 0x1fd, 0x233, 0x5, 0xd2, 0x6a, 0x2, 0x1fe, 0x233, 0x5, 
       0xd6, 0x6c, 0x2, 0x1ff, 0x233, 0x5, 0xd8, 0x6d, 0x2, 0x200, 0x233, 
       0x5, 0xdc, 0x6f, 0x2, 0x201, 0x233, 0x5, 0xde, 0x70, 0x2, 0x202, 
       0x233, 0x5, 0xe8, 0x75, 0x2, 0x203, 0x233, 0x5, 0x80, 0x41, 0x2, 
       0x204, 0x233, 0x5, 0x84, 0x43, 0x2, 0x205, 0x233, 0x5, 0xea, 0x76, 
       0x2, 0x206, 0x233, 0x5, 0x46, 0x24, 0x2, 0x207, 0x233, 0x5, 0x88, 
       0x45, 0x2, 0x208, 0x233, 0x5, 0x8e, 0x48, 0x2, 0x209, 0x233, 0x5, 
       0x94, 0x4b, 0x2, 0x20a, 0x233, 0x5, 0x44, 0x23, 0x2, 0x20b, 0x233, 
       0x5, 0x2e, 0x18, 0x2, 0x20c, 0x233, 0x5, 0x168, 0xb5, 0x2, 0x20d, 
       0x233, 0x5, 0x16c, 0xb7, 0x2, 0x20e, 0x233, 0x5, 0x9e, 0x50, 0x2, 
       0x20f, 0x233, 0x5, 0xa0, 0x51, 0x2, 0x210, 0x233, 0x5, 0xa2, 0x52, 
       0x2, 0x211, 0x233, 0x5, 0xbc, 0x5f, 0x2, 0x212, 0x233, 0x5, 0xd0, 
       0x69, 0x2, 0x213, 0x233, 0x5, 0x110, 0x89, 0x2, 0x214, 0x233, 0x5, 
       0x112, 0x8a, 0x2, 0x215, 0x233, 0x5, 0xa4, 0x53, 0x2, 0x216, 0x233, 
       0x5, 0xb0, 0x59, 0x2, 0x217, 0x233, 0x5, 0xb2, 0x5a, 0x2, 0x218, 
       0x233, 0x5, 0xba, 0x5e, 0x2, 0x219, 0x233, 0x5, 0xbe, 0x60, 0x2, 
       0x21a, 0x233, 0x5, 0xc6, 0x64, 0x2, 0x21b, 0x233, 0x5, 0xca, 0x66, 
       0x2, 0x21c, 0x233, 0x5, 0xcc, 0x67, 0x2, 0x21d, 0x233, 0x5, 0x160, 
       0xb1, 0x2, 0x21e, 0x233, 0x5, 0xce, 0x68, 0x2, 0x21f, 0x233, 0x5, 
       0xf2, 0x7a, 0x2, 0x220, 0x233, 0x5, 0xf4, 0x7b, 0x2, 0x221, 0x233, 
       0x5, 0xf6, 0x7c, 0x2, 0x222, 0x233, 0x5, 0xf8, 0x7d, 0x2, 0x223, 
       0x233, 0x5, 0xfa, 0x7e, 0x2, 0x224, 0x233, 0x5, 0xfc, 0x7f, 0x2, 
       0x225, 0x233, 0x5, 0x118, 0x8d, 0x2, 0x226, 0x233, 0x5, 0x106, 0x84, 
       0x2, 0x227, 0x233, 0x5, 0x158, 0xad, 0x2, 0x228, 0x233, 0x5, 0x10a, 
       0x86, 0x2, 0x229, 0x233, 0x5, 0x108, 0x85, 0x2, 0x22a, 0x233, 0x5, 
       0x10c, 0x87, 0x2, 0x22b, 0x233, 0x5, 0x10e, 0x88, 0x2, 0x22c, 0x233, 
       0x5, 0x114, 0x8b, 0x2, 0x22d, 0x233, 0x5, 0x1a6, 0xd4, 0x2, 0x22e, 
       0x233, 0x5, 0x1aa, 0xd6, 0x2, 0x22f, 0x233, 0x5, 0x16, 0xc, 0x2, 
       0x230, 0x233, 0x5, 0x18, 0xd, 0x2, 0x231, 0x233, 0x5, 0x10, 0x9, 
       0x2, 0x232, 0x1f6, 0x3, 0x2, 0x2, 0x2, 0x232, 0x1f7, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x1f8, 0x3, 0x2, 0x2, 0x2, 0x232, 0x1f9, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x1fa, 0x3, 0x2, 0x2, 0x2, 0x232, 0x1fb, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x1fc, 0x3, 0x2, 0x2, 0x2, 0x232, 0x1fd, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x1fe, 0x3, 0x2, 0x2, 0x2, 0x232, 0x1ff, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x200, 0x3, 0x2, 0x2, 0x2, 0x232, 0x201, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x202, 0x3, 0x2, 0x2, 0x2, 0x232, 0x203, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x204, 0x3, 0x2, 0x2, 0x2, 0x232, 0x205, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x206, 0x3, 0x2, 0x2, 0x2, 0x232, 0x207, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x208, 0x3, 0x2, 0x2, 0x2, 0x232, 0x209, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x20a, 0x3, 0x2, 0x2, 0x2, 0x232, 0x20b, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x20c, 0x3, 0x2, 0x2, 0x2, 0x232, 0x20d, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x20e, 0x3, 0x2, 0x2, 0x2, 0x232, 0x20f, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x210, 0x3, 0x2, 0x2, 0x2, 0x232, 0x211, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x212, 0x3, 0x2, 0x2, 0x2, 0x232, 0x213, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x214, 0x3, 0x2, 0x2, 0x2, 0x232, 0x215, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x216, 0x3, 0x2, 0x2, 0x2, 0x232, 0x217, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x218, 0x3, 0x2, 0x2, 0x2, 0x232, 0x219, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x21a, 0x3, 0x2, 0x2, 0x2, 0x232, 0x21b, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x21c, 0x3, 0x2, 0x2, 0x2, 0x232, 0x21d, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x21e, 0x3, 0x2, 0x2, 0x2, 0x232, 0x21f, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x220, 0x3, 0x2, 0x2, 0x2, 0x232, 0x221, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x222, 0x3, 0x2, 0x2, 0x2, 0x232, 0x223, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x224, 0x3, 0x2, 0x2, 0x2, 0x232, 0x225, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x226, 0x3, 0x2, 0x2, 0x2, 0x232, 0x227, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x228, 0x3, 0x2, 0x2, 0x2, 0x232, 0x229, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x22a, 0x3, 0x2, 0x2, 0x2, 0x232, 0x22b, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x22c, 0x3, 0x2, 0x2, 0x2, 0x232, 0x22d, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x22e, 0x3, 0x2, 0x2, 0x2, 0x232, 0x22f, 0x3, 0x2, 0x2, 
       0x2, 0x232, 0x230, 0x3, 0x2, 0x2, 0x2, 0x232, 0x231, 0x3, 0x2, 0x2, 
       0x2, 0x233, 0xf, 0x3, 0x2, 0x2, 0x2, 0x234, 0x235, 0x9, 0x2, 0x2, 
       0x2, 0x235, 0x11, 0x3, 0x2, 0x2, 0x2, 0x236, 0x238, 0x7, 0x6a, 0x2, 
       0x2, 0x237, 0x239, 0x5, 0x14, 0xb, 0x2, 0x238, 0x237, 0x3, 0x2, 0x2, 
       0x2, 0x239, 0x23a, 0x3, 0x2, 0x2, 0x2, 0x23a, 0x238, 0x3, 0x2, 0x2, 
       0x2, 0x23a, 0x23b, 0x3, 0x2, 0x2, 0x2, 0x23b, 0x13, 0x3, 0x2, 0x2, 
       0x2, 0x23c, 0x23d, 0x7, 0x138, 0x2, 0x2, 0x23d, 0x23e, 0x7, 0x170, 
       0x2, 0x2, 0x23e, 0x23f, 0x7, 0x121, 0x2, 0x2, 0x23f, 0x240, 0x5, 
       0x4, 0x3, 0x2, 0x240, 0x241, 0xa, 0x3, 0x2, 0x2, 0x241, 0x15, 0x3, 
       0x2, 0x2, 0x2, 0x242, 0x243, 0x7, 0xc5, 0x2, 0x2, 0x243, 0x17, 0x3, 
       0x2, 0x2, 0x2, 0x244, 0x245, 0x6, 0xd, 0x3, 0x2, 0x245, 0x246, 0x5, 
       0x17e, 0xc0, 0x2, 0x246, 0x19, 0x3, 0x2, 0x2, 0x2, 0x247, 0x248, 
       0x7, 0x102, 0x2, 0x2, 0x248, 0x255, 0x5, 0xfe, 0x80, 0x2, 0x249, 
       0x24b, 0x7, 0x102, 0x2, 0x2, 0x24a, 0x249, 0x3, 0x2, 0x2, 0x2, 0x24a, 
       0x24b, 0x3, 0x2, 0x2, 0x2, 0x24b, 0x24c, 0x3, 0x2, 0x2, 0x2, 0x24c, 
       0x251, 0x5, 0x1c, 0xf, 0x2, 0x24d, 0x24e, 0x7, 0x15b, 0x2, 0x2, 0x24e, 
       0x250, 0x5, 0x1c, 0xf, 0x2, 0x24f, 0x24d, 0x3, 0x2, 0x2, 0x2, 0x250, 
       0x253, 0x3, 0x2, 0x2, 0x2, 0x251, 0x24f, 0x3, 0x2, 0x2, 0x2, 0x251, 
       0x252, 0x3, 0x2, 0x2, 0x2, 0x252, 0x255, 0x3, 0x2, 0x2, 0x2, 0x253, 
       0x251, 0x3, 0x2, 0x2, 0x2, 0x254, 0x247, 0x3, 0x2, 0x2, 0x2, 0x254, 
       0x24a, 0x3, 0x2, 0x2, 0x2, 0x255, 0x1b, 0x3, 0x2, 0x2, 0x2, 0x256, 
       0x25a, 0x5, 0x1e, 0x10, 0x2, 0x257, 0x25a, 0x5, 0x20, 0x11, 0x2, 
       0x258, 0x25a, 0x5, 0x22, 0x12, 0x2, 0x259, 0x256, 0x3, 0x2, 0x2, 
       0x2, 0x259, 0x257, 0x3, 0x2, 0x2, 0x2, 0x259, 0x258, 0x3, 0x2, 0x2, 
       0x2, 0x25a, 0x1d, 0x3, 0x2, 0x2, 0x2, 0x25b, 0x25d, 0x5, 0x1b6, 0xdc, 
       0x2, 0x25c, 0x25e, 0x7, 0x15a, 0x2, 0x2, 0x25d, 0x25c, 0x3, 0x2, 
       0x2, 0x2, 0x25d, 0x25e, 0x3, 0x2, 0x2, 0x2, 0x25e, 0x25f, 0x3, 0x2, 
       0x2, 0x2, 0x25f, 0x260, 0x7, 0x15f, 0x2, 0x2, 0x260, 0x261, 0x5, 
       0x17e, 0xc0, 0x2, 0x261, 0x26c, 0x3, 0x2, 0x2, 0x2, 0x262, 0x263, 
       0x7, 0x169, 0x2, 0x2, 0x263, 0x264, 0x5, 0x1b6, 0xdc, 0x2, 0x264, 
       0x266, 0x7, 0x16c, 0x2, 0x2, 0x265, 0x267, 0x7, 0x15a, 0x2, 0x2, 
       0x266, 0x265, 0x3, 0x2, 0x2, 0x2, 0x266, 0x267, 0x3, 0x2, 0x2, 0x2, 
       0x267, 0x268, 0x3, 0x2, 0x2, 0x2, 0x268, 0x269, 0x7, 0x15f, 0x2, 
       0x2, 0x269, 0x26a, 0x5, 0x17e, 0xc0, 0x2, 0x26a, 0x26c, 0x3, 0x2, 
       0x2, 0x2, 0x26b, 0x25b, 0x3, 0x2, 0x2, 0x2, 0x26b, 0x262, 0x3, 0x2, 
       0x2, 0x2, 0x26c, 0x1f, 0x3, 0x2, 0x2, 0x2, 0x26d, 0x26e, 0x7, 0x169, 
       0x2, 0x2, 0x26e, 0x273, 0x5, 0x1b6, 0xdc, 0x2, 0x26f, 0x270, 0x7, 
       0x15b, 0x2, 0x2, 0x270, 0x272, 0x5, 0x1b6, 0xdc, 0x2, 0x271, 0x26f, 
       0x3, 0x2, 0x2, 0x2, 0x272, 0x275, 0x3, 0x2, 0x2, 0x2, 0x273, 0x271, 
       0x3, 0x2, 0x2, 0x2, 0x273, 0x274, 0x3, 0x2, 0x2, 0x2, 0x274, 0x276, 
       0x3, 0x2, 0x2, 0x2, 0x275, 0x273, 0x3, 0x2, 0x2, 0x2, 0x276, 0x278, 
       0x7, 0x16c, 0x2, 0x2, 0x277, 0x279, 0x7, 0x15a, 0x2, 0x2, 0x278, 
       0x277, 0x3, 0x2, 0x2, 0x2, 0x278, 0x279, 0x3, 0x2, 0x2, 0x2, 0x279, 
       0x27a, 0x3, 0x2, 0x2, 0x2, 0x27a, 0x27b, 0x7, 0x15f, 0x2, 0x2, 0x27b, 
       0x27c, 0x7, 0x169, 0x2, 0x2, 0x27c, 0x281, 0x5, 0x17e, 0xc0, 0x2, 
       0x27d, 0x27e, 0x7, 0x15b, 0x2, 0x2, 0x27e, 0x280, 0x5, 0x17e, 0xc0, 
       0x2, 0x27f, 0x27d, 0x3, 0x2, 0x2, 0x2, 0x280, 0x283, 0x3, 0x2, 0x2, 
       0x2, 0x281, 0x27f, 0x3, 0x2, 0x2, 0x2, 0x281, 0x282, 0x3, 0x2, 0x2, 
       0x2, 0x282, 0x284, 0x3, 0x2, 0x2, 0x2, 0x283, 0x281, 0x3, 0x2, 0x2, 
       0x2, 0x284, 0x285, 0x7, 0x16c, 0x2, 0x2, 0x285, 0x21, 0x3, 0x2, 0x2, 
       0x2, 0x286, 0x293, 0x5, 0x1b6, 0xdc, 0x2, 0x287, 0x288, 0x7, 0x169, 
       0x2, 0x2, 0x288, 0x28d, 0x5, 0x1b6, 0xdc, 0x2, 0x289, 0x28a, 0x7, 
       0x15b, 0x2, 0x2, 0x28a, 0x28c, 0x5, 0x1b6, 0xdc, 0x2, 0x28b, 0x289, 
       0x3, 0x2, 0x2, 0x2, 0x28c, 0x28f, 0x3, 0x2, 0x2, 0x2, 0x28d, 0x28b, 
       0x3, 0x2, 0x2, 0x2, 0x28d, 0x28e, 0x3, 0x2, 0x2, 0x2, 0x28e, 0x290, 
       0x3, 0x2, 0x2, 0x2, 0x28f, 0x28d, 0x3, 0x2, 0x2, 0x2, 0x290, 0x291, 
       0x7, 0x16c, 0x2, 0x2, 0x291, 0x293, 0x3, 0x2, 0x2, 0x2, 0x292, 0x286, 
       0x3, 0x2, 0x2, 0x2, 0x292, 0x287, 0x3, 0x2, 0x2, 0x2, 0x293, 0x295, 
       0x3, 0x2, 0x2, 0x2, 0x294, 0x296, 0x7, 0x15a, 0x2, 0x2, 0x295, 0x294, 
       0x3, 0x2, 0x2, 0x2, 0x295, 0x296, 0x3, 0x2, 0x2, 0x2, 0x296, 0x297, 
       0x3, 0x2, 0x2, 0x2, 0x297, 0x298, 0x7, 0x15f, 0x2, 0x2, 0x298, 0x299, 
       0x7, 0x169, 0x2, 0x2, 0x299, 0x29a, 0x5, 0x118, 0x8d, 0x2, 0x29a, 
       0x29b, 0x7, 0x16c, 0x2, 0x2, 0x29b, 0x23, 0x3, 0x2, 0x2, 0x2, 0x29c, 
       0x29d, 0x7, 0xb, 0x2, 0x2, 0x29d, 0x29e, 0x5, 0x1b6, 0xdc, 0x2, 0x29e, 
       0x29f, 0x7, 0x43, 0x2, 0x2, 0x29f, 0x2a3, 0x7, 0x75, 0x2, 0x2, 0x2a0, 
       0x2a1, 0x7, 0xea, 0x2, 0x2, 0x2a1, 0x2a4, 0x7, 0x102, 0x2, 0x2, 0x2a2, 
       0x2a4, 0x7, 0xde, 0x2, 0x2, 0x2a3, 0x2a0, 0x3, 0x2, 0x2, 0x2, 0x2a3, 
       0x2a2, 0x3, 0x2, 0x2, 0x2, 0x2a4, 0x2a5, 0x3, 0x2, 0x2, 0x2, 0x2a5, 
       0x2a6, 0x5, 0x1b6, 0xdc, 0x2, 0x2a6, 0x25, 0x3, 0x2, 0x2, 0x2, 0x2a7, 
       0x2aa, 0x7, 0x12, 0x2, 0x2, 0x2a8, 0x2a9, 0x7, 0xea, 0x2, 0x2, 0x2a9, 
       0x2ab, 0x7, 0x102, 0x2, 0x2, 0x2aa, 0x2a8, 0x3, 0x2, 0x2, 0x2, 0x2aa, 
       0x2ab, 0x3, 0x2, 0x2, 0x2, 0x2ab, 0x2ac, 0x3, 0x2, 0x2, 0x2, 0x2ac, 
       0x2ad, 0x9, 0x4, 0x2, 0x2, 0x2ad, 0x2ae, 0x7, 0x169, 0x2, 0x2, 0x2ae, 
       0x2b3, 0x5, 0x1b6, 0xdc, 0x2, 0x2af, 0x2b0, 0x7, 0x15b, 0x2, 0x2, 
       0x2b0, 0x2b2, 0x5, 0x1b6, 0xdc, 0x2, 0x2b1, 0x2af, 0x3, 0x2, 0x2, 
       0x2, 0x2b2, 0x2b5, 0x3, 0x2, 0x2, 0x2, 0x2b3, 0x2b1, 0x3, 0x2, 0x2, 
       0x2, 0x2b3, 0x2b4, 0x3, 0x2, 0x2, 0x2, 0x2b4, 0x2b6, 0x3, 0x2, 0x2, 
       0x2, 0x2b5, 0x2b3, 0x3, 0x2, 0x2, 0x2, 0x2b6, 0x2b7, 0x7, 0x16c, 
       0x2, 0x2, 0x2b7, 0x2b8, 0x7, 0x13b, 0x2, 0x2, 0x2b8, 0x2b9, 0x7, 
       0xde, 0x2, 0x2, 0x2b9, 0x2ba, 0x5, 0x1b6, 0xdc, 0x2, 0x2ba, 0x27, 
       0x3, 0x2, 0x2, 0x2, 0x2bb, 0x2bc, 0x7, 0x17, 0x2, 0x2, 0x2bc, 0x2bd, 
       0x7, 0x127, 0x2, 0x2, 0x2bd, 0x29, 0x3, 0x2, 0x2, 0x2, 0x2be, 0x2bf, 
       0x7, 0x1f, 0x2, 0x2, 0x2bf, 0x2b, 0x3, 0x2, 0x2, 0x2, 0x2c0, 0x2c1, 
       0x7, 0x22, 0x2, 0x2, 0x2c1, 0x2c8, 0x5, 0x1b6, 0xdc, 0x2, 0x2c2, 
       0x2c4, 0x7, 0x169, 0x2, 0x2, 0x2c3, 0x2c5, 0x5, 0x19e, 0xd0, 0x2, 
       0x2c4, 0x2c3, 0x3, 0x2, 0x2, 0x2, 0x2c4, 0x2c5, 0x3, 0x2, 0x2, 0x2, 
       0x2c5, 0x2c6, 0x3, 0x2, 0x2, 0x2, 0x2c6, 0x2c9, 0x7, 0x16c, 0x2, 
       0x2, 0x2c7, 0x2c9, 0x5, 0x19e, 0xd0, 0x2, 0x2c8, 0x2c2, 0x3, 0x2, 
       0x2, 0x2, 0x2c8, 0x2c7, 0x3, 0x2, 0x2, 0x2, 0x2c8, 0x2c9, 0x3, 0x2, 
       0x2, 0x2, 0x2c9, 0x2d, 0x3, 0x2, 0x2, 0x2, 0x2ca, 0x2cb, 0x7, 0x4c, 
       0x2, 0x2, 0x2cb, 0x2d0, 0x5, 0x34, 0x1b, 0x2, 0x2cc, 0x2cd, 0x7, 
       0x15b, 0x2, 0x2, 0x2cd, 0x2cf, 0x5, 0x34, 0x1b, 0x2, 0x2ce, 0x2cc, 
       0x3, 0x2, 0x2, 0x2, 0x2cf, 0x2d2, 0x3, 0x2, 0x2, 0x2, 0x2d0, 0x2ce, 
       0x3, 0x2, 0x2, 0x2, 0x2d0, 0x2d1, 0x3, 0x2, 0x2, 0x2, 0x2d1, 0x2f, 
       0x3, 0x2, 0x2, 0x2, 0x2d2, 0x2d0, 0x3, 0x2, 0x2, 0x2, 0x2d3, 0x2d4, 
       0x7, 0x4c, 0x2, 0x2, 0x2d4, 0x2d5, 0x5, 0x34, 0x1b, 0x2, 0x2d5, 0x2db, 
       0x7, 0x16e, 0x2, 0x2, 0x2d6, 0x2d7, 0x5, 0x34, 0x1b, 0x2, 0x2d7, 
       0x2d8, 0x7, 0x16e, 0x2, 0x2, 0x2d8, 0x2da, 0x3, 0x2, 0x2, 0x2, 0x2d9, 
       0x2d6, 0x3, 0x2, 0x2, 0x2, 0x2da, 0x2dd, 0x3, 0x2, 0x2, 0x2, 0x2db, 
       0x2d9, 0x3, 0x2, 0x2, 0x2, 0x2db, 0x2dc, 0x3, 0x2, 0x2, 0x2, 0x2dc, 
       0x31, 0x3, 0x2, 0x2, 0x2, 0x2dd, 0x2db, 0x3, 0x2, 0x2, 0x2, 0x2de, 
       0x2df, 0x5, 0x34, 0x1b, 0x2, 0x2df, 0x2e5, 0x7, 0x16e, 0x2, 0x2, 
       0x2e0, 0x2e1, 0x5, 0x34, 0x1b, 0x2, 0x2e1, 0x2e2, 0x7, 0x16e, 0x2, 
       0x2, 0x2e2, 0x2e4, 0x3, 0x2, 0x2, 0x2, 0x2e3, 0x2e0, 0x3, 0x2, 0x2, 
       0x2, 0x2e4, 0x2e7, 0x3, 0x2, 0x2, 0x2, 0x2e5, 0x2e3, 0x3, 0x2, 0x2, 
       0x2, 0x2e5, 0x2e6, 0x3, 0x2, 0x2, 0x2, 0x2e6, 0x33, 0x3, 0x2, 0x2, 
       0x2, 0x2e7, 0x2e5, 0x3, 0x2, 0x2, 0x2, 0x2e8, 0x2ee, 0x5, 0x3a, 0x1e, 
       0x2, 0x2e9, 0x2ee, 0x5, 0x38, 0x1d, 0x2, 0x2ea, 0x2ee, 0x5, 0x40, 
       0x21, 0x2, 0x2eb, 0x2ee, 0x5, 0x36, 0x1c, 0x2, 0x2ec, 0x2ee, 0x5, 
       0x42, 0x22, 0x2, 0x2ed, 0x2e8, 0x3, 0x2, 0x2, 0x2, 0x2ed, 0x2e9, 
       0x3, 0x2, 0x2, 0x2, 0x2ed, 0x2ea, 0x3, 0x2, 0x2, 0x2, 0x2ed, 0x2eb, 
       0x3, 0x2, 0x2, 0x2, 0x2ed, 0x2ec, 0x3, 0x2, 0x2, 0x2, 0x2ee, 0x35, 
       0x3, 0x2, 0x2, 0x2, 0x2ef, 0x2f4, 0x5, 0x1b6, 0xdc, 0x2, 0x2f0, 0x2f1, 
       0x7, 0x15b, 0x2, 0x2, 0x2f1, 0x2f3, 0x5, 0x1b6, 0xdc, 0x2, 0x2f2, 
       0x2f0, 0x3, 0x2, 0x2, 0x2, 0x2f3, 0x2f6, 0x3, 0x2, 0x2, 0x2, 0x2f4, 
       0x2f2, 0x3, 0x2, 0x2, 0x2, 0x2f4, 0x2f5, 0x3, 0x2, 0x2, 0x2, 0x2f5, 
       0x2f8, 0x3, 0x2, 0x2, 0x2, 0x2f6, 0x2f4, 0x3, 0x2, 0x2, 0x2, 0x2f7, 
       0x2f9, 0x7, 0x10, 0x2, 0x2, 0x2f8, 0x2f7, 0x3, 0x2, 0x2, 0x2, 0x2f8, 
       0x2f9, 0x3, 0x2, 0x2, 0x2, 0x2f9, 0x2fa, 0x3, 0x2, 0x2, 0x2, 0x2fa, 
       0x2fc, 0x5, 0x78, 0x3d, 0x2, 0x2fb, 0x2fd, 0x5, 0x7a, 0x3e, 0x2, 
       0x2fc, 0x2fb, 0x3, 0x2, 0x2, 0x2, 0x2fc, 0x2fd, 0x3, 0x2, 0x2, 0x2, 
       0x2fd, 0x301, 0x3, 0x2, 0x2, 0x2, 0x2fe, 0x300, 0x5, 0x7c, 0x3f, 
       0x2, 0x2ff, 0x2fe, 0x3, 0x2, 0x2, 0x2, 0x300, 0x303, 0x3, 0x2, 0x2, 
       0x2, 0x301, 0x2ff, 0x3, 0x2, 0x2, 0x2, 0x301, 0x302, 0x3, 0x2, 0x2, 
       0x2, 0x302, 0x305, 0x3, 0x2, 0x2, 0x2, 0x303, 0x301, 0x3, 0x2, 0x2, 
       0x2, 0x304, 0x306, 0x5, 0x7e, 0x40, 0x2, 0x305, 0x304, 0x3, 0x2, 
       0x2, 0x2, 0x305, 0x306, 0x3, 0x2, 0x2, 0x2, 0x306, 0x313, 0x3, 0x2, 
       0x2, 0x2, 0x307, 0x308, 0x5, 0x1b6, 0xdc, 0x2, 0x308, 0x30a, 0x7, 
       0x33, 0x2, 0x2, 0x309, 0x30b, 0x7, 0x10, 0x2, 0x2, 0x30a, 0x309, 
       0x3, 0x2, 0x2, 0x2, 0x30a, 0x30b, 0x3, 0x2, 0x2, 0x2, 0x30b, 0x30c, 
       0x3, 0x2, 0x2, 0x2, 0x30c, 0x30e, 0x5, 0x78, 0x3d, 0x2, 0x30d, 0x30f, 
       0x5, 0x7a, 0x3e, 0x2, 0x30e, 0x30d, 0x3, 0x2, 0x2, 0x2, 0x30e, 0x30f, 
       0x3, 0x2, 0x2, 0x2, 0x30f, 0x310, 0x3, 0x2, 0x2, 0x2, 0x310, 0x311, 
       0x5, 0x7e, 0x40, 0x2, 0x311, 0x313, 0x3, 0x2, 0x2, 0x2, 0x312, 0x2ef, 
       0x3, 0x2, 0x2, 0x2, 0x312, 0x307, 0x3, 0x2, 0x2, 0x2, 0x313, 0x37, 
       0x3, 0x2, 0x2, 0x2, 0x314, 0x315, 0x5, 0x1b6, 0xdc, 0x2, 0x315, 0x316, 
       0x7, 0x37, 0x2, 0x2, 0x316, 0x39, 0x3, 0x2, 0x2, 0x2, 0x317, 0x318, 
       0x7, 0x43, 0x2, 0x2, 0x318, 0x31d, 0x5, 0x1b6, 0xdc, 0x2, 0x319, 
       0x31a, 0x5, 0x1b6, 0xdc, 0x2, 0x31a, 0x31b, 0x7, 0x43, 0x2, 0x2, 
       0x31b, 0x31d, 0x3, 0x2, 0x2, 0x2, 0x31c, 0x317, 0x3, 0x2, 0x2, 0x2, 
       0x31c, 0x319, 0x3, 0x2, 0x2, 0x2, 0x31d, 0x320, 0x3, 0x2, 0x2, 0x2, 
       0x31e, 0x321, 0x5, 0x3c, 0x1f, 0x2, 0x31f, 0x321, 0x5, 0x3e, 0x20, 
       0x2, 0x320, 0x31e, 0x3, 0x2, 0x2, 0x2, 0x320, 0x31f, 0x3, 0x2, 0x2, 
       0x2, 0x320, 0x321, 0x3, 0x2, 0x2, 0x2, 0x321, 0x322, 0x3, 0x2, 0x2, 
       0x2, 0x322, 0x325, 0x9, 0x5, 0x2, 0x2, 0x323, 0x326, 0x5, 0x118, 
       0x8d, 0x2, 0x324, 0x326, 0x5, 0x17e, 0xc0, 0x2, 0x325, 0x323, 0x3, 
       0x2, 0x2, 0x2, 0x325, 0x324, 0x3, 0x2, 0x2, 0x2, 0x326, 0x3b, 0x3, 
       0x2, 0x2, 0x2, 0x327, 0x328, 0x7, 0x13b, 0x2, 0x2, 0x328, 0x32a, 
       0x7, 0xec, 0x2, 0x2, 0x329, 0x32b, 0x7, 0xcb, 0x2, 0x2, 0x32a, 0x329, 
       0x3, 0x2, 0x2, 0x2, 0x32a, 0x32b, 0x3, 0x2, 0x2, 0x2, 0x32b, 0x32e, 
       0x3, 0x2, 0x2, 0x2, 0x32c, 0x32d, 0x7, 0x125, 0x2, 0x2, 0x32d, 0x32f, 
       0x9, 0x6, 0x2, 0x2, 0x32e, 0x32c, 0x3, 0x2, 0x2, 0x2, 0x32e, 0x32f, 
       0x3, 0x2, 0x2, 0x2, 0x32f, 0x3d, 0x3, 0x2, 0x2, 0x2, 0x330, 0x331, 
       0x7, 0x13c, 0x2, 0x2, 0x331, 0x332, 0x7, 0xec, 0x2, 0x2, 0x332, 0x3f, 
       0x3, 0x2, 0x2, 0x2, 0x333, 0x334, 0x9, 0x7, 0x2, 0x2, 0x334, 0x335, 
       0x7, 0x81, 0x2, 0x2, 0x335, 0x33b, 0x7, 0x75, 0x2, 0x2, 0x336, 0x33c, 
       0x7, 0x10e, 0x2, 0x2, 0x337, 0x33c, 0x7, 0x111, 0x2, 0x2, 0x338, 
       0x339, 0x7, 0xc3, 0x2, 0x2, 0x339, 0x33c, 0x7, 0x78, 0x2, 0x2, 0x33a, 
       0x33c, 0x5, 0x1b6, 0xdc, 0x2, 0x33b, 0x336, 0x3, 0x2, 0x2, 0x2, 0x33b, 
       0x337, 0x3, 0x2, 0x2, 0x2, 0x33b, 0x338, 0x3, 0x2, 0x2, 0x2, 0x33b, 
       0x33a, 0x3, 0x2, 0x2, 0x2, 0x33c, 0x33d, 0x3, 0x2, 0x2, 0x2, 0x33d, 
       0x33e, 0x5, 0x8, 0x5, 0x2, 0x33e, 0x41, 0x3, 0x2, 0x2, 0x2, 0x33f, 
       0x341, 0x7, 0x7d, 0x2, 0x2, 0x340, 0x33f, 0x3, 0x2, 0x2, 0x2, 0x340, 
       0x341, 0x3, 0x2, 0x2, 0x2, 0x341, 0x342, 0x3, 0x2, 0x2, 0x2, 0x342, 
       0x343, 0x7, 0x11e, 0x2, 0x2, 0x343, 0x344, 0x7, 0x11c, 0x2, 0x2, 
       0x344, 0x346, 0x5, 0x1b6, 0xdc, 0x2, 0x345, 0x347, 0x5, 0x56, 0x2c, 
       0x2, 0x346, 0x345, 0x3, 0x2, 0x2, 0x2, 0x346, 0x347, 0x3, 0x2, 0x2, 
       0x2, 0x347, 0x348, 0x3, 0x2, 0x2, 0x2, 0x348, 0x349, 0x5, 0x48, 0x25, 
       0x2, 0x349, 0x43, 0x3, 0x2, 0x2, 0x2, 0x34a, 0x34b, 0x7, 0x3d, 0x2, 
       0x2, 0x34b, 0x34f, 0x7, 0x11c, 0x2, 0x2, 0x34c, 0x34d, 0x7, 0x88, 
       0x2, 0x2, 0x34d, 0x34e, 0x7, 0xc3, 0x2, 0x2, 0x34e, 0x350, 0x7, 0x6c, 
       0x2, 0x2, 0x34f, 0x34c, 0x3, 0x2, 0x2, 0x2, 0x34f, 0x350, 0x3, 0x2, 
       0x2, 0x2, 0x350, 0x351, 0x3, 0x2, 0x2, 0x2, 0x351, 0x353, 0x5, 0x148, 
       0xa5, 0x2, 0x352, 0x354, 0x5, 0x56, 0x2c, 0x2, 0x353, 0x352, 0x3, 
       0x2, 0x2, 0x2, 0x353, 0x354, 0x3, 0x2, 0x2, 0x2, 0x354, 0x355, 0x3, 
       0x2, 0x2, 0x2, 0x355, 0x356, 0x5, 0x48, 0x25, 0x2, 0x356, 0x45, 0x3, 
       0x2, 0x2, 0x2, 0x357, 0x35e, 0x7, 0x3d, 0x2, 0x2, 0x358, 0x359, 0x7, 
       0xa8, 0x2, 0x2, 0x359, 0x35f, 0x7, 0x11e, 0x2, 0x2, 0x35a, 0x35c, 
       0x9, 0x8, 0x2, 0x2, 0x35b, 0x35a, 0x3, 0x2, 0x2, 0x2, 0x35b, 0x35c, 
       0x3, 0x2, 0x2, 0x2, 0x35c, 0x35d, 0x3, 0x2, 0x2, 0x2, 0x35d, 0x35f, 
       0x7, 0x137, 0x2, 0x2, 0x35e, 0x358, 0x3, 0x2, 0x2, 0x2, 0x35e, 0x35b, 
       0x3, 0x2, 0x2, 0x2, 0x35f, 0x360, 0x3, 0x2, 0x2, 0x2, 0x360, 0x361, 
       0x7, 0x11c, 0x2, 0x2, 0x361, 0x363, 0x5, 0x1b6, 0xdc, 0x2, 0x362, 
       0x364, 0x5, 0x56, 0x2c, 0x2, 0x363, 0x362, 0x3, 0x2, 0x2, 0x2, 0x363, 
       0x364, 0x3, 0x2, 0x2, 0x2, 0x364, 0x365, 0x3, 0x2, 0x2, 0x2, 0x365, 
       0x366, 0x5, 0x48, 0x25, 0x2, 0x366, 0x47, 0x3, 0x2, 0x2, 0x2, 0x367, 
       0x369, 0x7, 0x10, 0x2, 0x2, 0x368, 0x367, 0x3, 0x2, 0x2, 0x2, 0x368, 
       0x369, 0x3, 0x2, 0x2, 0x2, 0x369, 0x36a, 0x3, 0x2, 0x2, 0x2, 0x36a, 
       0x36b, 0x7, 0x169, 0x2, 0x2, 0x36b, 0x36c, 0x5, 0x118, 0x8d, 0x2, 
       0x36c, 0x36d, 0x7, 0x16c, 0x2, 0x2, 0x36d, 0x377, 0x3, 0x2, 0x2, 
       0x2, 0x36e, 0x370, 0x7, 0x10, 0x2, 0x2, 0x36f, 0x36e, 0x3, 0x2, 0x2, 
       0x2, 0x36f, 0x370, 0x3, 0x2, 0x2, 0x2, 0x370, 0x371, 0x3, 0x2, 0x2, 
       0x2, 0x371, 0x377, 0x5, 0x118, 0x8d, 0x2, 0x372, 0x373, 0x7, 0x169, 
       0x2, 0x2, 0x373, 0x374, 0x5, 0x4a, 0x26, 0x2, 0x374, 0x375, 0x7, 
       0x16c, 0x2, 0x2, 0x375, 0x377, 0x3, 0x2, 0x2, 0x2, 0x376, 0x368, 
       0x3, 0x2, 0x2, 0x2, 0x376, 0x36f, 0x3, 0x2, 0x2, 0x2, 0x376, 0x372, 
       0x3, 0x2, 0x2, 0x2, 0x377, 0x379, 0x3, 0x2, 0x2, 0x2, 0x378, 0x37a, 
       0x5, 0x5c, 0x2f, 0x2, 0x379, 0x378, 0x3, 0x2, 0x2, 0x2, 0x379, 0x37a, 
       0x3, 0x2, 0x2, 0x2, 0x37a, 0x49, 0x3, 0x2, 0x2, 0x2, 0x37b, 0x380, 
       0x5, 0x4c, 0x27, 0x2, 0x37c, 0x37d, 0x7, 0x15b, 0x2, 0x2, 0x37d, 
       0x37f, 0x5, 0x4c, 0x27, 0x2, 0x37e, 0x37c, 0x3, 0x2, 0x2, 0x2, 0x37f, 
       0x382, 0x3, 0x2, 0x2, 0x2, 0x380, 0x37e, 0x3, 0x2, 0x2, 0x2, 0x380, 
       0x381, 0x3, 0x2, 0x2, 0x2, 0x381, 0x4b, 0x3, 0x2, 0x2, 0x2, 0x382, 
       0x380, 0x3, 0x2, 0x2, 0x2, 0x383, 0x384, 0x5, 0x4e, 0x28, 0x2, 0x384, 
       0x386, 0x5, 0x78, 0x3d, 0x2, 0x385, 0x387, 0x5, 0x7a, 0x3e, 0x2, 
       0x386, 0x385, 0x3, 0x2, 0x2, 0x2, 0x386, 0x387, 0x3, 0x2, 0x2, 0x2, 
       0x387, 0x38b, 0x3, 0x2, 0x2, 0x2, 0x388, 0x38a, 0x5, 0x7c, 0x3f, 
       0x2, 0x389, 0x388, 0x3, 0x2, 0x2, 0x2, 0x38a, 0x38d, 0x3, 0x2, 0x2, 
       0x2, 0x38b, 0x389, 0x3, 0x2, 0x2, 0x2, 0x38b, 0x38c, 0x3, 0x2, 0x2, 
       0x2, 0x38c, 0x391, 0x3, 0x2, 0x2, 0x2, 0x38d, 0x38b, 0x3, 0x2, 0x2, 
       0x2, 0x38e, 0x390, 0x5, 0x50, 0x29, 0x2, 0x38f, 0x38e, 0x3, 0x2, 
       0x2, 0x2, 0x390, 0x393, 0x3, 0x2, 0x2, 0x2, 0x391, 0x38f, 0x3, 0x2, 
       0x2, 0x2, 0x391, 0x392, 0x3, 0x2, 0x2, 0x2, 0x392, 0x39a, 0x3, 0x2, 
       0x2, 0x2, 0x393, 0x391, 0x3, 0x2, 0x2, 0x2, 0x394, 0x395, 0x7, 0x38, 
       0x2, 0x2, 0x395, 0x397, 0x5, 0x1b6, 0xdc, 0x2, 0x396, 0x394, 0x3, 
       0x2, 0x2, 0x2, 0x396, 0x397, 0x3, 0x2, 0x2, 0x2, 0x397, 0x398, 0x3, 
       0x2, 0x2, 0x2, 0x398, 0x39a, 0x5, 0x52, 0x2a, 0x2, 0x399, 0x383, 
       0x3, 0x2, 0x2, 0x2, 0x399, 0x396, 0x3, 0x2, 0x2, 0x2, 0x39a, 0x4d, 
       0x3, 0x2, 0x2, 0x2, 0x39b, 0x39c, 0x5, 0x1b6, 0xdc, 0x2, 0x39c, 0x4f, 
       0x3, 0x2, 0x2, 0x2, 0x39d, 0x3be, 0x5, 0x7e, 0x40, 0x2, 0x39e, 0x3a0, 
       0x7, 0xc3, 0x2, 0x2, 0x39f, 0x39e, 0x3, 0x2, 0x2, 0x2, 0x39f, 0x3a0, 
       0x3, 0x2, 0x2, 0x2, 0x3a0, 0x3a1, 0x3, 0x2, 0x2, 0x2, 0x3a1, 0x3be, 
       0x7, 0xc5, 0x2, 0x2, 0x3a2, 0x3a3, 0x7, 0xdb, 0x2, 0x2, 0x3a3, 0x3be, 
       0x7, 0xa0, 0x2, 0x2, 0x3a4, 0x3be, 0x7, 0x12c, 0x2, 0x2, 0x3a5, 0x3a6, 
       0x7, 0xe5, 0x2, 0x2, 0x3a6, 0x3a7, 0x5, 0x148, 0xa5, 0x2, 0x3a7, 
       0x3a8, 0x7, 0x169, 0x2, 0x2, 0x3a8, 0x3a9, 0x5, 0x1b6, 0xdc, 0x2, 
       0x3a9, 0x3ad, 0x7, 0x16c, 0x2, 0x2, 0x3aa, 0x3ac, 0x5, 0x54, 0x2b, 
       0x2, 0x3ab, 0x3aa, 0x3, 0x2, 0x2, 0x2, 0x3ac, 0x3af, 0x3, 0x2, 0x2, 
       0x2, 0x3ad, 0x3ab, 0x3, 0x2, 0x2, 0x2, 0x3ad, 0x3ae, 0x3, 0x2, 0x2, 
       0x2, 0x3ae, 0x3be, 0x3, 0x2, 0x2, 0x2, 0x3af, 0x3ad, 0x3, 0x2, 0x2, 
       0x2, 0x3b0, 0x3b1, 0x7, 0x87, 0x2, 0x2, 0x3b1, 0x3b2, 0x7, 0x169, 
       0x2, 0x2, 0x3b2, 0x3b7, 0x7, 0x173, 0x2, 0x2, 0x3b3, 0x3b4, 0x7, 
       0x15b, 0x2, 0x2, 0x3b4, 0x3b6, 0x7, 0x173, 0x2, 0x2, 0x3b5, 0x3b3, 
       0x3, 0x2, 0x2, 0x2, 0x3b6, 0x3b9, 0x3, 0x2, 0x2, 0x2, 0x3b7, 0x3b5, 
       0x3, 0x2, 0x2, 0x2, 0x3b7, 0x3b8, 0x3, 0x2, 0x2, 0x2, 0x3b8, 0x3ba, 
       0x3, 0x2, 0x2, 0x2, 0x3b9, 0x3b7, 0x3, 0x2, 0x2, 0x2, 0x3ba, 0x3be, 
       0x7, 0x16c, 0x2, 0x2, 0x3bb, 0x3be, 0x7, 0x14, 0x2, 0x2, 0x3bc, 0x3be, 
       0x7, 0x63, 0x2, 0x2, 0x3bd, 0x39d, 0x3, 0x2, 0x2, 0x2, 0x3bd, 0x39f, 
       0x3, 0x2, 0x2, 0x2, 0x3bd, 0x3a2, 0x3, 0x2, 0x2, 0x2, 0x3bd, 0x3a4, 
       0x3, 0x2, 0x2, 0x2, 0x3bd, 0x3a5, 0x3, 0x2, 0x2, 0x2, 0x3bd, 0x3b0, 
       0x3, 0x2, 0x2, 0x2, 0x3bd, 0x3bb, 0x3, 0x2, 0x2, 0x2, 0x3bd, 0x3bc, 
       0x3, 0x2, 0x2, 0x2, 0x3be, 0x51, 0x3, 0x2, 0x2, 0x2, 0x3bf, 0x3c0, 
       0x7, 0xdb, 0x2, 0x2, 0x3c0, 0x3c2, 0x7, 0xa0, 0x2, 0x2, 0x3c1, 0x3c3, 
       0x7, 0x2d, 0x2, 0x2, 0x3c2, 0x3c1, 0x3, 0x2, 0x2, 0x2, 0x3c2, 0x3c3, 
       0x3, 0x2, 0x2, 0x2, 0x3c3, 0x3c4, 0x3, 0x2, 0x2, 0x2, 0x3c4, 0x3c5, 
       0x7, 0x169, 0x2, 0x2, 0x3c5, 0x3c7, 0x5, 0x1b6, 0xdc, 0x2, 0x3c6, 
       0x3c8, 0x9, 0x9, 0x2, 0x2, 0x3c7, 0x3c6, 0x3, 0x2, 0x2, 0x2, 0x3c7, 
       0x3c8, 0x3, 0x2, 0x2, 0x2, 0x3c8, 0x3d0, 0x3, 0x2, 0x2, 0x2, 0x3c9, 
       0x3ca, 0x7, 0x15b, 0x2, 0x2, 0x3ca, 0x3cc, 0x5, 0x1b6, 0xdc, 0x2, 
       0x3cb, 0x3cd, 0x9, 0x9, 0x2, 0x2, 0x3cc, 0x3cb, 0x3, 0x2, 0x2, 0x2, 
       0x3cc, 0x3cd, 0x3, 0x2, 0x2, 0x2, 0x3cd, 0x3cf, 0x3, 0x2, 0x2, 0x2, 
       0x3ce, 0x3c9, 0x3, 0x2, 0x2, 0x2, 0x3cf, 0x3d2, 0x3, 0x2, 0x2, 0x2, 
       0x3d0, 0x3ce, 0x3, 0x2, 0x2, 0x2, 0x3d0, 0x3d1, 0x3, 0x2, 0x2, 0x2, 
       0x3d1, 0x3d3, 0x3, 0x2, 0x2, 0x2, 0x3d2, 0x3d0, 0x3, 0x2, 0x2, 0x2, 
       0x3d3, 0x3d5, 0x7, 0x16c, 0x2, 0x2, 0x3d4, 0x3d6, 0x7, 0x63, 0x2, 
       0x2, 0x3d5, 0x3d4, 0x3, 0x2, 0x2, 0x2, 0x3d5, 0x3d6, 0x3, 0x2, 0x2, 
       0x2, 0x3d6, 0x3d8, 0x3, 0x2, 0x2, 0x2, 0x3d7, 0x3d9, 0x5, 0xee, 0x78, 
       0x2, 0x3d8, 0x3d7, 0x3, 0x2, 0x2, 0x2, 0x3d8, 0x3d9, 0x3, 0x2, 0x2, 
       0x2, 0x3d9, 0x3f9, 0x3, 0x2, 0x2, 0x2, 0x3da, 0x3db, 0x7, 0x76, 0x2, 
       0x2, 0x3db, 0x3dc, 0x7, 0xa0, 0x2, 0x2, 0x3dc, 0x3dd, 0x7, 0x169, 
       0x2, 0x2, 0x3dd, 0x3e2, 0x5, 0x1b6, 0xdc, 0x2, 0x3de, 0x3df, 0x7, 
       0x15b, 0x2, 0x2, 0x3df, 0x3e1, 0x5, 0x1b6, 0xdc, 0x2, 0x3e0, 0x3de, 
       0x3, 0x2, 0x2, 0x2, 0x3e1, 0x3e4, 0x3, 0x2, 0x2, 0x2, 0x3e2, 0x3e0, 
       0x3, 0x2, 0x2, 0x2, 0x3e2, 0x3e3, 0x3, 0x2, 0x2, 0x2, 0x3e3, 0x3e5, 
       0x3, 0x2, 0x2, 0x2, 0x3e4, 0x3e2, 0x3, 0x2, 0x2, 0x2, 0x3e5, 0x3e6, 
       0x7, 0x16c, 0x2, 0x2, 0x3e6, 0x3e7, 0x7, 0xe5, 0x2, 0x2, 0x3e7, 0x3e8, 
       0x5, 0x148, 0xa5, 0x2, 0x3e8, 0x3e9, 0x7, 0x169, 0x2, 0x2, 0x3e9, 
       0x3ee, 0x5, 0x1b6, 0xdc, 0x2, 0x3ea, 0x3eb, 0x7, 0x15b, 0x2, 0x2, 
       0x3eb, 0x3ed, 0x5, 0x1b6, 0xdc, 0x2, 0x3ec, 0x3ea, 0x3, 0x2, 0x2, 
       0x2, 0x3ed, 0x3f0, 0x3, 0x2, 0x2, 0x2, 0x3ee, 0x3ec, 0x3, 0x2, 0x2, 
       0x2, 0x3ee, 0x3ef, 0x3, 0x2, 0x2, 0x2, 0x3ef, 0x3f1, 0x3, 0x2, 0x2, 
       0x2, 0x3f0, 0x3ee, 0x3, 0x2, 0x2, 0x2, 0x3f1, 0x3f5, 0x7, 0x16c, 
       0x2, 0x2, 0x3f2, 0x3f4, 0x5, 0x54, 0x2b, 0x2, 0x3f3, 0x3f2, 0x3, 
       0x2, 0x2, 0x2, 0x3f4, 0x3f7, 0x3, 0x2, 0x2, 0x2, 0x3f5, 0x3f3, 0x3, 
       0x2, 0x2, 0x2, 0x3f5, 0x3f6, 0x3, 0x2, 0x2, 0x2, 0x3f6, 0x3f9, 0x3, 
       0x2, 0x2, 0x2, 0x3f7, 0x3f5, 0x3, 0x2, 0x2, 0x2, 0x3f8, 0x3bf, 0x3, 
       0x2, 0x2, 0x2, 0x3f8, 0x3da, 0x3, 0x2, 0x2, 0x2, 0x3f9, 0x53, 0x3, 
       0x2, 0x2, 0x2, 0x3fa, 0x3fb, 0x7, 0xca, 0x2, 0x2, 0x3fb, 0x404, 0x9, 
       0xa, 0x2, 0x2, 0x3fc, 0x3fd, 0x7, 0xbe, 0x2, 0x2, 0x3fd, 0x405, 0x7, 
       0x8, 0x2, 0x2, 0x3fe, 0x405, 0x7, 0xe9, 0x2, 0x2, 0x3ff, 0x400, 0x7, 
       0x102, 0x2, 0x2, 0x400, 0x405, 0x7, 0xc5, 0x2, 0x2, 0x401, 0x402, 
       0x7, 0x102, 0x2, 0x2, 0x402, 0x405, 0x7, 0x4d, 0x2, 0x2, 0x403, 0x405, 
       0x7, 0x24, 0x2, 0x2, 0x404, 0x3fc, 0x3, 0x2, 0x2, 0x2, 0x404, 0x3fe, 
       0x3, 0x2, 0x2, 0x2, 0x404, 0x3ff, 0x3, 0x2, 0x2, 0x2, 0x404, 0x401, 
       0x3, 0x2, 0x2, 0x2, 0x404, 0x403, 0x3, 0x2, 0x2, 0x2, 0x405, 0x55, 
       0x3, 0x2, 0x2, 0x2, 0x406, 0x408, 0x5, 0x58, 0x2d, 0x2, 0x407, 0x406, 
       0x3, 0x2, 0x2, 0x2, 0x408, 0x409, 0x3, 0x2, 0x2, 0x2, 0x409, 0x407, 
       0x3, 0x2, 0x2, 0x2, 0x409, 0x40a, 0x3, 0x2, 0x2, 0x2, 0x40a, 0x57, 
       0x3, 0x2, 0x2, 0x2, 0x40b, 0x40c, 0x7, 0x15b, 0x2, 0x2, 0x40c, 0x40f, 
       0x5, 0x5a, 0x2e, 0x2, 0x40d, 0x40f, 0x5, 0x66, 0x34, 0x2, 0x40e, 
       0x40b, 0x3, 0x2, 0x2, 0x2, 0x40e, 0x40d, 0x3, 0x2, 0x2, 0x2, 0x40f, 
       0x59, 0x3, 0x2, 0x2, 0x2, 0x410, 0x412, 0x7, 0xbe, 0x2, 0x2, 0x411, 
       0x410, 0x3, 0x2, 0x2, 0x2, 0x411, 0x412, 0x3, 0x2, 0x2, 0x2, 0x412, 
       0x413, 0x3, 0x2, 0x2, 0x2, 0x413, 0x414, 0x9, 0xb, 0x2, 0x2, 0x414, 
       0x5b, 0x3, 0x2, 0x2, 0x2, 0x415, 0x417, 0x5, 0x5e, 0x30, 0x2, 0x416, 
       0x415, 0x3, 0x2, 0x2, 0x2, 0x417, 0x418, 0x3, 0x2, 0x2, 0x2, 0x418, 
       0x416, 0x3, 0x2, 0x2, 0x2, 0x418, 0x419, 0x3, 0x2, 0x2, 0x2, 0x419, 
       0x5d, 0x3, 0x2, 0x2, 0x2, 0x41a, 0x41b, 0x7, 0xca, 0x2, 0x2, 0x41b, 
       0x41c, 0x7, 0x34, 0x2, 0x2, 0x41c, 0x41d, 0x9, 0xc, 0x2, 0x2, 0x41d, 
       0x425, 0x7, 0xf4, 0x2, 0x2, 0x41e, 0x425, 0x5, 0x60, 0x31, 0x2, 0x41f, 
       0x425, 0x5, 0x62, 0x32, 0x2, 0x420, 0x425, 0x5, 0x64, 0x33, 0x2, 
       0x421, 0x425, 0x5, 0x66, 0x34, 0x2, 0x422, 0x425, 0x5, 0x6c, 0x37, 
       0x2, 0x423, 0x425, 0x5, 0x6e, 0x38, 0x2, 0x424, 0x41a, 0x3, 0x2, 
       0x2, 0x2, 0x424, 0x41e, 0x3, 0x2, 0x2, 0x2, 0x424, 0x41f, 0x3, 0x2, 
       0x2, 0x2, 0x424, 0x420, 0x3, 0x2, 0x2, 0x2, 0x424, 0x421, 0x3, 0x2, 
       0x2, 0x2, 0x424, 0x422, 0x3, 0x2, 0x2, 0x2, 0x424, 0x423, 0x3, 0x2, 
       0x2, 0x2, 0x425, 0x5f, 0x3, 0x2, 0x2, 0x2, 0x426, 0x427, 0x7, 0xff, 
       0x2, 0x2, 0x427, 0x428, 0x7, 0x3e, 0x2, 0x2, 0x428, 0x439, 0x9, 0xd, 
       0x2, 0x2, 0x429, 0x42a, 0x9, 0xe, 0x2, 0x2, 0x42a, 0x439, 0x7, 0x173, 
       0x2, 0x2, 0x42b, 0x439, 0x7, 0xc0, 0x2, 0x2, 0x42c, 0x439, 0x9, 0xf, 
       0x2, 0x2, 0x42d, 0x42e, 0x7, 0x115, 0x2, 0x2, 0x42e, 0x431, 0x7, 
       0x169, 0x2, 0x2, 0x42f, 0x432, 0x5, 0x1b6, 0xdc, 0x2, 0x430, 0x432, 
       0x7, 0x173, 0x2, 0x2, 0x431, 0x42f, 0x3, 0x2, 0x2, 0x2, 0x431, 0x430, 
       0x3, 0x2, 0x2, 0x2, 0x432, 0x433, 0x3, 0x2, 0x2, 0x2, 0x433, 0x431, 
       0x3, 0x2, 0x2, 0x2, 0x433, 0x434, 0x3, 0x2, 0x2, 0x2, 0x434, 0x435, 
       0x3, 0x2, 0x2, 0x2, 0x435, 0x439, 0x7, 0x16c, 0x2, 0x2, 0x436, 0x437, 
       0x7, 0x11d, 0x2, 0x2, 0x437, 0x439, 0x5, 0x1b6, 0xdc, 0x2, 0x438, 
       0x426, 0x3, 0x2, 0x2, 0x2, 0x438, 0x429, 0x3, 0x2, 0x2, 0x2, 0x438, 
       0x42b, 0x3, 0x2, 0x2, 0x2, 0x438, 0x42c, 0x3, 0x2, 0x2, 0x2, 0x438, 
       0x42d, 0x3, 0x2, 0x2, 0x2, 0x438, 0x436, 0x3, 0x2, 0x2, 0x2, 0x439, 
       0x61, 0x3, 0x2, 0x2, 0x2, 0x43a, 0x43c, 0x7, 0x8d, 0x2, 0x2, 0x43b, 
       0x43a, 0x3, 0x2, 0x2, 0x2, 0x43b, 0x43c, 0x3, 0x2, 0x2, 0x2, 0x43c, 
       0x43d, 0x3, 0x2, 0x2, 0x2, 0x43d, 0x43e, 0x7, 0x8b, 0x2, 0x2, 0x43e, 
       0x45c, 0x5, 0x1b6, 0xdc, 0x2, 0x43f, 0x440, 0x7, 0x13b, 0x2, 0x2, 
       0x440, 0x45c, 0x7, 0xe7, 0x2, 0x2, 0x441, 0x442, 0x7, 0x5b, 0x2, 
       0x2, 0x442, 0x443, 0x7, 0x20, 0x2, 0x2, 0x443, 0x444, 0x7, 0x82, 
       0x2, 0x2, 0x444, 0x445, 0x7, 0x169, 0x2, 0x2, 0x445, 0x44a, 0x5, 
       0x1b6, 0xdc, 0x2, 0x446, 0x447, 0x7, 0x15b, 0x2, 0x2, 0x447, 0x449, 
       0x5, 0x1b6, 0xdc, 0x2, 0x448, 0x446, 0x3, 0x2, 0x2, 0x2, 0x449, 0x44c, 
       0x3, 0x2, 0x2, 0x2, 0x44a, 0x448, 0x3, 0x2, 0x2, 0x2, 0x44a, 0x44b, 
       0x3, 0x2, 0x2, 0x2, 0x44b, 0x44d, 0x3, 0x2, 0x2, 0x2, 0x44c, 0x44a, 
       0x3, 0x2, 0x2, 0x2, 0x44d, 0x44e, 0x7, 0x16c, 0x2, 0x2, 0x44e, 0x45c, 
       0x3, 0x2, 0x2, 0x2, 0x44f, 0x451, 0x7, 0xc3, 0x2, 0x2, 0x450, 0x44f, 
       0x3, 0x2, 0x2, 0x2, 0x450, 0x451, 0x3, 0x2, 0x2, 0x2, 0x451, 0x452, 
       0x3, 0x2, 0x2, 0x2, 0x452, 0x45c, 0x7, 0xae, 0x2, 0x2, 0x453, 0x454, 
       0x7, 0x35, 0x2, 0x2, 0x454, 0x45c, 0x9, 0x10, 0x2, 0x2, 0x455, 0x456, 
       0x7, 0x51, 0x2, 0x2, 0x456, 0x45c, 0x7, 0xcb, 0x2, 0x2, 0x457, 0x458, 
       0x7, 0x13b, 0x2, 0x2, 0x458, 0x459, 0x7, 0xe9, 0x2, 0x2, 0x459, 0x45a, 
       0x7, 0xca, 0x2, 0x2, 0x45a, 0x45c, 0x7, 0x5e, 0x2, 0x2, 0x45b, 0x43b, 
       0x3, 0x2, 0x2, 0x2, 0x45b, 0x43f, 0x3, 0x2, 0x2, 0x2, 0x45b, 0x441, 
       0x3, 0x2, 0x2, 0x2, 0x45b, 0x450, 0x3, 0x2, 0x2, 0x2, 0x45b, 0x453, 
       0x3, 0x2, 0x2, 0x2, 0x45b, 0x455, 0x3, 0x2, 0x2, 0x2, 0x45b, 0x457, 
       0x3, 0x2, 0x2, 0x2, 0x45c, 0x63, 0x3, 0x2, 0x2, 0x2, 0x45d, 0x45f, 
       0x7, 0x12c, 0x2, 0x2, 0x45e, 0x45d, 0x3, 0x2, 0x2, 0x2, 0x45e, 0x45f, 
       0x3, 0x2, 0x2, 0x2, 0x45f, 0x460, 0x3, 0x2, 0x2, 0x2, 0x460, 0x461, 
       0x7, 0xdb, 0x2, 0x2, 0x461, 0x462, 0x7, 0x8d, 0x2, 0x2, 0x462, 0x463, 
       0x7, 0x169, 0x2, 0x2, 0x463, 0x468, 0x5, 0x1b6, 0xdc, 0x2, 0x464, 
       0x465, 0x7, 0x15b, 0x2, 0x2, 0x465, 0x467, 0x5, 0x1b6, 0xdc, 0x2, 
       0x466, 0x464, 0x3, 0x2, 0x2, 0x2, 0x467, 0x46a, 0x3, 0x2, 0x2, 0x2, 
       0x468, 0x466, 0x3, 0x2, 0x2, 0x2, 0x468, 0x469, 0x3, 0x2, 0x2, 0x2, 
       0x469, 0x46b, 0x3, 0x2, 0x2, 0x2, 0x46a, 0x468, 0x3, 0x2, 0x2, 0x2, 
       0x46b, 0x46c, 0x7, 0x16c, 0x2, 0x2, 0x46c, 0x470, 0x3, 0x2, 0x2, 
       0x2, 0x46d, 0x46e, 0x7, 0x13b, 0x2, 0x2, 0x46e, 0x470, 0x7, 0x45, 
       0x2, 0x2, 0x46f, 0x45e, 0x3, 0x2, 0x2, 0x2, 0x46f, 0x46d, 0x3, 0x2, 
       0x2, 0x2, 0x470, 0x65, 0x3, 0x2, 0x2, 0x2, 0x471, 0x476, 0x5, 0x68, 
       0x35, 0x2, 0x472, 0x473, 0x7, 0x116, 0x2, 0x2, 0x473, 0x474, 0x7, 
       0x10, 0x2, 0x2, 0x474, 0x476, 0x5, 0x1b6, 0xdc, 0x2, 0x475, 0x471, 
       0x3, 0x2, 0x2, 0x2, 0x475, 0x472, 0x3, 0x2, 0x2, 0x2, 0x476, 0x67, 
       0x3, 0x2, 0x2, 0x2, 0x477, 0x478, 0x7, 0xf3, 0x2, 0x2, 0x478, 0x479, 
       0x7, 0x77, 0x2, 0x2, 0x479, 0x47d, 0x7, 0x53, 0x2, 0x2, 0x47a, 0x47c, 
       0x5, 0x6a, 0x36, 0x2, 0x47b, 0x47a, 0x3, 0x2, 0x2, 0x2, 0x47c, 0x47f, 
       0x3, 0x2, 0x2, 0x2, 0x47d, 0x47b, 0x3, 0x2, 0x2, 0x2, 0x47d, 0x47e, 
       0x3, 0x2, 0x2, 0x2, 0x47e, 0x69, 0x3, 0x2, 0x2, 0x2, 0x47f, 0x47d, 
       0x3, 0x2, 0x2, 0x2, 0x480, 0x481, 0x7, 0x71, 0x2, 0x2, 0x481, 0x482, 
       0x7, 0x11f, 0x2, 0x2, 0x482, 0x483, 0x7, 0x20, 0x2, 0x2, 0x483, 0x487, 
       0x5, 0x17e, 0xc0, 0x2, 0x484, 0x485, 0x7, 0x66, 0x2, 0x2, 0x485, 
       0x486, 0x7, 0x20, 0x2, 0x2, 0x486, 0x488, 0x5, 0x17e, 0xc0, 0x2, 
       0x487, 0x484, 0x3, 0x2, 0x2, 0x2, 0x487, 0x488, 0x3, 0x2, 0x2, 0x2, 
       0x488, 0x49c, 0x3, 0x2, 0x2, 0x2, 0x489, 0x48a, 0x7, 0x30, 0x2, 0x2, 
       0x48a, 0x48b, 0x7, 0x9d, 0x2, 0x2, 0x48b, 0x48c, 0x7, 0x11f, 0x2, 
       0x2, 0x48c, 0x48d, 0x7, 0x20, 0x2, 0x2, 0x48d, 0x49c, 0x5, 0x17e, 
       0xc0, 0x2, 0x48e, 0x48f, 0x7, 0xb1, 0x2, 0x2, 0x48f, 0x490, 0x7, 
       0xa1, 0x2, 0x2, 0x490, 0x491, 0x7, 0x11f, 0x2, 0x2, 0x491, 0x492, 
       0x7, 0x20, 0x2, 0x2, 0x492, 0x49c, 0x5, 0x17e, 0xc0, 0x2, 0x493, 
       0x494, 0x7, 0xa7, 0x2, 0x2, 0x494, 0x495, 0x7, 0x11f, 0x2, 0x2, 0x495, 
       0x496, 0x7, 0x20, 0x2, 0x2, 0x496, 0x49c, 0x5, 0x17e, 0xc0, 0x2, 
       0x497, 0x498, 0x7, 0xc5, 0x2, 0x2, 0x498, 0x499, 0x7, 0x4f, 0x2, 
       0x2, 0x499, 0x49a, 0x7, 0x10, 0x2, 0x2, 0x49a, 0x49c, 0x5, 0x17e, 
       0xc0, 0x2, 0x49b, 0x480, 0x3, 0x2, 0x2, 0x2, 0x49b, 0x489, 0x3, 0x2, 
       0x2, 0x2, 0x49b, 0x48e, 0x3, 0x2, 0x2, 0x2, 0x49b, 0x493, 0x3, 0x2, 
       0x2, 0x2, 0x49b, 0x497, 0x3, 0x2, 0x2, 0x2, 0x49c, 0x6b, 0x3, 0x2, 
       0x2, 0x2, 0x49d, 0x49e, 0x7, 0xca, 0x2, 0x2, 0x49e, 0x4a2, 0x5, 0x1b6, 
       0xdc, 0x2, 0x49f, 0x4a0, 0x7, 0x120, 0x2, 0x2, 0x4a0, 0x4a2, 0x5, 
       0x1b6, 0xdc, 0x2, 0x4a1, 0x49d, 0x3, 0x2, 0x2, 0x2, 0x4a1, 0x49f, 
       0x3, 0x2, 0x2, 0x2, 0x4a2, 0x6d, 0x3, 0x2, 0x2, 0x2, 0x4a3, 0x4a5, 
       0x7, 0x14, 0x2, 0x2, 0x4a4, 0x4a6, 0x7, 0x15f, 0x2, 0x2, 0x4a5, 0x4a4, 
       0x3, 0x2, 0x2, 0x2, 0x4a5, 0x4a6, 0x3, 0x2, 0x2, 0x2, 0x4a6, 0x4a7, 
       0x3, 0x2, 0x2, 0x2, 0x4a7, 0x4bf, 0x5, 0x17e, 0xc0, 0x2, 0x4a8, 0x4aa, 
       0x7, 0x32, 0x2, 0x2, 0x4a9, 0x4ab, 0x7, 0x15f, 0x2, 0x2, 0x4aa, 0x4a9, 
       0x3, 0x2, 0x2, 0x2, 0x4aa, 0x4ab, 0x3, 0x2, 0x2, 0x2, 0x4ab, 0x4ac, 
       0x3, 0x2, 0x2, 0x2, 0x4ac, 0x4bf, 0x5, 0x17e, 0xc0, 0x2, 0x4ad, 0x4af, 
       0x7, 0x4d, 0x2, 0x2, 0x4ae, 0x4ad, 0x3, 0x2, 0x2, 0x2, 0x4ae, 0x4af, 
       0x3, 0x2, 0x2, 0x2, 0x4af, 0x4b3, 0x3, 0x2, 0x2, 0x2, 0x4b0, 0x4b1, 
       0x7, 0x29, 0x2, 0x2, 0x4b1, 0x4b4, 0x7, 0x102, 0x2, 0x2, 0x4b2, 0x4b4, 
       0x7, 0x2a, 0x2, 0x2, 0x4b3, 0x4b0, 0x3, 0x2, 0x2, 0x2, 0x4b3, 0x4b2, 
       0x3, 0x2, 0x2, 0x2, 0x4b4, 0x4b6, 0x3, 0x2, 0x2, 0x2, 0x4b5, 0x4b7, 
       0x7, 0x15f, 0x2, 0x2, 0x4b6, 0x4b5, 0x3, 0x2, 0x2, 0x2, 0x4b6, 0x4b7, 
       0x3, 0x2, 0x2, 0x2, 0x4b7, 0x4b8, 0x3, 0x2, 0x2, 0x2, 0x4b8, 0x4bf, 
       0x5, 0x17e, 0xc0, 0x2, 0x4b9, 0x4bb, 0x7, 0x65, 0x2, 0x2, 0x4ba, 
       0x4bc, 0x7, 0x15f, 0x2, 0x2, 0x4bb, 0x4ba, 0x3, 0x2, 0x2, 0x2, 0x4bb, 
       0x4bc, 0x3, 0x2, 0x2, 0x2, 0x4bc, 0x4bd, 0x3, 0x2, 0x2, 0x2, 0x4bd, 
       0x4bf, 0x5, 0x17e, 0xc0, 0x2, 0x4be, 0x4a3, 0x3, 0x2, 0x2, 0x2, 0x4be, 
       0x4a8, 0x3, 0x2, 0x2, 0x2, 0x4be, 0x4ae, 0x3, 0x2, 0x2, 0x2, 0x4be, 
       0x4b9, 0x3, 0x2, 0x2, 0x2, 0x4bf, 0x6f, 0x3, 0x2, 0x2, 0x2, 0x4c0, 
       0x4c1, 0x7, 0xc, 0x2, 0x2, 0x4c1, 0x4c2, 0x7, 0x11c, 0x2, 0x2, 0x4c2, 
       0x4c3, 0x5, 0x148, 0xa5, 0x2, 0x4c3, 0x4c4, 0x5, 0x72, 0x3a, 0x2, 
       0x4c4, 0x71, 0x3, 0x2, 0x2, 0x2, 0x4c5, 0x4c6, 0x5, 0x74, 0x3b, 0x2, 
       0x4c6, 0x73, 0x3, 0x2, 0x2, 0x2, 0x4c7, 0x4ca, 0x7, 0x9, 0x2, 0x2, 
       0x4c8, 0x4c9, 0x7, 0x38, 0x2, 0x2, 0x4c9, 0x4cb, 0x5, 0x1b6, 0xdc, 
       0x2, 0x4ca, 0x4c8, 0x3, 0x2, 0x2, 0x2, 0x4ca, 0x4cb, 0x3, 0x2, 0x2, 
       0x2, 0x4cb, 0x4cc, 0x3, 0x2, 0x2, 0x2, 0x4cc, 0x4cd, 0x5, 0x76, 0x3c, 
       0x2, 0x4cd, 0x75, 0x3, 0x2, 0x2, 0x2, 0x4ce, 0x4cf, 0x7, 0xdb, 0x2, 
       0x2, 0x4cf, 0x4d1, 0x7, 0xa0, 0x2, 0x2, 0x4d0, 0x4d2, 0x7, 0x2d, 
       0x2, 0x2, 0x4d1, 0x4d0, 0x3, 0x2, 0x2, 0x2, 0x4d1, 0x4d2, 0x3, 0x2, 
       0x2, 0x2, 0x4d2, 0x4d3, 0x3, 0x2, 0x2, 0x2, 0x4d3, 0x4d4, 0x7, 0x169, 
       0x2, 0x2, 0x4d4, 0x4d6, 0x5, 0x1b6, 0xdc, 0x2, 0x4d5, 0x4d7, 0x9, 
       0x9, 0x2, 0x2, 0x4d6, 0x4d5, 0x3, 0x2, 0x2, 0x2, 0x4d6, 0x4d7, 0x3, 
       0x2, 0x2, 0x2, 0x4d7, 0x4df, 0x3, 0x2, 0x2, 0x2, 0x4d8, 0x4d9, 0x7, 
       0x15b, 0x2, 0x2, 0x4d9, 0x4db, 0x5, 0x1b6, 0xdc, 0x2, 0x4da, 0x4dc, 
       0x9, 0x9, 0x2, 0x2, 0x4db, 0x4da, 0x3, 0x2, 0x2, 0x2, 0x4db, 0x4dc, 
       0x3, 0x2, 0x2, 0x2, 0x4dc, 0x4de, 0x3, 0x2, 0x2, 0x2, 0x4dd, 0x4d8, 
       0x3, 0x2, 0x2, 0x2, 0x4de, 0x4e1, 0x3, 0x2, 0x2, 0x2, 0x4df, 0x4dd, 
       0x3, 0x2, 0x2, 0x2, 0x4df, 0x4e0, 0x3, 0x2, 0x2, 0x2, 0x4e0, 0x4e2, 
       0x3, 0x2, 0x2, 0x2, 0x4e1, 0x4df, 0x3, 0x2, 0x2, 0x2, 0x4e2, 0x4e4, 
       0x7, 0x16c, 0x2, 0x2, 0x4e3, 0x4e5, 0x7, 0x63, 0x2, 0x2, 0x4e4, 0x4e3, 
       0x3, 0x2, 0x2, 0x2, 0x4e4, 0x4e5, 0x3, 0x2, 0x2, 0x2, 0x4e5, 0x4e7, 
       0x3, 0x2, 0x2, 0x2, 0x4e6, 0x4e8, 0x5, 0xee, 0x78, 0x2, 0x4e7, 0x4e6, 
       0x3, 0x2, 0x2, 0x2, 0x4e7, 0x4e8, 0x3, 0x2, 0x2, 0x2, 0x4e8, 0x50d, 
       0x3, 0x2, 0x2, 0x2, 0x4e9, 0x4ea, 0x7, 0x76, 0x2, 0x2, 0x4ea, 0x4eb, 
       0x7, 0xa0, 0x2, 0x2, 0x4eb, 0x4ec, 0x7, 0x169, 0x2, 0x2, 0x4ec, 0x4f1, 
       0x5, 0x1b6, 0xdc, 0x2, 0x4ed, 0x4ee, 0x7, 0x15b, 0x2, 0x2, 0x4ee, 
       0x4f0, 0x5, 0x1b6, 0xdc, 0x2, 0x4ef, 0x4ed, 0x3, 0x2, 0x2, 0x2, 0x4f0, 
       0x4f3, 0x3, 0x2, 0x2, 0x2, 0x4f1, 0x4ef, 0x3, 0x2, 0x2, 0x2, 0x4f1, 
       0x4f2, 0x3, 0x2, 0x2, 0x2, 0x4f2, 0x4f4, 0x3, 0x2, 0x2, 0x2, 0x4f3, 
       0x4f1, 0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4f5, 0x7, 0x16c, 0x2, 0x2, 0x4f5, 
       0x4f6, 0x7, 0xe5, 0x2, 0x2, 0x4f6, 0x4f7, 0x5, 0x148, 0xa5, 0x2, 
       0x4f7, 0x4f8, 0x7, 0x169, 0x2, 0x2, 0x4f8, 0x4fd, 0x5, 0x1b6, 0xdc, 
       0x2, 0x4f9, 0x4fa, 0x7, 0x15b, 0x2, 0x2, 0x4fa, 0x4fc, 0x5, 0x1b6, 
       0xdc, 0x2, 0x4fb, 0x4f9, 0x3, 0x2, 0x2, 0x2, 0x4fc, 0x4ff, 0x3, 0x2, 
       0x2, 0x2, 0x4fd, 0x4fb, 0x3, 0x2, 0x2, 0x2, 0x4fd, 0x4fe, 0x3, 0x2, 
       0x2, 0x2, 0x4fe, 0x500, 0x3, 0x2, 0x2, 0x2, 0x4ff, 0x4fd, 0x3, 0x2, 
       0x2, 0x2, 0x500, 0x504, 0x7, 0x16c, 0x2, 0x2, 0x501, 0x503, 0x5, 
       0x54, 0x2b, 0x2, 0x502, 0x501, 0x3, 0x2, 0x2, 0x2, 0x503, 0x506, 
       0x3, 0x2, 0x2, 0x2, 0x504, 0x502, 0x3, 0x2, 0x2, 0x2, 0x504, 0x505, 
       0x3, 0x2, 0x2, 0x2, 0x505, 0x50d, 0x3, 0x2, 0x2, 0x2, 0x506, 0x504, 
       0x3, 0x2, 0x2, 0x2, 0x507, 0x508, 0x7, 0x4d, 0x2, 0x2, 0x508, 0x509, 
       0x5, 0x17e, 0xc0, 0x2, 0x509, 0x50a, 0x7, 0x75, 0x2, 0x2, 0x50a, 
       0x50b, 0x5, 0x1b6, 0xdc, 0x2, 0x50b, 0x50d, 0x3, 0x2, 0x2, 0x2, 0x50c, 
       0x4ce, 0x3, 0x2, 0x2, 0x2, 0x50c, 0x4e9, 0x3, 0x2, 0x2, 0x2, 0x50c, 
       0x507, 0x3, 0x2, 0x2, 0x2, 0x50d, 0x77, 0x3, 0x2, 0x2, 0x2, 0x50e, 
       0x53c, 0x7, 0x28, 0x2, 0x2, 0x50f, 0x53c, 0x7, 0x19, 0x2, 0x2, 0x510, 
       0x53c, 0x7, 0x1a, 0x2, 0x2, 0x511, 0x53c, 0x7, 0x1b, 0x2, 0x2, 0x512, 
       0x53c, 0x7, 0x1c, 0x2, 0x2, 0x513, 0x53c, 0x7, 0x1d, 0x2, 0x2, 0x514, 
       0x53c, 0x7, 0x46, 0x2, 0x2, 0x515, 0x53c, 0x7, 0x47, 0x2, 0x2, 0x516, 
       0x53c, 0x7, 0x4a, 0x2, 0x2, 0x517, 0x53c, 0x7, 0x4b, 0x2, 0x2, 0x518, 
       0x51a, 0x7, 0x5d, 0x2, 0x2, 0x519, 0x51b, 0x7, 0xd9, 0x2, 0x2, 0x51a, 
       0x519, 0x3, 0x2, 0x2, 0x2, 0x51a, 0x51b, 0x3, 0x2, 0x2, 0x2, 0x51b, 
       0x53c, 0x3, 0x2, 0x2, 0x2, 0x51c, 0x53c, 0x7, 0x74, 0x2, 0x2, 0x51d, 
       0x53c, 0x7, 0x92, 0x2, 0x2, 0x51e, 0x53c, 0x7, 0x93, 0x2, 0x2, 0x51f, 
       0x53c, 0x7, 0x94, 0x2, 0x2, 0x520, 0x53c, 0x7, 0x95, 0x2, 0x2, 0x521, 
       0x53c, 0x7, 0x96, 0x2, 0x2, 0x522, 0x53c, 0x7, 0xbb, 0x2, 0x2, 0x523, 
       0x53c, 0x7, 0xbd, 0x2, 0x2, 0x524, 0x53c, 0x7, 0xc7, 0x2, 0x2, 0x525, 
       0x53c, 0x7, 0xc6, 0x2, 0x2, 0x526, 0x53c, 0x7, 0xd8, 0x2, 0x2, 0x527, 
       0x53c, 0x7, 0xe4, 0x2, 0x2, 0x528, 0x529, 0x7, 0xeb, 0x2, 0x2, 0x529, 
       0x53c, 0x7, 0x136, 0x2, 0x2, 0x52a, 0x53c, 0x7, 0x109, 0x2, 0x2, 
       0x52b, 0x53c, 0x7, 0x108, 0x2, 0x2, 0x52c, 0x53c, 0x7, 0x10a, 0x2, 
       0x2, 0x52d, 0x53c, 0x7, 0x10c, 0x2, 0x2, 0x52e, 0x53c, 0x7, 0x10b, 
       0x2, 0x2, 0x52f, 0x53c, 0x7, 0x117, 0x2, 0x2, 0x530, 0x53c, 0x7, 
       0x11b, 0x2, 0x2, 0x531, 0x53c, 0x7, 0x122, 0x2, 0x2, 0x532, 0x53c, 
       0x7, 0x123, 0x2, 0x2, 0x533, 0x53c, 0x7, 0x134, 0x2, 0x2, 0x534, 
       0x53c, 0x7, 0x135, 0x2, 0x2, 0x535, 0x53c, 0x7, 0x13f, 0x2, 0x2, 
       0x536, 0x539, 0x5, 0x1b6, 0xdc, 0x2, 0x537, 0x538, 0x7, 0x5, 0x2, 
       0x2, 0x538, 0x53a, 0x9, 0x11, 0x2, 0x2, 0x539, 0x537, 0x3, 0x2, 0x2, 
       0x2, 0x539, 0x53a, 0x3, 0x2, 0x2, 0x2, 0x53a, 0x53c, 0x3, 0x2, 0x2, 
       0x2, 0x53b, 0x50e, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x50f, 0x3, 0x2, 0x2, 
       0x2, 0x53b, 0x510, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x511, 0x3, 0x2, 0x2, 
       0x2, 0x53b, 0x512, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x513, 0x3, 0x2, 0x2, 
       0x2, 0x53b, 0x514, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x515, 0x3, 0x2, 0x2, 
       0x2, 0x53b, 0x516, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x517, 0x3, 0x2, 0x2, 
       0x2, 0x53b, 0x518, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x51c, 0x3, 0x2, 0x2, 
       0x2, 0x53b, 0x51d, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x51e, 0x3, 0x2, 0x2, 
       0x2, 0x53b, 0x51f, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x520, 0x3, 0x2, 0x2, 
       0x2, 0x53b, 0x521, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x522, 0x3, 0x2, 0x2, 
       0x2, 0x53b, 0x523, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x524, 0x3, 0x2, 0x2, 
       0x2, 0x53b, 0x525, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x526, 0x3, 0x2, 0x2, 
       0x2, 0x53b, 0x527, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x528, 0x3, 0x2, 0x2, 
       0x2, 0x53b, 0x52a, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x52b, 0x3, 0x2, 0x2, 
       0x2, 0x53b, 0x52c, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x52d, 0x3, 0x2, 0x2, 
       0x2, 0x53b, 0x52e, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x52f, 0x3, 0x2, 0x2, 
       0x2, 0x53b, 0x530, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x531, 0x3, 0x2, 0x2, 
       0x2, 0x53b, 0x532, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x533, 0x3, 0x2, 0x2, 
       0x2, 0x53b, 0x534, 0x3, 0x2, 0x2, 0x2, 0x53b, 0x535, 0x3, 0x2, 0x2, 
       0x2, 0x53b, 0x536, 0x3, 0x2, 0x2, 0x2, 0x53c, 0x79, 0x3, 0x2, 0x2, 
       0x2, 0x53d, 0x53e, 0x7, 0x169, 0x2, 0x2, 0x53e, 0x540, 0x9, 0x12, 
       0x2, 0x2, 0x53f, 0x541, 0x9, 0x13, 0x2, 0x2, 0x540, 0x53f, 0x3, 0x2, 
       0x2, 0x2, 0x540, 0x541, 0x3, 0x2, 0x2, 0x2, 0x541, 0x544, 0x3, 0x2, 
       0x2, 0x2, 0x542, 0x543, 0x7, 0x15b, 0x2, 0x2, 0x543, 0x545, 0x7, 
       0x173, 0x2, 0x2, 0x544, 0x542, 0x3, 0x2, 0x2, 0x2, 0x544, 0x545, 
       0x3, 0x2, 0x2, 0x2, 0x545, 0x546, 0x3, 0x2, 0x2, 0x2, 0x546, 0x547, 
       0x7, 0x16c, 0x2, 0x2, 0x547, 0x7b, 0x3, 0x2, 0x2, 0x2, 0x548, 0x54a, 
       0x7, 0xc3, 0x2, 0x2, 0x549, 0x548, 0x3, 0x2, 0x2, 0x2, 0x549, 0x54a, 
       0x3, 0x2, 0x2, 0x2, 0x54a, 0x54b, 0x3, 0x2, 0x2, 0x2, 0x54b, 0x554, 
       0x7, 0xc5, 0x2, 0x2, 0x54c, 0x54d, 0x7, 0x29, 0x2, 0x2, 0x54d, 0x54e, 
       0x7, 0x102, 0x2, 0x2, 0x54e, 0x554, 0x5, 0x1b6, 0xdc, 0x2, 0x54f, 
       0x551, 0x7, 0xc3, 0x2, 0x2, 0x550, 0x54f, 0x3, 0x2, 0x2, 0x2, 0x550, 
       0x551, 0x3, 0x2, 0x2, 0x2, 0x551, 0x552, 0x3, 0x2, 0x2, 0x2, 0x552, 
       0x554, 0x9, 0x14, 0x2, 0x2, 0x553, 0x549, 0x3, 0x2, 0x2, 0x2, 0x553, 
       0x54c, 0x3, 0x2, 0x2, 0x2, 0x553, 0x550, 0x3, 0x2, 0x2, 0x2, 0x554, 
       0x7d, 0x3, 0x2, 0x2, 0x2, 0x555, 0x557, 0x7, 0x15a, 0x2, 0x2, 0x556, 
       0x555, 0x3, 0x2, 0x2, 0x2, 0x556, 0x557, 0x3, 0x2, 0x2, 0x2, 0x557, 
       0x558, 0x3, 0x2, 0x2, 0x2, 0x558, 0x559, 0x7, 0x15f, 0x2, 0x2, 0x559, 
       0x562, 0x5, 0x17e, 0xc0, 0x2, 0x55a, 0x55c, 0x7, 0x13b, 0x2, 0x2, 
       0x55b, 0x55a, 0x3, 0x2, 0x2, 0x2, 0x55b, 0x55c, 0x3, 0x2, 0x2, 0x2, 
       0x55c, 0x55d, 0x3, 0x2, 0x2, 0x2, 0x55d, 0x55f, 0x7, 0x4d, 0x2, 0x2, 
       0x55e, 0x560, 0x5, 0x17e, 0xc0, 0x2, 0x55f, 0x55e, 0x3, 0x2, 0x2, 
       0x2, 0x55f, 0x560, 0x3, 0x2, 0x2, 0x2, 0x560, 0x562, 0x3, 0x2, 0x2, 
       0x2, 0x561, 0x556, 0x3, 0x2, 0x2, 0x2, 0x561, 0x55b, 0x3, 0x2, 0x2, 
       0x2, 0x562, 0x7f, 0x3, 0x2, 0x2, 0x2, 0x563, 0x564, 0x7, 0x3d, 0x2, 
       0x2, 0x564, 0x568, 0x9, 0x15, 0x2, 0x2, 0x565, 0x566, 0x7, 0x88, 
       0x2, 0x2, 0x566, 0x567, 0x7, 0xc3, 0x2, 0x2, 0x567, 0x569, 0x7, 0x6c, 
       0x2, 0x2, 0x568, 0x565, 0x3, 0x2, 0x2, 0x2, 0x568, 0x569, 0x3, 0x2, 
       0x2, 0x2, 0x569, 0x56a, 0x3, 0x2, 0x2, 0x2, 0x56a, 0x56e, 0x5, 0x17e, 
       0xc0, 0x2, 0x56b, 0x56d, 0x5, 0x82, 0x42, 0x2, 0x56c, 0x56b, 0x3, 
       0x2, 0x2, 0x2, 0x56d, 0x570, 0x3, 0x2, 0x2, 0x2, 0x56e, 0x56c, 0x3, 
       0x2, 0x2, 0x2, 0x56e, 0x56f, 0x3, 0x2, 0x2, 0x2, 0x56f, 0x81, 0x3, 
       0x2, 0x2, 0x2, 0x570, 0x56e, 0x3, 0x2, 0x2, 0x2, 0x571, 0x572, 0x7, 
       0x32, 0x2, 0x2, 0x572, 0x576, 0x5, 0x17e, 0xc0, 0x2, 0x573, 0x574, 
       0x7, 0xa9, 0x2, 0x2, 0x574, 0x576, 0x5, 0x17e, 0xc0, 0x2, 0x575, 
       0x571, 0x3, 0x2, 0x2, 0x2, 0x575, 0x573, 0x3, 0x2, 0x2, 0x2, 0x576, 
       0x83, 0x3, 0x2, 0x2, 0x2, 0x577, 0x57f, 0x7, 0xc, 0x2, 0x2, 0x578, 
       0x57b, 0x7, 0x3d, 0x2, 0x2, 0x579, 0x57a, 0x7, 0xcd, 0x2, 0x2, 0x57a, 
       0x57c, 0x7, 0xe7, 0x2, 0x2, 0x57b, 0x579, 0x3, 0x2, 0x2, 0x2, 0x57b, 
       0x57c, 0x3, 0x2, 0x2, 0x2, 0x57c, 0x57f, 0x3, 0x2, 0x2, 0x2, 0x57d, 
       0x57f, 0x7, 0xe7, 0x2, 0x2, 0x57e, 0x577, 0x3, 0x2, 0x2, 0x2, 0x57e, 
       0x578, 0x3, 0x2, 0x2, 0x2, 0x57e, 0x57d, 0x3, 0x2, 0x2, 0x2, 0x57e, 
       0x57f, 0x3, 0x2, 0x2, 0x2, 0x57f, 0x580, 0x3, 0x2, 0x2, 0x2, 0x580, 
       0x581, 0x7, 0x7b, 0x2, 0x2, 0x581, 0x583, 0x5, 0x1b6, 0xdc, 0x2, 
       0x582, 0x584, 0x5, 0x96, 0x4c, 0x2, 0x583, 0x582, 0x3, 0x2, 0x2, 
       0x2, 0x583, 0x584, 0x3, 0x2, 0x2, 0x2, 0x584, 0x585, 0x3, 0x2, 0x2, 
       0x2, 0x585, 0x587, 0x5, 0x86, 0x44, 0x2, 0x586, 0x588, 0x9, 0x16, 
       0x2, 0x2, 0x587, 0x586, 0x3, 0x2, 0x2, 0x2, 0x587, 0x588, 0x3, 0x2, 
       0x2, 0x2, 0x588, 0x58a, 0x3, 0x2, 0x2, 0x2, 0x589, 0x58b, 0x5, 0x32, 
       0x1a, 0x2, 0x58a, 0x589, 0x3, 0x2, 0x2, 0x2, 0x58a, 0x58b, 0x3, 0x2, 
       0x2, 0x2, 0x58b, 0x58c, 0x3, 0x2, 0x2, 0x2, 0x58c, 0x58d, 0x5, 0x8, 
       0x5, 0x2, 0x58d, 0x85, 0x3, 0x2, 0x2, 0x2, 0x58e, 0x58f, 0x9, 0x17, 
       0x2, 0x2, 0x58f, 0x591, 0x5, 0x78, 0x3d, 0x2, 0x590, 0x592, 0x5, 
       0x7a, 0x3e, 0x2, 0x591, 0x590, 0x3, 0x2, 0x2, 0x2, 0x591, 0x592, 
       0x3, 0x2, 0x2, 0x2, 0x592, 0x87, 0x3, 0x2, 0x2, 0x2, 0x593, 0x59b, 
       0x7, 0xc, 0x2, 0x2, 0x594, 0x597, 0x7, 0x3d, 0x2, 0x2, 0x595, 0x596, 
       0x7, 0xcd, 0x2, 0x2, 0x596, 0x598, 0x7, 0xe7, 0x2, 0x2, 0x597, 0x595, 
       0x3, 0x2, 0x2, 0x2, 0x597, 0x598, 0x3, 0x2, 0x2, 0x2, 0x598, 0x59b, 
       0x3, 0x2, 0x2, 0x2, 0x599, 0x59b, 0x7, 0xe7, 0x2, 0x2, 0x59a, 0x593, 
       0x3, 0x2, 0x2, 0x2, 0x59a, 0x594, 0x3, 0x2, 0x2, 0x2, 0x59a, 0x599, 
       0x3, 0x2, 0x2, 0x2, 0x59a, 0x59b, 0x3, 0x2, 0x2, 0x2, 0x59b, 0x59c, 
       0x3, 0x2, 0x2, 0x2, 0x59c, 0x59d, 0x7, 0xd4, 0x2, 0x2, 0x59d, 0x59e, 
       0x5, 0x1b6, 0xdc, 0x2, 0x59e, 0x59f, 0x9, 0x16, 0x2, 0x2, 0x59f, 
       0x5a0, 0x5, 0x8a, 0x46, 0x2, 0x5a0, 0x5a4, 0x7, 0x64, 0x2, 0x2, 0x5a1, 
       0x5a2, 0x5, 0x1b6, 0xdc, 0x2, 0x5a2, 0x5a3, 0x7, 0x16e, 0x2, 0x2, 
       0x5a3, 0x5a5, 0x3, 0x2, 0x2, 0x2, 0x5a4, 0x5a1, 0x3, 0x2, 0x2, 0x2, 
       0x5a4, 0x5a5, 0x3, 0x2, 0x2, 0x2, 0x5a5, 0x89, 0x3, 0x2, 0x2, 0x2, 
       0x5a6, 0x5a7, 0x5, 0x8c, 0x47, 0x2, 0x5a7, 0x5ad, 0x7, 0x16e, 0x2, 
       0x2, 0x5a8, 0x5a9, 0x5, 0x8c, 0x47, 0x2, 0x5a9, 0x5aa, 0x7, 0x16e, 
       0x2, 0x2, 0x5aa, 0x5ac, 0x3, 0x2, 0x2, 0x2, 0x5ab, 0x5a8, 0x3, 0x2, 
       0x2, 0x2, 0x5ac, 0x5af, 0x3, 0x2, 0x2, 0x2, 0x5ad, 0x5ab, 0x3, 0x2, 
       0x2, 0x2, 0x5ad, 0x5ae, 0x3, 0x2, 0x2, 0x2, 0x5ae, 0x8b, 0x3, 0x2, 
       0x2, 0x2, 0x5af, 0x5ad, 0x3, 0x2, 0x2, 0x2, 0x5b0, 0x5be, 0x5, 0x34, 
       0x1b, 0x2, 0x5b1, 0x5b2, 0x7, 0x7b, 0x2, 0x2, 0x5b2, 0x5b4, 0x5, 
       0x1b6, 0xdc, 0x2, 0x5b3, 0x5b5, 0x5, 0x96, 0x4c, 0x2, 0x5b4, 0x5b3, 
       0x3, 0x2, 0x2, 0x2, 0x5b4, 0x5b5, 0x3, 0x2, 0x2, 0x2, 0x5b5, 0x5b6, 
       0x3, 0x2, 0x2, 0x2, 0x5b6, 0x5b7, 0x5, 0x86, 0x44, 0x2, 0x5b7, 0x5be, 
       0x3, 0x2, 0x2, 0x2, 0x5b8, 0x5b9, 0x9, 0x18, 0x2, 0x2, 0x5b9, 0x5bb, 
       0x5, 0x1b6, 0xdc, 0x2, 0x5ba, 0x5bc, 0x5, 0x96, 0x4c, 0x2, 0x5bb, 
       0x5ba, 0x3, 0x2, 0x2, 0x2, 0x5bb, 0x5bc, 0x3, 0x2, 0x2, 0x2, 0x5bc, 
       0x5be, 0x3, 0x2, 0x2, 0x2, 0x5bd, 0x5b0, 0x3, 0x2, 0x2, 0x2, 0x5bd, 
       0x5b1, 0x3, 0x2, 0x2, 0x2, 0x5bd, 0x5b8, 0x3, 0x2, 0x2, 0x2, 0x5be, 
       0x8d, 0x3, 0x2, 0x2, 0x2, 0x5bf, 0x5c7, 0x7, 0xc, 0x2, 0x2, 0x5c0, 
       0x5c3, 0x7, 0x3d, 0x2, 0x2, 0x5c1, 0x5c2, 0x7, 0xcd, 0x2, 0x2, 0x5c2, 
       0x5c4, 0x7, 0xe7, 0x2, 0x2, 0x5c3, 0x5c1, 0x3, 0x2, 0x2, 0x2, 0x5c3, 
       0x5c4, 0x3, 0x2, 0x2, 0x2, 0x5c4, 0x5c7, 0x3, 0x2, 0x2, 0x2, 0x5c5, 
       0x5c7, 0x7, 0xe7, 0x2, 0x2, 0x5c6, 0x5bf, 0x3, 0x2, 0x2, 0x2, 0x5c6, 
       0x5c0, 0x3, 0x2, 0x2, 0x2, 0x5c6, 0x5c5, 0x3, 0x2, 0x2, 0x2, 0x5c6, 
       0x5c7, 0x3, 0x2, 0x2, 0x2, 0x5c7, 0x5c8, 0x3, 0x2, 0x2, 0x2, 0x5c8, 
       0x5c9, 0x7, 0xd4, 0x2, 0x2, 0x5c9, 0x5ca, 0x7, 0x1e, 0x2, 0x2, 0x5ca, 
       0x5cb, 0x5, 0x1b6, 0xdc, 0x2, 0x5cb, 0x5cc, 0x9, 0x16, 0x2, 0x2, 
       0x5cc, 0x5cd, 0x5, 0x90, 0x49, 0x2, 0x5cd, 0x5d1, 0x7, 0x64, 0x2, 
       0x2, 0x5ce, 0x5cf, 0x5, 0x1b6, 0xdc, 0x2, 0x5cf, 0x5d0, 0x7, 0x16e, 
       0x2, 0x2, 0x5d0, 0x5d2, 0x3, 0x2, 0x2, 0x2, 0x5d1, 0x5ce, 0x3, 0x2, 
       0x2, 0x2, 0x5d1, 0x5d2, 0x3, 0x2, 0x2, 0x2, 0x5d2, 0x8f, 0x3, 0x2, 
       0x2, 0x2, 0x5d3, 0x5d4, 0x5, 0x92, 0x4a, 0x2, 0x5d4, 0x5da, 0x7, 
       0x16e, 0x2, 0x2, 0x5d5, 0x5d6, 0x5, 0x92, 0x4a, 0x2, 0x5d6, 0x5d7, 
       0x7, 0x16e, 0x2, 0x2, 0x5d7, 0x5d9, 0x3, 0x2, 0x2, 0x2, 0x5d8, 0x5d5, 
       0x3, 0x2, 0x2, 0x2, 0x5d9, 0x5dc, 0x3, 0x2, 0x2, 0x2, 0x5da, 0x5d8, 
       0x3, 0x2, 0x2, 0x2, 0x5da, 0x5db, 0x3, 0x2, 0x2, 0x2, 0x5db, 0x91, 
       0x3, 0x2, 0x2, 0x2, 0x5dc, 0x5da, 0x3, 0x2, 0x2, 0x2, 0x5dd, 0x5e1, 
       0x5, 0x34, 0x1b, 0x2, 0x5de, 0x5e1, 0x5, 0x84, 0x43, 0x2, 0x5df, 
       0x5e1, 0x5, 0x94, 0x4b, 0x2, 0x5e0, 0x5dd, 0x3, 0x2, 0x2, 0x2, 0x5e0, 
       0x5de, 0x3, 0x2, 0x2, 0x2, 0x5e0, 0x5df, 0x3, 0x2, 0x2, 0x2, 0x5e1, 
       0x93, 0x3, 0x2, 0x2, 0x2, 0x5e2, 0x5ea, 0x7, 0xc, 0x2, 0x2, 0x5e3, 
       0x5e6, 0x7, 0x3d, 0x2, 0x2, 0x5e4, 0x5e5, 0x7, 0xcd, 0x2, 0x2, 0x5e5, 
       0x5e7, 0x7, 0xe7, 0x2, 0x2, 0x5e6, 0x5e4, 0x3, 0x2, 0x2, 0x2, 0x5e6, 
       0x5e7, 0x3, 0x2, 0x2, 0x2, 0x5e7, 0x5ea, 0x3, 0x2, 0x2, 0x2, 0x5e8, 
       0x5ea, 0x7, 0xe7, 0x2, 0x2, 0x5e9, 0x5e2, 0x3, 0x2, 0x2, 0x2, 0x5e9, 
       0x5e3, 0x3, 0x2, 0x2, 0x2, 0x5e9, 0x5e8, 0x3, 0x2, 0x2, 0x2, 0x5e9, 
       0x5ea, 0x3, 0x2, 0x2, 0x2, 0x5ea, 0x5eb, 0x3, 0x2, 0x2, 0x2, 0x5eb, 
       0x5ec, 0x9, 0x18, 0x2, 0x2, 0x5ec, 0x5ee, 0x5, 0x1b6, 0xdc, 0x2, 
       0x5ed, 0x5ef, 0x5, 0x96, 0x4c, 0x2, 0x5ee, 0x5ed, 0x3, 0x2, 0x2, 
       0x2, 0x5ee, 0x5ef, 0x3, 0x2, 0x2, 0x2, 0x5ef, 0x5f1, 0x3, 0x2, 0x2, 
       0x2, 0x5f0, 0x5f2, 0x5, 0x9a, 0x4e, 0x2, 0x5f1, 0x5f0, 0x3, 0x2, 
       0x2, 0x2, 0x5f1, 0x5f2, 0x3, 0x2, 0x2, 0x2, 0x5f2, 0x5f4, 0x3, 0x2, 
       0x2, 0x2, 0x5f3, 0x5f5, 0x9, 0x16, 0x2, 0x2, 0x5f4, 0x5f3, 0x3, 0x2, 
       0x2, 0x2, 0x5f4, 0x5f5, 0x3, 0x2, 0x2, 0x2, 0x5f5, 0x5f7, 0x3, 0x2, 
       0x2, 0x2, 0x5f6, 0x5f8, 0x5, 0x32, 0x1a, 0x2, 0x5f7, 0x5f6, 0x3, 
       0x2, 0x2, 0x2, 0x5f7, 0x5f8, 0x3, 0x2, 0x2, 0x2, 0x5f8, 0x5fa, 0x3, 
       0x2, 0x2, 0x2, 0x5f9, 0x5fb, 0x5, 0x114, 0x8b, 0x2, 0x5fa, 0x5f9, 
       0x3, 0x2, 0x2, 0x2, 0x5fa, 0x5fb, 0x3, 0x2, 0x2, 0x2, 0x5fb, 0x5fc, 
       0x3, 0x2, 0x2, 0x2, 0x5fc, 0x600, 0x5, 0xc, 0x7, 0x2, 0x5fd, 0x5fe, 
       0x5, 0x1b6, 0xdc, 0x2, 0x5fe, 0x5ff, 0x7, 0x16e, 0x2, 0x2, 0x5ff, 
       0x601, 0x3, 0x2, 0x2, 0x2, 0x600, 0x5fd, 0x3, 0x2, 0x2, 0x2, 0x600, 
       0x601, 0x3, 0x2, 0x2, 0x2, 0x601, 0x95, 0x3, 0x2, 0x2, 0x2, 0x602, 
       0x603, 0x7, 0x169, 0x2, 0x2, 0x603, 0x619, 0x7, 0x16c, 0x2, 0x2, 
       0x604, 0x605, 0x7, 0x169, 0x2, 0x2, 0x605, 0x60a, 0x5, 0x98, 0x4d, 
       0x2, 0x606, 0x607, 0x7, 0x15b, 0x2, 0x2, 0x607, 0x609, 0x5, 0x98, 
       0x4d, 0x2, 0x608, 0x606, 0x3, 0x2, 0x2, 0x2, 0x609, 0x60c, 0x3, 0x2, 
       0x2, 0x2, 0x60a, 0x608, 0x3, 0x2, 0x2, 0x2, 0x60a, 0x60b, 0x3, 0x2, 
       0x2, 0x2, 0x60b, 0x60d, 0x3, 0x2, 0x2, 0x2, 0x60c, 0x60a, 0x3, 0x2, 
       0x2, 0x2, 0x60d, 0x60e, 0x7, 0x16c, 0x2, 0x2, 0x60e, 0x619, 0x3, 
       0x2, 0x2, 0x2, 0x60f, 0x610, 0x6, 0x4c, 0x4, 0x2, 0x610, 0x615, 0x5, 
       0x98, 0x4d, 0x2, 0x611, 0x612, 0x7, 0x15b, 0x2, 0x2, 0x612, 0x614, 
       0x5, 0x98, 0x4d, 0x2, 0x613, 0x611, 0x3, 0x2, 0x2, 0x2, 0x614, 0x617, 
       0x3, 0x2, 0x2, 0x2, 0x615, 0x613, 0x3, 0x2, 0x2, 0x2, 0x615, 0x616, 
       0x3, 0x2, 0x2, 0x2, 0x616, 0x619, 0x3, 0x2, 0x2, 0x2, 0x617, 0x615, 
       0x3, 0x2, 0x2, 0x2, 0x618, 0x602, 0x3, 0x2, 0x2, 0x2, 0x618, 0x604, 
       0x3, 0x2, 0x2, 0x2, 0x618, 0x60f, 0x3, 0x2, 0x2, 0x2, 0x619, 0x97, 
       0x3, 0x2, 0x2, 0x2, 0x61a, 0x620, 0x7, 0x8b, 0x2, 0x2, 0x61b, 0x620, 
       0x7, 0xcf, 0x2, 0x2, 0x61c, 0x620, 0x7, 0x90, 0x2, 0x2, 0x61d, 0x61e, 
       0x7, 0x8b, 0x2, 0x2, 0x61e, 0x620, 0x7, 0xcf, 0x2, 0x2, 0x61f, 0x61a, 
       0x3, 0x2, 0x2, 0x2, 0x61f, 0x61b, 0x3, 0x2, 0x2, 0x2, 0x61f, 0x61c, 
       0x3, 0x2, 0x2, 0x2, 0x61f, 0x61d, 0x3, 0x2, 0x2, 0x2, 0x61f, 0x620, 
       0x3, 0x2, 0x2, 0x2, 0x620, 0x621, 0x3, 0x2, 0x2, 0x2, 0x621, 0x622, 
       0x5, 0x1b6, 0xdc, 0x2, 0x622, 0x624, 0x5, 0x78, 0x3d, 0x2, 0x623, 
       0x625, 0x5, 0x7a, 0x3e, 0x2, 0x624, 0x623, 0x3, 0x2, 0x2, 0x2, 0x624, 
       0x625, 0x3, 0x2, 0x2, 0x2, 0x625, 0x629, 0x3, 0x2, 0x2, 0x2, 0x626, 
       0x628, 0x5, 0x7c, 0x3f, 0x2, 0x627, 0x626, 0x3, 0x2, 0x2, 0x2, 0x628, 
       0x62b, 0x3, 0x2, 0x2, 0x2, 0x629, 0x627, 0x3, 0x2, 0x2, 0x2, 0x629, 
       0x62a, 0x3, 0x2, 0x2, 0x2, 0x62a, 0x62d, 0x3, 0x2, 0x2, 0x2, 0x62b, 
       0x629, 0x3, 0x2, 0x2, 0x2, 0x62c, 0x62e, 0x5, 0x7e, 0x40, 0x2, 0x62d, 
       0x62c, 0x3, 0x2, 0x2, 0x2, 0x62d, 0x62e, 0x3, 0x2, 0x2, 0x2, 0x62e, 
       0x645, 0x3, 0x2, 0x2, 0x2, 0x62f, 0x635, 0x5, 0x1b6, 0xdc, 0x2, 0x630, 
       0x636, 0x7, 0x8b, 0x2, 0x2, 0x631, 0x636, 0x7, 0xcf, 0x2, 0x2, 0x632, 
       0x636, 0x7, 0x90, 0x2, 0x2, 0x633, 0x634, 0x7, 0x8b, 0x2, 0x2, 0x634, 
       0x636, 0x7, 0xcf, 0x2, 0x2, 0x635, 0x630, 0x3, 0x2, 0x2, 0x2, 0x635, 
       0x631, 0x3, 0x2, 0x2, 0x2, 0x635, 0x632, 0x3, 0x2, 0x2, 0x2, 0x635, 
       0x633, 0x3, 0x2, 0x2, 0x2, 0x635, 0x636, 0x3, 0x2, 0x2, 0x2, 0x636, 
       0x637, 0x3, 0x2, 0x2, 0x2, 0x637, 0x639, 0x5, 0x78, 0x3d, 0x2, 0x638, 
       0x63a, 0x5, 0x7a, 0x3e, 0x2, 0x639, 0x638, 0x3, 0x2, 0x2, 0x2, 0x639, 
       0x63a, 0x3, 0x2, 0x2, 0x2, 0x63a, 0x63e, 0x3, 0x2, 0x2, 0x2, 0x63b, 
       0x63d, 0x5, 0x7c, 0x3f, 0x2, 0x63c, 0x63b, 0x3, 0x2, 0x2, 0x2, 0x63d, 
       0x640, 0x3, 0x2, 0x2, 0x2, 0x63e, 0x63c, 0x3, 0x2, 0x2, 0x2, 0x63e, 
       0x63f, 0x3, 0x2, 0x2, 0x2, 0x63f, 0x642, 0x3, 0x2, 0x2, 0x2, 0x640, 
       0x63e, 0x3, 0x2, 0x2, 0x2, 0x641, 0x643, 0x5, 0x7e, 0x40, 0x2, 0x642, 
       0x641, 0x3, 0x2, 0x2, 0x2, 0x642, 0x643, 0x3, 0x2, 0x2, 0x2, 0x643, 
       0x645, 0x3, 0x2, 0x2, 0x2, 0x644, 0x61f, 0x3, 0x2, 0x2, 0x2, 0x644, 
       0x62f, 0x3, 0x2, 0x2, 0x2, 0x645, 0x99, 0x3, 0x2, 0x2, 0x2, 0x646, 
       0x648, 0x5, 0x9c, 0x4f, 0x2, 0x647, 0x646, 0x3, 0x2, 0x2, 0x2, 0x648, 
       0x649, 0x3, 0x2, 0x2, 0x2, 0x649, 0x647, 0x3, 0x2, 0x2, 0x2, 0x649, 
       0x64a, 0x3, 0x2, 0x2, 0x2, 0x64a, 0x9b, 0x3, 0x2, 0x2, 0x2, 0x64b, 
       0x64c, 0x7, 0xa2, 0x2, 0x2, 0x64c, 0x657, 0x7, 0x10d, 0x2, 0x2, 0x64d, 
       0x64e, 0x7, 0x10d, 0x2, 0x2, 0x64e, 0x64f, 0x7, 0xfe, 0x2, 0x2, 0x64f, 
       0x657, 0x9, 0x19, 0x2, 0x2, 0x650, 0x652, 0x7, 0x5f, 0x2, 0x2, 0x651, 
       0x650, 0x3, 0x2, 0x2, 0x2, 0x651, 0x652, 0x3, 0x2, 0x2, 0x2, 0x652, 
       0x653, 0x3, 0x2, 0x2, 0x2, 0x653, 0x654, 0x7, 0xea, 0x2, 0x2, 0x654, 
       0x655, 0x7, 0x105, 0x2, 0x2, 0x655, 0x657, 0x7, 0x173, 0x2, 0x2, 
       0x656, 0x64b, 0x3, 0x2, 0x2, 0x2, 0x656, 0x64d, 0x3, 0x2, 0x2, 0x2, 
       0x656, 0x651, 0x3, 0x2, 0x2, 0x2, 0x657, 0x9d, 0x3, 0x2, 0x2, 0x2, 
       0x658, 0x659, 0x7, 0x5e, 0x2, 0x2, 0x659, 0x65c, 0x7, 0x11c, 0x2, 
       0x2, 0x65a, 0x65b, 0x7, 0x88, 0x2, 0x2, 0x65b, 0x65d, 0x7, 0x6c, 
       0x2, 0x2, 0x65c, 0x65a, 0x3, 0x2, 0x2, 0x2, 0x65c, 0x65d, 0x3, 0x2, 
       0x2, 0x2, 0x65d, 0x65e, 0x3, 0x2, 0x2, 0x2, 0x65e, 0x667, 0x5, 0x148, 
       0xa5, 0x2, 0x65f, 0x660, 0x7, 0x5e, 0x2, 0x2, 0x660, 0x663, 0x9, 
       0x15, 0x2, 0x2, 0x661, 0x662, 0x7, 0x88, 0x2, 0x2, 0x662, 0x664, 
       0x7, 0x6c, 0x2, 0x2, 0x663, 0x661, 0x3, 0x2, 0x2, 0x2, 0x663, 0x664, 
       0x3, 0x2, 0x2, 0x2, 0x664, 0x665, 0x3, 0x2, 0x2, 0x2, 0x665, 0x667, 
       0x5, 0x17e, 0xc0, 0x2, 0x666, 0x658, 0x3, 0x2, 0x2, 0x2, 0x666, 0x65f, 
       0x3, 0x2, 0x2, 0x2, 0x667, 0x9f, 0x3, 0x2, 0x2, 0x2, 0x668, 0x669, 
       0x7, 0x64, 0x2, 0x2, 0x669, 0x66a, 0x7, 0x127, 0x2, 0x2, 0x66a, 0xa1, 
       0x3, 0x2, 0x2, 0x2, 0x66b, 0x66d, 0x9, 0x1a, 0x2, 0x2, 0x66c, 0x66e, 
       0x7, 0x8a, 0x2, 0x2, 0x66d, 0x66c, 0x3, 0x2, 0x2, 0x2, 0x66d, 0x66e, 
       0x3, 0x2, 0x2, 0x2, 0x66e, 0x66f, 0x3, 0x2, 0x2, 0x2, 0x66f, 0x675, 
       0x5, 0x17e, 0xc0, 0x2, 0x670, 0x671, 0x7, 0x169, 0x2, 0x2, 0x671, 
       0x672, 0x5, 0x19e, 0xd0, 0x2, 0x672, 0x673, 0x7, 0x16c, 0x2, 0x2, 
       0x673, 0x676, 0x3, 0x2, 0x2, 0x2, 0x674, 0x676, 0x5, 0x19e, 0xd0, 
       0x2, 0x675, 0x670, 0x3, 0x2, 0x2, 0x2, 0x675, 0x674, 0x3, 0x2, 0x2, 
       0x2, 0x675, 0x676, 0x3, 0x2, 0x2, 0x2, 0x676, 0x680, 0x3, 0x2, 0x2, 
       0x2, 0x677, 0x678, 0x7, 0x99, 0x2, 0x2, 0x678, 0x67d, 0x7, 0x170, 
       0x2, 0x2, 0x679, 0x67a, 0x7, 0x15b, 0x2, 0x2, 0x67a, 0x67c, 0x7, 
       0x170, 0x2, 0x2, 0x67b, 0x679, 0x3, 0x2, 0x2, 0x2, 0x67c, 0x67f, 
       0x3, 0x2, 0x2, 0x2, 0x67d, 0x67b, 0x3, 0x2, 0x2, 0x2, 0x67d, 0x67e, 
       0x3, 0x2, 0x2, 0x2, 0x67e, 0x681, 0x3, 0x2, 0x2, 0x2, 0x67f, 0x67d, 
       0x3, 0x2, 0x2, 0x2, 0x680, 0x677, 0x3, 0x2, 0x2, 0x2, 0x680, 0x681, 
       0x3, 0x2, 0x2, 0x2, 0x681, 0x683, 0x3, 0x2, 0x2, 0x2, 0x682, 0x684, 
       0x5, 0x116, 0x8c, 0x2, 0x683, 0x682, 0x3, 0x2, 0x2, 0x2, 0x683, 0x684, 
       0x3, 0x2, 0x2, 0x2, 0x684, 0xa3, 0x3, 0x2, 0x2, 0x2, 0x685, 0x689, 
       0x5, 0xa6, 0x54, 0x2, 0x686, 0x689, 0x5, 0xa8, 0x55, 0x2, 0x687, 
       0x689, 0x5, 0xaa, 0x56, 0x2, 0x688, 0x685, 0x3, 0x2, 0x2, 0x2, 0x688, 
       0x686, 0x3, 0x2, 0x2, 0x2, 0x688, 0x687, 0x3, 0x2, 0x2, 0x2, 0x689, 
       0xa5, 0x3, 0x2, 0x2, 0x2, 0x68a, 0x68b, 0x7, 0x88, 0x2, 0x2, 0x68b, 
       0x68c, 0x5, 0x16e, 0xb8, 0x2, 0x68c, 0x68d, 0x7, 0x121, 0x2, 0x2, 
       0x68d, 0x691, 0x5, 0x4, 0x3, 0x2, 0x68e, 0x690, 0x5, 0xac, 0x57, 
       0x2, 0x68f, 0x68e, 0x3, 0x2, 0x2, 0x2, 0x690, 0x693, 0x3, 0x2, 0x2, 
       0x2, 0x691, 0x68f, 0x3, 0x2, 0x2, 0x2, 0x691, 0x692, 0x3, 0x2, 0x2, 
       0x2, 0x692, 0x695, 0x3, 0x2, 0x2, 0x2, 0x693, 0x691, 0x3, 0x2, 0x2, 
       0x2, 0x694, 0x696, 0x5, 0xae, 0x58, 0x2, 0x695, 0x694, 0x3, 0x2, 
       0x2, 0x2, 0x695, 0x696, 0x3, 0x2, 0x2, 0x2, 0x696, 0x697, 0x3, 0x2, 
       0x2, 0x2, 0x697, 0x698, 0x7, 0x64, 0x2, 0x2, 0x698, 0x699, 0x7, 0x88, 
       0x2, 0x2, 0x699, 0xa7, 0x3, 0x2, 0x2, 0x2, 0x69a, 0x69b, 0x7, 0x88, 
       0x2, 0x2, 0x69b, 0x69c, 0x5, 0x16e, 0xb8, 0x2, 0x69c, 0x69f, 0x5, 
       0x8, 0x5, 0x2, 0x69d, 0x69e, 0x7, 0x60, 0x2, 0x2, 0x69e, 0x6a0, 0x5, 
       0x8, 0x5, 0x2, 0x69f, 0x69d, 0x3, 0x2, 0x2, 0x2, 0x69f, 0x6a0, 0x3, 
       0x2, 0x2, 0x2, 0x6a0, 0xa9, 0x3, 0x2, 0x2, 0x2, 0x6a1, 0x6a2, 0x7, 
       0x6, 0x2, 0x2, 0x6a2, 0x6a3, 0x7, 0x88, 0x2, 0x2, 0x6a3, 0x6a4, 0x5, 
       0x16e, 0xb8, 0x2, 0x6a4, 0x6a5, 0x7, 0x121, 0x2, 0x2, 0x6a5, 0x6a6, 
       0x5, 0x8, 0x5, 0x2, 0x6a6, 0xab, 0x3, 0x2, 0x2, 0x2, 0x6a7, 0x6a8, 
       0x9, 0x1b, 0x2, 0x2, 0x6a8, 0x6a9, 0x5, 0x16e, 0xb8, 0x2, 0x6a9, 
       0x6aa, 0x7, 0x121, 0x2, 0x2, 0x6aa, 0x6ab, 0x5, 0x4, 0x3, 0x2, 0x6ab, 
       0xad, 0x3, 0x2, 0x2, 0x2, 0x6ac, 0x6ad, 0x7, 0x60, 0x2, 0x2, 0x6ad, 
       0x6ae, 0x5, 0x4, 0x3, 0x2, 0x6ae, 0xaf, 0x3, 0x2, 0x2, 0x2, 0x6af, 
       0x6b2, 0x7, 0x8c, 0x2, 0x2, 0x6b0, 0x6b3, 0x5, 0x1b0, 0xd9, 0x2, 
       0x6b1, 0x6b3, 0x5, 0x17e, 0xc0, 0x2, 0x6b2, 0x6b0, 0x3, 0x2, 0x2, 
       0x2, 0x6b2, 0x6b1, 0x3, 0x2, 0x2, 0x2, 0x6b3, 0xb1, 0x3, 0x2, 0x2, 
       0x2, 0x6b4, 0x6bb, 0x7, 0x91, 0x2, 0x2, 0x6b5, 0x6b6, 0x7, 0xd2, 
       0x2, 0x2, 0x6b6, 0x6bc, 0x7, 0x11c, 0x2, 0x2, 0x6b7, 0x6b9, 0x7, 
       0x99, 0x2, 0x2, 0x6b8, 0x6ba, 0x7, 0x11c, 0x2, 0x2, 0x6b9, 0x6b8, 
       0x3, 0x2, 0x2, 0x2, 0x6b9, 0x6ba, 0x3, 0x2, 0x2, 0x2, 0x6ba, 0x6bc, 
       0x3, 0x2, 0x2, 0x2, 0x6bb, 0x6b5, 0x3, 0x2, 0x2, 0x2, 0x6bb, 0x6b7, 
       0x3, 0x2, 0x2, 0x2, 0x6bc, 0x6bd, 0x3, 0x2, 0x2, 0x2, 0x6bd, 0x6bf, 
       0x5, 0x148, 0xa5, 0x2, 0x6be, 0x6c0, 0x5, 0xb4, 0x5b, 0x2, 0x6bf, 
       0x6be, 0x3, 0x2, 0x2, 0x2, 0x6bf, 0x6c0, 0x3, 0x2, 0x2, 0x2, 0x6c0, 
       0x6c3, 0x3, 0x2, 0x2, 0x2, 0x6c1, 0x6c4, 0x5, 0x118, 0x8d, 0x2, 0x6c2, 
       0x6c4, 0x5, 0xb6, 0x5c, 0x2, 0x6c3, 0x6c1, 0x3, 0x2, 0x2, 0x2, 0x6c3, 
       0x6c2, 0x3, 0x2, 0x2, 0x2, 0x6c4, 0xb3, 0x3, 0x2, 0x2, 0x2, 0x6c5, 
       0x6c6, 0x7, 0x169, 0x2, 0x2, 0x6c6, 0x6cb, 0x5, 0x1b6, 0xdc, 0x2, 
       0x6c7, 0x6c8, 0x7, 0x15b, 0x2, 0x2, 0x6c8, 0x6ca, 0x5, 0x1b6, 0xdc, 
       0x2, 0x6c9, 0x6c7, 0x3, 0x2, 0x2, 0x2, 0x6ca, 0x6cd, 0x3, 0x2, 0x2, 
       0x2, 0x6cb, 0x6c9, 0x3, 0x2, 0x2, 0x2, 0x6cb, 0x6cc, 0x3, 0x2, 0x2, 
       0x2, 0x6cc, 0x6ce, 0x3, 0x2, 0x2, 0x2, 0x6cd, 0x6cb, 0x3, 0x2, 0x2, 
       0x2, 0x6ce, 0x6cf, 0x7, 0x16c, 0x2, 0x2, 0x6cf, 0xb5, 0x3, 0x2, 0x2, 
       0x2, 0x6d0, 0x6d1, 0x7, 0x132, 0x2, 0x2, 0x6d1, 0x6d6, 0x5, 0xb8, 
       0x5d, 0x2, 0x6d2, 0x6d3, 0x7, 0x15b, 0x2, 0x2, 0x6d3, 0x6d5, 0x5, 
       0xb8, 0x5d, 0x2, 0x6d4, 0x6d2, 0x3, 0x2, 0x2, 0x2, 0x6d5, 0x6d8, 
       0x3, 0x2, 0x2, 0x2, 0x6d6, 0x6d4, 0x3, 0x2, 0x2, 0x2, 0x6d6, 0x6d7, 
       0x3, 0x2, 0x2, 0x2, 0x6d7, 0xb7, 0x3, 0x2, 0x2, 0x2, 0x6d8, 0x6d6, 
       0x3, 0x2, 0x2, 0x2, 0x6d9, 0x6da, 0x7, 0x169, 0x2, 0x2, 0x6da, 0x6df, 
       0x5, 0x17e, 0xc0, 0x2, 0x6db, 0x6dc, 0x7, 0x15b, 0x2, 0x2, 0x6dc, 
       0x6de, 0x5, 0x17e, 0xc0, 0x2, 0x6dd, 0x6db, 0x3, 0x2, 0x2, 0x2, 0x6de, 
       0x6e1, 0x3, 0x2, 0x2, 0x2, 0x6df, 0x6dd, 0x3, 0x2, 0x2, 0x2, 0x6df, 
       0x6e0, 0x3, 0x2, 0x2, 0x2, 0x6e0, 0x6e2, 0x3, 0x2, 0x2, 0x2, 0x6e1, 
       0x6df, 0x3, 0x2, 0x2, 0x2, 0x6e2, 0x6e3, 0x7, 0x16c, 0x2, 0x2, 0x6e3, 
       0xb9, 0x3, 0x2, 0x2, 0x2, 0x6e4, 0x6e5, 0x7, 0x91, 0x2, 0x2, 0x6e5, 
       0x6e7, 0x7, 0xd2, 0x2, 0x2, 0x6e6, 0x6e8, 0x7, 0xa8, 0x2, 0x2, 0x6e7, 
       0x6e6, 0x3, 0x2, 0x2, 0x2, 0x6e7, 0x6e8, 0x3, 0x2, 0x2, 0x2, 0x6e8, 
       0x6e9, 0x3, 0x2, 0x2, 0x2, 0x6e9, 0x6ea, 0x7, 0x59, 0x2, 0x2, 0x6ea, 
       0x6eb, 0x5, 0x1a4, 0xd3, 0x2, 0x6eb, 0x6ec, 0x5, 0x1a2, 0xd2, 0x2, 
       0x6ec, 0xbb, 0x3, 0x2, 0x2, 0x2, 0x6ed, 0x6ef, 0x7, 0x6d, 0x2, 0x2, 
       0x6ee, 0x6f0, 0x7, 0x170, 0x2, 0x2, 0x6ef, 0x6ee, 0x3, 0x2, 0x2, 
       0x2, 0x6ef, 0x6f0, 0x3, 0x2, 0x2, 0x2, 0x6f0, 0x6f3, 0x3, 0x2, 0x2, 
       0x2, 0x6f1, 0x6f2, 0x7, 0x138, 0x2, 0x2, 0x6f2, 0x6f4, 0x5, 0x16e, 
       0xb8, 0x2, 0x6f3, 0x6f1, 0x3, 0x2, 0x2, 0x2, 0x6f3, 0x6f4, 0x3, 0x2, 
       0x2, 0x2, 0x6f4, 0xbd, 0x3, 0x2, 0x2, 0x2, 0x6f5, 0x6f6, 0x7, 0x7c, 
       0x2, 0x2, 0x6f6, 0x6f7, 0x7, 0x57, 0x2, 0x2, 0x6f7, 0x6f8, 0x5, 0xc0, 
       0x61, 0x2, 0x6f8, 0xbf, 0x3, 0x2, 0x2, 0x2, 0x6f9, 0x6fc, 0x5, 0xc2, 
       0x62, 0x2, 0x6fa, 0x6fc, 0x5, 0xc4, 0x63, 0x2, 0x6fb, 0x6f9, 0x3, 
       0x2, 0x2, 0x2, 0x6fb, 0x6fa, 0x3, 0x2, 0x2, 0x2, 0x6fc, 0xc1, 0x3, 
       0x2, 0x2, 0x2, 0x6fd, 0x6fe, 0x7, 0x6a, 0x2, 0x2, 0x6fe, 0x6ff, 0x7, 
       0x173, 0x2, 0x2, 0x6ff, 0x700, 0x5, 0x1b6, 0xdc, 0x2, 0x700, 0x701, 
       0x7, 0x15f, 0x2, 0x2, 0x701, 0x702, 0x7, 0xb6, 0x2, 0x2, 0x702, 0xc3, 
       0x3, 0x2, 0x2, 0x2, 0x703, 0x704, 0x5, 0x1b6, 0xdc, 0x2, 0x704, 0x705, 
       0x7, 0x15f, 0x2, 0x2, 0x705, 0x706, 0x7, 0xf6, 0x2, 0x2, 0x706, 0xc5, 
       0x3, 0x2, 0x2, 0x2, 0x707, 0x708, 0x7, 0x7f, 0x2, 0x2, 0x708, 0x70d, 
       0x5, 0xc8, 0x65, 0x2, 0x709, 0x70a, 0x7, 0x15b, 0x2, 0x2, 0x70a, 
       0x70c, 0x5, 0xc8, 0x65, 0x2, 0x70b, 0x709, 0x3, 0x2, 0x2, 0x2, 0x70c, 
       0x70f, 0x3, 0x2, 0x2, 0x2, 0x70d, 0x70b, 0x3, 0x2, 0x2, 0x2, 0x70d, 
       0x70e, 0x3, 0x2, 0x2, 0x2, 0x70e, 0x710, 0x3, 0x2, 0x2, 0x2, 0x70f, 
       0x70d, 0x3, 0x2, 0x2, 0x2, 0x710, 0x711, 0x7, 0x125, 0x2, 0x2, 0x711, 
       0x712, 0x7, 0xf1, 0x2, 0x2, 0x712, 0x713, 0x5, 0x1b6, 0xdc, 0x2, 
       0x713, 0xc7, 0x3, 0x2, 0x2, 0x2, 0x714, 0x715, 0x7, 0x69, 0x2, 0x2, 
       0x715, 0x716, 0x7, 0xca, 0x2, 0x2, 0x716, 0x717, 0x7, 0xde, 0x2, 
       0x2, 0x717, 0x718, 0x5, 0x1b6, 0xdc, 0x2, 0x718, 0xc9, 0x3, 0x2, 
       0x2, 0x2, 0x719, 0x71b, 0x7, 0xa3, 0x2, 0x2, 0x71a, 0x71c, 0x7, 0x170, 
       0x2, 0x2, 0x71b, 0x71a, 0x3, 0x2, 0x2, 0x2, 0x71b, 0x71c, 0x3, 0x2, 
       0x2, 0x2, 0x71c, 0xcb, 0x3, 0x2, 0x2, 0x2, 0x71d, 0x71e, 0x7, 0xb1, 
       0x2, 0x2, 0x71e, 0x71f, 0x7, 0xc8, 0x2, 0x2, 0x71f, 0x722, 0x5, 0x17e, 
       0xc0, 0x2, 0x720, 0x721, 0x7, 0x125, 0x2, 0x2, 0x721, 0x723, 0x5, 
       0x17e, 0xc0, 0x2, 0x722, 0x720, 0x3, 0x2, 0x2, 0x2, 0x722, 0x723, 
       0x3, 0x2, 0x2, 0x2, 0x723, 0x726, 0x3, 0x2, 0x2, 0x2, 0x724, 0x725, 
       0x7, 0x13, 0x2, 0x2, 0x725, 0x727, 0x5, 0x17e, 0xc0, 0x2, 0x726, 
       0x724, 0x3, 0x2, 0x2, 0x2, 0x726, 0x727, 0x3, 0x2, 0x2, 0x2, 0x727, 
       0xcd, 0x3, 0x2, 0x2, 0x2, 0x728, 0x729, 0x7, 0xcc, 0x2, 0x2, 0x729, 
       0x72f, 0x7, 0x170, 0x2, 0x2, 0x72a, 0x72d, 0x7, 0x75, 0x2, 0x2, 0x72b, 
       0x72e, 0x5, 0x118, 0x8d, 0x2, 0x72c, 0x72e, 0x5, 0x17e, 0xc0, 0x2, 
       0x72d, 0x72b, 0x3, 0x2, 0x2, 0x2, 0x72d, 0x72c, 0x3, 0x2, 0x2, 0x2, 
       0x72e, 0x730, 0x3, 0x2, 0x2, 0x2, 0x72f, 0x72a, 0x3, 0x2, 0x2, 0x2, 
       0x72f, 0x730, 0x3, 0x2, 0x2, 0x2, 0x730, 0xcf, 0x3, 0x2, 0x2, 0x2, 
       0x731, 0x733, 0x7, 0x70, 0x2, 0x2, 0x732, 0x734, 0x7, 0x79, 0x2, 
       0x2, 0x733, 0x732, 0x3, 0x2, 0x2, 0x2, 0x733, 0x734, 0x3, 0x2, 0x2, 
       0x2, 0x734, 0x735, 0x3, 0x2, 0x2, 0x2, 0x735, 0x736, 0x7, 0x170, 
       0x2, 0x2, 0x736, 0x737, 0x7, 0x99, 0x2, 0x2, 0x737, 0x73c, 0x7, 0x170, 
       0x2, 0x2, 0x738, 0x739, 0x7, 0x15b, 0x2, 0x2, 0x739, 0x73b, 0x7, 
       0x170, 0x2, 0x2, 0x73a, 0x738, 0x3, 0x2, 0x2, 0x2, 0x73b, 0x73e, 
       0x3, 0x2, 0x2, 0x2, 0x73c, 0x73a, 0x3, 0x2, 0x2, 0x2, 0x73c, 0x73d, 
       0x3, 0x2, 0x2, 0x2, 0x73d, 0xd1, 0x3, 0x2, 0x2, 0x2, 0x73e, 0x73c, 
       0x3, 0x2, 0x2, 0x2, 0x73f, 0x740, 0x7, 0x2f, 0x2, 0x2, 0x740, 0x741, 
       0x9, 0x1c, 0x2, 0x2, 0x741, 0x742, 0x7, 0xca, 0x2, 0x2, 0x742, 0x744, 
       0x5, 0x148, 0xa5, 0x2, 0x743, 0x745, 0x5, 0xd4, 0x6b, 0x2, 0x744, 
       0x743, 0x3, 0x2, 0x2, 0x2, 0x744, 0x745, 0x3, 0x2, 0x2, 0x2, 0x745, 
       0xd3, 0x3, 0x2, 0x2, 0x2, 0x746, 0x747, 0x7, 0x31, 0x2, 0x2, 0x747, 
       0x748, 0x7, 0x169, 0x2, 0x2, 0x748, 0x74d, 0x5, 0x1b6, 0xdc, 0x2, 
       0x749, 0x74a, 0x7, 0x15b, 0x2, 0x2, 0x74a, 0x74c, 0x5, 0x1b6, 0xdc, 
       0x2, 0x74b, 0x749, 0x3, 0x2, 0x2, 0x2, 0x74c, 0x74f, 0x3, 0x2, 0x2, 
       0x2, 0x74d, 0x74b, 0x3, 0x2, 0x2, 0x2, 0x74d, 0x74e, 0x3, 0x2, 0x2, 
       0x2, 0x74e, 0x750, 0x3, 0x2, 0x2, 0x2, 0x74f, 0x74d, 0x3, 0x2, 0x2, 
       0x2, 0x750, 0x751, 0x7, 0x16c, 0x2, 0x2, 0x751, 0xd5, 0x3, 0x2, 0x2, 
       0x2, 0x752, 0x753, 0x7, 0x2c, 0x2, 0x2, 0x753, 0x754, 0x7, 0x170, 
       0x2, 0x2, 0x754, 0xd7, 0x3, 0x2, 0x2, 0x2, 0x755, 0x756, 0x7, 0x2e, 
       0x2, 0x2, 0x756, 0x757, 0x9, 0x1d, 0x2, 0x2, 0x757, 0x758, 0x5, 0xda, 
       0x6e, 0x2, 0x758, 0x759, 0x7, 0x15b, 0x2, 0x2, 0x759, 0x75a, 0x5, 
       0xda, 0x6e, 0x2, 0x75a, 0xd9, 0x3, 0x2, 0x2, 0x2, 0x75b, 0x75d, 0x5, 
       0x148, 0xa5, 0x2, 0x75c, 0x75e, 0x5, 0x14a, 0xa6, 0x2, 0x75d, 0x75c, 
       0x3, 0x2, 0x2, 0x2, 0x75d, 0x75e, 0x3, 0x2, 0x2, 0x2, 0x75e, 0x764, 
       0x3, 0x2, 0x2, 0x2, 0x75f, 0x760, 0x7, 0x169, 0x2, 0x2, 0x760, 0x761, 
       0x5, 0x118, 0x8d, 0x2, 0x761, 0x762, 0x7, 0x16c, 0x2, 0x2, 0x762, 
       0x764, 0x3, 0x2, 0x2, 0x2, 0x763, 0x75b, 0x3, 0x2, 0x2, 0x2, 0x763, 
       0x75f, 0x3, 0x2, 0x2, 0x2, 0x764, 0x767, 0x3, 0x2, 0x2, 0x2, 0x765, 
       0x766, 0x7, 0x13, 0x2, 0x2, 0x766, 0x768, 0x5, 0x1b6, 0xdc, 0x2, 
       0x767, 0x765, 0x3, 0x2, 0x2, 0x2, 0x767, 0x768, 0x3, 0x2, 0x2, 0x2, 
       0x768, 0xdb, 0x3, 0x2, 0x2, 0x2, 0x769, 0x76a, 0x7, 0x3a, 0x2, 0x2, 
       0x76a, 0x76b, 0x7, 0x79, 0x2, 0x2, 0x76b, 0x76c, 0x7, 0xa8, 0x2, 
       0x2, 0x76c, 0x771, 0x5, 0xe0, 0x71, 0x2, 0x76d, 0x76e, 0x7, 0x15b, 
       0x2, 0x2, 0x76e, 0x770, 0x5, 0xe0, 0x71, 0x2, 0x76f, 0x76d, 0x3, 
       0x2, 0x2, 0x2, 0x770, 0x773, 0x3, 0x2, 0x2, 0x2, 0x771, 0x76f, 0x3, 
       0x2, 0x2, 0x2, 0x771, 0x772, 0x3, 0x2, 0x2, 0x2, 0x772, 0x774, 0x3, 
       0x2, 0x2, 0x2, 0x773, 0x771, 0x3, 0x2, 0x2, 0x2, 0x774, 0x775, 0x7, 
       0x125, 0x2, 0x2, 0x775, 0x779, 0x5, 0xe2, 0x72, 0x2, 0x776, 0x778, 
       0x5, 0xe6, 0x74, 0x2, 0x777, 0x776, 0x3, 0x2, 0x2, 0x2, 0x778, 0x77b, 
       0x3, 0x2, 0x2, 0x2, 0x779, 0x777, 0x3, 0x2, 0x2, 0x2, 0x779, 0x77a, 
       0x3, 0x2, 0x2, 0x2, 0x77a, 0xdd, 0x3, 0x2, 0x2, 0x2, 0x77b, 0x779, 
       0x3, 0x2, 0x2, 0x2, 0x77c, 0x782, 0x7, 0x3a, 0x2, 0x2, 0x77d, 0x783, 
       0x5, 0x148, 0xa5, 0x2, 0x77e, 0x77f, 0x7, 0x169, 0x2, 0x2, 0x77f, 
       0x780, 0x5, 0x118, 0x8d, 0x2, 0x780, 0x781, 0x7, 0x16c, 0x2, 0x2, 
       0x781, 0x783, 0x3, 0x2, 0x2, 0x2, 0x782, 0x77d, 0x3, 0x2, 0x2, 0x2, 
       0x782, 0x77e, 0x3, 0x2, 0x2, 0x2, 0x783, 0x784, 0x3, 0x2, 0x2, 0x2, 
       0x784, 0x786, 0x7, 0x125, 0x2, 0x2, 0x785, 0x787, 0x7, 0x84, 0x2, 
       0x2, 0x786, 0x785, 0x3, 0x2, 0x2, 0x2, 0x786, 0x787, 0x3, 0x2, 0x2, 
       0x2, 0x787, 0x788, 0x3, 0x2, 0x2, 0x2, 0x788, 0x78c, 0x5, 0xe2, 0x72, 
       0x2, 0x789, 0x78b, 0x5, 0xe4, 0x73, 0x2, 0x78a, 0x789, 0x3, 0x2, 
       0x2, 0x2, 0x78b, 0x78e, 0x3, 0x2, 0x2, 0x2, 0x78c, 0x78a, 0x3, 0x2, 
       0x2, 0x2, 0x78c, 0x78d, 0x3, 0x2, 0x2, 0x2, 0x78d, 0xdf, 0x3, 0x2, 
       0x2, 0x2, 0x78e, 0x78c, 0x3, 0x2, 0x2, 0x2, 0x78f, 0x792, 0x5, 0x1b0, 
       0xd9, 0x2, 0x790, 0x792, 0x5, 0x17e, 0xc0, 0x2, 0x791, 0x78f, 0x3, 
       0x2, 0x2, 0x2, 0x791, 0x790, 0x3, 0x2, 0x2, 0x2, 0x792, 0xe1, 0x3, 
       0x2, 0x2, 0x2, 0x793, 0x796, 0x5, 0x1b0, 0xd9, 0x2, 0x794, 0x796, 
       0x5, 0x17e, 0xc0, 0x2, 0x795, 0x793, 0x3, 0x2, 0x2, 0x2, 0x795, 0x794, 
       0x3, 0x2, 0x2, 0x2, 0x796, 0xe3, 0x3, 0x2, 0x2, 0x2, 0x797, 0x798, 
       0x7, 0x13, 0x2, 0x2, 0x798, 0x7a0, 0x5, 0x1b6, 0xdc, 0x2, 0x799, 
       0x79a, 0x7, 0x16, 0x2, 0x2, 0x79a, 0x7a0, 0x5, 0x17e, 0xc0, 0x2, 
       0x79b, 0x79c, 0x7, 0x54, 0x2, 0x2, 0x79c, 0x7a0, 0x5, 0x17e, 0xc0, 
       0x2, 0x79d, 0x79e, 0x7, 0x10f, 0x2, 0x2, 0x79e, 0x7a0, 0x5, 0x1b6, 
       0xdc, 0x2, 0x79f, 0x797, 0x3, 0x2, 0x2, 0x2, 0x79f, 0x799, 0x3, 0x2, 
       0x2, 0x2, 0x79f, 0x79b, 0x3, 0x2, 0x2, 0x2, 0x79f, 0x79d, 0x3, 0x2, 
       0x2, 0x2, 0x7a0, 0xe5, 0x3, 0x2, 0x2, 0x2, 0x7a1, 0x7a2, 0x9, 0x1e, 
       0x2, 0x2, 0x7a2, 0xe7, 0x3, 0x2, 0x2, 0x2, 0x7a3, 0x7a5, 0x7, 0x34, 
       0x2, 0x2, 0x7a4, 0x7a6, 0x7, 0x13d, 0x2, 0x2, 0x7a5, 0x7a4, 0x3, 
       0x2, 0x2, 0x2, 0x7a5, 0x7a6, 0x3, 0x2, 0x2, 0x2, 0x7a6, 0xe9, 0x3, 
       0x2, 0x2, 0x2, 0x7a7, 0x7a9, 0x7, 0x3d, 0x2, 0x2, 0x7a8, 0x7aa, 0x7, 
       0x12c, 0x2, 0x2, 0x7a9, 0x7a8, 0x3, 0x2, 0x2, 0x2, 0x7a9, 0x7aa, 
       0x3, 0x2, 0x2, 0x2, 0x7aa, 0x7ab, 0x3, 0x2, 0x2, 0x2, 0x7ab, 0x7ac, 
       0x7, 0x8d, 0x2, 0x2, 0x7ac, 0x7ad, 0x5, 0x1b6, 0xdc, 0x2, 0x7ad, 
       0x7ae, 0x7, 0xca, 0x2, 0x2, 0x7ae, 0x7af, 0x5, 0x148, 0xa5, 0x2, 
       0x7af, 0x7b0, 0x7, 0x169, 0x2, 0x2, 0x7b0, 0x7b5, 0x5, 0xec, 0x77, 
       0x2, 0x7b1, 0x7b2, 0x7, 0x15b, 0x2, 0x2, 0x7b2, 0x7b4, 0x5, 0xec, 
       0x77, 0x2, 0x7b3, 0x7b1, 0x3, 0x2, 0x2, 0x2, 0x7b4, 0x7b7, 0x3, 0x2, 
       0x2, 0x2, 0x7b5, 0x7b3, 0x3, 0x2, 0x2, 0x2, 0x7b5, 0x7b6, 0x3, 0x2, 
       0x2, 0x2, 0x7b6, 0x7b8, 0x3, 0x2, 0x2, 0x2, 0x7b7, 0x7b5, 0x3, 0x2, 
       0x2, 0x2, 0x7b8, 0x7b9, 0x7, 0x16c, 0x2, 0x2, 0x7b9, 0xeb, 0x3, 0x2, 
       0x2, 0x2, 0x7ba, 0x7bc, 0x5, 0x1b6, 0xdc, 0x2, 0x7bb, 0x7bd, 0x9, 
       0x9, 0x2, 0x2, 0x7bc, 0x7bb, 0x3, 0x2, 0x2, 0x2, 0x7bc, 0x7bd, 0x3, 
       0x2, 0x2, 0x2, 0x7bd, 0xed, 0x3, 0x2, 0x2, 0x2, 0x7be, 0x7bf, 0x5, 
       0xf0, 0x79, 0x2, 0x7bf, 0xef, 0x3, 0x2, 0x2, 0x2, 0x7c0, 0x7c1, 0x7, 
       0x13b, 0x2, 0x2, 0x7c1, 0x7c2, 0x7, 0x169, 0x2, 0x2, 0x7c2, 0x7c3, 
       0x5, 0x1b6, 0xdc, 0x2, 0x7c3, 0x7c4, 0x7, 0x15f, 0x2, 0x2, 0x7c4, 
       0x7cc, 0x5, 0x1b6, 0xdc, 0x2, 0x7c5, 0x7c6, 0x7, 0x15b, 0x2, 0x2, 
       0x7c6, 0x7c7, 0x5, 0x1b6, 0xdc, 0x2, 0x7c7, 0x7c8, 0x7, 0x15f, 0x2, 
       0x2, 0x7c8, 0x7c9, 0x5, 0x1b6, 0xdc, 0x2, 0x7c9, 0x7cb, 0x3, 0x2, 
       0x2, 0x2, 0x7ca, 0x7c5, 0x3, 0x2, 0x2, 0x2, 0x7cb, 0x7ce, 0x3, 0x2, 
       0x2, 0x2, 0x7cc, 0x7ca, 0x3, 0x2, 0x2, 0x2, 0x7cc, 0x7cd, 0x3, 0x2, 
       0x2, 0x2, 0x7cd, 0x7cf, 0x3, 0x2, 0x2, 0x2, 0x7ce, 0x7cc, 0x3, 0x2, 
       0x2, 0x2, 0x7cf, 0x7d3, 0x7, 0x16c, 0x2, 0x2, 0x7d0, 0x7d2, 0x5, 
       0x6c, 0x37, 0x2, 0x7d1, 0x7d0, 0x3, 0x2, 0x2, 0x2, 0x7d2, 0x7d5, 
       0x3, 0x2, 0x2, 0x2, 0x7d3, 0x7d1, 0x3, 0x2, 0x2, 0x2, 0x7d3, 0x7d4, 
       0x3, 0x2, 0x2, 0x2, 0x7d4, 0xf1, 0x3, 0x2, 0x2, 0x2, 0x7d5, 0x7d3, 
       0x3, 0x2, 0x2, 0x2, 0x7d6, 0x7d7, 0x7, 0xdc, 0x2, 0x2, 0x7d7, 0x7de, 
       0x5, 0x17e, 0xc0, 0x2, 0x7d8, 0x7d9, 0x7, 0xdc, 0x2, 0x2, 0x7d9, 
       0x7da, 0x7, 0x169, 0x2, 0x2, 0x7da, 0x7db, 0x5, 0x17e, 0xc0, 0x2, 
       0x7db, 0x7dc, 0x7, 0x16c, 0x2, 0x2, 0x7dc, 0x7de, 0x3, 0x2, 0x2, 
       0x2, 0x7dd, 0x7d6, 0x3, 0x2, 0x2, 0x2, 0x7dd, 0x7d8, 0x3, 0x2, 0x2, 
       0x2, 0x7de, 0xf3, 0x3, 0x2, 0x2, 0x2, 0x7df, 0x7e1, 0x7, 0x6, 0x2, 
       0x2, 0x7e0, 0x7df, 0x3, 0x2, 0x2, 0x2, 0x7e0, 0x7e1, 0x3, 0x2, 0x2, 
       0x2, 0x7e1, 0x7e2, 0x3, 0x2, 0x2, 0x2, 0x7e2, 0x7e4, 0x7, 0xe1, 0x2, 
       0x2, 0x7e3, 0x7e5, 0x5, 0x17e, 0xc0, 0x2, 0x7e4, 0x7e3, 0x3, 0x2, 
       0x2, 0x2, 0x7e4, 0x7e5, 0x3, 0x2, 0x2, 0x2, 0x7e5, 0xf5, 0x3, 0x2, 
       0x2, 0x2, 0x7e6, 0x7e7, 0x7, 0xe3, 0x2, 0x2, 0x7e7, 0xf7, 0x3, 0x2, 
       0x2, 0x2, 0x7e8, 0x7f4, 0x7, 0xe8, 0x2, 0x2, 0x7e9, 0x7eb, 0x7, 0x110, 
       0x2, 0x2, 0x7ea, 0x7ec, 0x7, 0x131, 0x2, 0x2, 0x7eb, 0x7ea, 0x3, 
       0x2, 0x2, 0x2, 0x7eb, 0x7ec, 0x3, 0x2, 0x2, 0x2, 0x7ec, 0x7ed, 0x3, 
       0x2, 0x2, 0x2, 0x7ed, 0x7f2, 0x5, 0x17e, 0xc0, 0x2, 0x7ee, 0x7ef, 
       0x7, 0x102, 0x2, 0x2, 0x7ef, 0x7f0, 0x7, 0xb6, 0x2, 0x2, 0x7f0, 0x7f1, 
       0x7, 0x15f, 0x2, 0x2, 0x7f1, 0x7f3, 0x5, 0x17e, 0xc0, 0x2, 0x7f2, 
       0x7ee, 0x3, 0x2, 0x2, 0x2, 0x7f2, 0x7f3, 0x3, 0x2, 0x2, 0x2, 0x7f3, 
       0x7f5, 0x3, 0x2, 0x2, 0x2, 0x7f4, 0x7e9, 0x3, 0x2, 0x2, 0x2, 0x7f4, 
       0x7f5, 0x3, 0x2, 0x2, 0x2, 0x7f5, 0xf9, 0x3, 0x2, 0x2, 0x2, 0x7f6, 
       0x7f8, 0x7, 0xec, 0x2, 0x2, 0x7f7, 0x7f9, 0x5, 0x17e, 0xc0, 0x2, 
       0x7f8, 0x7f7, 0x3, 0x2, 0x2, 0x2, 0x7f8, 0x7f9, 0x3, 0x2, 0x2, 0x2, 
       0x7f9, 0xfb, 0x3, 0x2, 0x2, 0x2, 0x7fa, 0x7fc, 0x7, 0xf2, 0x2, 0x2, 
       0x7fb, 0x7fd, 0x7, 0x13d, 0x2, 0x2, 0x7fc, 0x7fb, 0x3, 0x2, 0x2, 
       0x2, 0x7fc, 0x7fd, 0x3, 0x2, 0x2, 0x2, 0x7fd, 0xfd, 0x3, 0x2, 0x2, 
       0x2, 0x7fe, 0x802, 0x5, 0x100, 0x81, 0x2, 0x7ff, 0x802, 0x5, 0x102, 
       0x82, 0x2, 0x800, 0x802, 0x5, 0x104, 0x83, 0x2, 0x801, 0x7fe, 0x3, 
       0x2, 0x2, 0x2, 0x801, 0x7ff, 0x3, 0x2, 0x2, 0x2, 0x801, 0x800, 0x3, 
       0x2, 0x2, 0x2, 0x802, 0xff, 0x3, 0x2, 0x2, 0x2, 0x803, 0x805, 0x7, 
       0x41, 0x2, 0x2, 0x804, 0x803, 0x3, 0x2, 0x2, 0x2, 0x804, 0x805, 0x3, 
       0x2, 0x2, 0x2, 0x805, 0x806, 0x3, 0x2, 0x2, 0x2, 0x806, 0x809, 0x7, 
       0xfb, 0x2, 0x2, 0x807, 0x809, 0x7, 0x42, 0x2, 0x2, 0x808, 0x804, 
       0x3, 0x2, 0x2, 0x2, 0x808, 0x807, 0x3, 0x2, 0x2, 0x2, 0x809, 0x80b, 
       0x3, 0x2, 0x2, 0x2, 0x80a, 0x80c, 0x7, 0x15f, 0x2, 0x2, 0x80b, 0x80a, 
       0x3, 0x2, 0x2, 0x2, 0x80b, 0x80c, 0x3, 0x2, 0x2, 0x2, 0x80c, 0x80d, 
       0x3, 0x2, 0x2, 0x2, 0x80d, 0x80e, 0x5, 0x17e, 0xc0, 0x2, 0x80e, 0x101, 
       0x3, 0x2, 0x2, 0x2, 0x80f, 0x810, 0x9, 0x1f, 0x2, 0x2, 0x810, 0x811, 
       0x9, 0x20, 0x2, 0x2, 0x811, 0x103, 0x3, 0x2, 0x2, 0x2, 0x812, 0x813, 
       0x7, 0xe0, 0x2, 0x2, 0x813, 0x816, 0x7, 0x15f, 0x2, 0x2, 0x814, 0x817, 
       0x5, 0x17e, 0xc0, 0x2, 0x815, 0x817, 0x7, 0xc2, 0x2, 0x2, 0x816, 
       0x814, 0x3, 0x2, 0x2, 0x2, 0x816, 0x815, 0x3, 0x2, 0x2, 0x2, 0x817, 
       0x819, 0x3, 0x2, 0x2, 0x2, 0x818, 0x81a, 0x7, 0x12d, 0x2, 0x2, 0x819, 
       0x818, 0x3, 0x2, 0x2, 0x2, 0x819, 0x81a, 0x3, 0x2, 0x2, 0x2, 0x81a, 
       0x81b, 0x3, 0x2, 0x2, 0x2, 0x81b, 0x81c, 0x7, 0x75, 0x2, 0x2, 0x81c, 
       0x81d, 0x9, 0x21, 0x2, 0x2, 0x81d, 0x105, 0x3, 0x2, 0x2, 0x2, 0x81e, 
       0x81f, 0x7, 0x107, 0x2, 0x2, 0x81f, 0x820, 0x5, 0x1b6, 0xdc, 0x2, 
       0x820, 0x107, 0x3, 0x2, 0x2, 0x2, 0x821, 0x823, 0x7, 0x129, 0x2, 
       0x2, 0x822, 0x824, 0x7, 0x11c, 0x2, 0x2, 0x823, 0x822, 0x3, 0x2, 
       0x2, 0x2, 0x823, 0x824, 0x3, 0x2, 0x2, 0x2, 0x824, 0x825, 0x3, 0x2, 
       0x2, 0x2, 0x825, 0x826, 0x5, 0x148, 0xa5, 0x2, 0x826, 0x109, 0x3, 
       0x2, 0x2, 0x2, 0x827, 0x828, 0x7, 0x12f, 0x2, 0x2, 0x828, 0x829, 
       0x5, 0x17e, 0xc0, 0x2, 0x829, 0x10b, 0x3, 0x2, 0x2, 0x2, 0x82a, 0x82c, 
       0x7, 0x132, 0x2, 0x2, 0x82b, 0x82d, 0x7, 0x169, 0x2, 0x2, 0x82c, 
       0x82b, 0x3, 0x2, 0x2, 0x2, 0x82c, 0x82d, 0x3, 0x2, 0x2, 0x2, 0x82d, 
       0x82e, 0x3, 0x2, 0x2, 0x2, 0x82e, 0x833, 0x5, 0x17e, 0xc0, 0x2, 0x82f, 
       0x830, 0x7, 0x15b, 0x2, 0x2, 0x830, 0x832, 0x5, 0x17e, 0xc0, 0x2, 
       0x831, 0x82f, 0x3, 0x2, 0x2, 0x2, 0x832, 0x835, 0x3, 0x2, 0x2, 0x2, 
       0x833, 0x831, 0x3, 0x2, 0x2, 0x2, 0x833, 0x834, 0x3, 0x2, 0x2, 0x2, 
       0x834, 0x837, 0x3, 0x2, 0x2, 0x2, 0x835, 0x833, 0x3, 0x2, 0x2, 0x2, 
       0x836, 0x838, 0x7, 0x16c, 0x2, 0x2, 0x837, 0x836, 0x3, 0x2, 0x2, 
       0x2, 0x837, 0x838, 0x3, 0x2, 0x2, 0x2, 0x838, 0x839, 0x3, 0x2, 0x2, 
       0x2, 0x839, 0x83b, 0x7, 0x99, 0x2, 0x2, 0x83a, 0x83c, 0x7, 0x169, 
       0x2, 0x2, 0x83b, 0x83a, 0x3, 0x2, 0x2, 0x2, 0x83b, 0x83c, 0x3, 0x2, 
       0x2, 0x2, 0x83c, 0x83d, 0x3, 0x2, 0x2, 0x2, 0x83d, 0x842, 0x5, 0x1b6, 
       0xdc, 0x2, 0x83e, 0x83f, 0x7, 0x15b, 0x2, 0x2, 0x83f, 0x841, 0x5, 
       0x1b6, 0xdc, 0x2, 0x840, 0x83e, 0x3, 0x2, 0x2, 0x2, 0x841, 0x844, 
       0x3, 0x2, 0x2, 0x2, 0x842, 0x840, 0x3, 0x2, 0x2, 0x2, 0x842, 0x843, 
       0x3, 0x2, 0x2, 0x2, 0x843, 0x846, 0x3, 0x2, 0x2, 0x2, 0x844, 0x842, 
       0x3, 0x2, 0x2, 0x2, 0x845, 0x847, 0x7, 0x16c, 0x2, 0x2, 0x846, 0x845, 
       0x3, 0x2, 0x2, 0x2, 0x846, 0x847, 0x3, 0x2, 0x2, 0x2, 0x847, 0x10d, 
       0x3, 0x2, 0x2, 0x2, 0x848, 0x849, 0x7, 0x13a, 0x2, 0x2, 0x849, 0x84a, 
       0x5, 0x16e, 0xb8, 0x2, 0x84a, 0x84b, 0x9, 0x22, 0x2, 0x2, 0x84b, 
       0x84c, 0x5, 0x4, 0x3, 0x2, 0x84c, 0x84e, 0x7, 0x64, 0x2, 0x2, 0x84d, 
       0x84f, 0x9, 0x23, 0x2, 0x2, 0x84e, 0x84d, 0x3, 0x2, 0x2, 0x2, 0x84e, 
       0x84f, 0x3, 0x2, 0x2, 0x2, 0x84f, 0x10f, 0x3, 0x2, 0x2, 0x2, 0x850, 
       0x851, 0x7, 0x75, 0x2, 0x2, 0x851, 0x852, 0x7, 0x170, 0x2, 0x2, 0x852, 
       0x854, 0x7, 0x8b, 0x2, 0x2, 0x853, 0x855, 0x7, 0x169, 0x2, 0x2, 0x854, 
       0x853, 0x3, 0x2, 0x2, 0x2, 0x854, 0x855, 0x3, 0x2, 0x2, 0x2, 0x855, 
       0x856, 0x3, 0x2, 0x2, 0x2, 0x856, 0x858, 0x5, 0x118, 0x8d, 0x2, 0x857, 
       0x859, 0x7, 0x16c, 0x2, 0x2, 0x858, 0x857, 0x3, 0x2, 0x2, 0x2, 0x858, 
       0x859, 0x3, 0x2, 0x2, 0x2, 0x859, 0x85a, 0x3, 0x2, 0x2, 0x2, 0x85a, 
       0x85b, 0x7, 0xb0, 0x2, 0x2, 0x85b, 0x85c, 0x5, 0x4, 0x3, 0x2, 0x85c, 
       0x85d, 0x7, 0x64, 0x2, 0x2, 0x85d, 0x85e, 0x7, 0xb0, 0x2, 0x2, 0x85e, 
       0x111, 0x3, 0x2, 0x2, 0x2, 0x85f, 0x860, 0x7, 0x75, 0x2, 0x2, 0x860, 
       0x861, 0x7, 0x170, 0x2, 0x2, 0x861, 0x863, 0x7, 0x8b, 0x2, 0x2, 0x862, 
       0x864, 0x7, 0xee, 0x2, 0x2, 0x863, 0x862, 0x3, 0x2, 0x2, 0x2, 0x863, 
       0x864, 0x3, 0x2, 0x2, 0x2, 0x864, 0x865, 0x3, 0x2, 0x2, 0x2, 0x865, 
       0x866, 0x5, 0x17e, 0xc0, 0x2, 0x866, 0x867, 0x7, 0x15e, 0x2, 0x2, 
       0x867, 0x86a, 0x5, 0x17e, 0xc0, 0x2, 0x868, 0x869, 0x9, 0x24, 0x2, 
       0x2, 0x869, 0x86b, 0x5, 0x17e, 0xc0, 0x2, 0x86a, 0x868, 0x3, 0x2, 
       0x2, 0x2, 0x86a, 0x86b, 0x3, 0x2, 0x2, 0x2, 0x86b, 0x86c, 0x3, 0x2, 
       0x2, 0x2, 0x86c, 0x86d, 0x7, 0xb0, 0x2, 0x2, 0x86d, 0x86e, 0x5, 0x4, 
       0x3, 0x2, 0x86e, 0x86f, 0x7, 0x64, 0x2, 0x2, 0x86f, 0x870, 0x7, 0xb0, 
       0x2, 0x2, 0x870, 0x113, 0x3, 0x2, 0x2, 0x2, 0x871, 0x878, 0x7, 0x179, 
       0x2, 0x2, 0x872, 0x873, 0x7, 0x165, 0x2, 0x2, 0x873, 0x874, 0x7, 
       0x165, 0x2, 0x2, 0x874, 0x875, 0x7, 0x170, 0x2, 0x2, 0x875, 0x876, 
       0x7, 0x163, 0x2, 0x2, 0x876, 0x878, 0x7, 0x163, 0x2, 0x2, 0x877, 
       0x871, 0x3, 0x2, 0x2, 0x2, 0x877, 0x872, 0x3, 0x2, 0x2, 0x2, 0x878, 
       0x115, 0x3, 0x2, 0x2, 0x2, 0x879, 0x87a, 0x7, 0x130, 0x2, 0x2, 0x87a, 
       0x87f, 0x5, 0x17e, 0xc0, 0x2, 0x87b, 0x87c, 0x7, 0x15b, 0x2, 0x2, 
       0x87c, 0x87e, 0x5, 0x17e, 0xc0, 0x2, 0x87d, 0x87b, 0x3, 0x2, 
  };
  static const uint16_t serializedATNSegment1[] = {
    0x2, 0x2, 0x87e, 0x881, 0x3, 0x2, 0x2, 0x2, 0x87f, 0x87d, 0x3, 0x2, 
       0x2, 0x2, 0x87f, 0x880, 0x3, 0x2, 0x2, 0x2, 0x880, 0x117, 0x3, 0x2, 
       0x2, 0x2, 0x881, 0x87f, 0x3, 0x2, 0x2, 0x2, 0x882, 0x884, 0x5, 0x11a, 
       0x8e, 0x2, 0x883, 0x882, 0x3, 0x2, 0x2, 0x2, 0x883, 0x884, 0x3, 0x2, 
       0x2, 0x2, 0x884, 0x885, 0x3, 0x2, 0x2, 0x2, 0x885, 0x886, 0x5, 0x120, 
       0x91, 0x2, 0x886, 0x119, 0x3, 0x2, 0x2, 0x2, 0x887, 0x888, 0x7, 0x13b, 
       0x2, 0x2, 0x888, 0x88d, 0x5, 0x11c, 0x8f, 0x2, 0x889, 0x88a, 0x7, 
       0x15b, 0x2, 0x2, 0x88a, 0x88c, 0x5, 0x11c, 0x8f, 0x2, 0x88b, 0x889, 
       0x3, 0x2, 0x2, 0x2, 0x88c, 0x88f, 0x3, 0x2, 0x2, 0x2, 0x88d, 0x88b, 
       0x3, 0x2, 0x2, 0x2, 0x88d, 0x88e, 0x3, 0x2, 0x2, 0x2, 0x88e, 0x11b, 
       0x3, 0x2, 0x2, 0x2, 0x88f, 0x88d, 0x3, 0x2, 0x2, 0x2, 0x890, 0x892, 
       0x5, 0x1b6, 0xdc, 0x2, 0x891, 0x893, 0x5, 0x11e, 0x90, 0x2, 0x892, 
       0x891, 0x3, 0x2, 0x2, 0x2, 0x892, 0x893, 0x3, 0x2, 0x2, 0x2, 0x893, 
       0x894, 0x3, 0x2, 0x2, 0x2, 0x894, 0x895, 0x7, 0x10, 0x2, 0x2, 0x895, 
       0x896, 0x7, 0x169, 0x2, 0x2, 0x896, 0x897, 0x5, 0x120, 0x91, 0x2, 
       0x897, 0x898, 0x7, 0x16c, 0x2, 0x2, 0x898, 0x11d, 0x3, 0x2, 0x2, 
       0x2, 0x899, 0x89a, 0x7, 0x169, 0x2, 0x2, 0x89a, 0x89f, 0x5, 0x1b6, 
       0xdc, 0x2, 0x89b, 0x89c, 0x7, 0x15b, 0x2, 0x2, 0x89c, 0x89e, 0x5, 
       0x1b6, 0xdc, 0x2, 0x89d, 0x89b, 0x3, 0x2, 0x2, 0x2, 0x89e, 0x8a1, 
       0x3, 0x2, 0x2, 0x2, 0x89f, 0x89d, 0x3, 0x2, 0x2, 0x2, 0x89f, 0x8a0, 
       0x3, 0x2, 0x2, 0x2, 0x8a0, 0x8a2, 0x3, 0x2, 0x2, 0x2, 0x8a1, 0x89f, 
       0x3, 0x2, 0x2, 0x2, 0x8a2, 0x8a3, 0x7, 0x16c, 0x2, 0x2, 0x8a3, 0x11f, 
       0x3, 0x2, 0x2, 0x2, 0x8a4, 0x8aa, 0x5, 0x122, 0x92, 0x2, 0x8a5, 0x8a6, 
       0x5, 0x124, 0x93, 0x2, 0x8a6, 0x8a7, 0x5, 0x122, 0x92, 0x2, 0x8a7, 
       0x8a9, 0x3, 0x2, 0x2, 0x2, 0x8a8, 0x8a5, 0x3, 0x2, 0x2, 0x2, 0x8a9, 
       0x8ac, 0x3, 0x2, 0x2, 0x2, 0x8aa, 0x8a8, 0x3, 0x2, 0x2, 0x2, 0x8aa, 
       0x8ab, 0x3, 0x2, 0x2, 0x2, 0x8ab, 0x121, 0x3, 0x2, 0x2, 0x2, 0x8ac, 
       0x8aa, 0x3, 0x2, 0x2, 0x2, 0x8ad, 0x8b3, 0x5, 0x126, 0x94, 0x2, 0x8ae, 
       0x8af, 0x7, 0x169, 0x2, 0x2, 0x8af, 0x8b0, 0x5, 0x120, 0x91, 0x2, 
       0x8b0, 0x8b1, 0x7, 0x16c, 0x2, 0x2, 0x8b1, 0x8b3, 0x3, 0x2, 0x2, 
       0x2, 0x8b2, 0x8ad, 0x3, 0x2, 0x2, 0x2, 0x8b2, 0x8ae, 0x3, 0x2, 0x2, 
       0x2, 0x8b3, 0x123, 0x3, 0x2, 0x2, 0x2, 0x8b4, 0x8b6, 0x7, 0x12b, 
       0x2, 0x2, 0x8b5, 0x8b7, 0x7, 0xa, 0x2, 0x2, 0x8b6, 0x8b5, 0x3, 0x2, 
       0x2, 0x2, 0x8b6, 0x8b7, 0x3, 0x2, 0x2, 0x2, 0x8b7, 0x8c1, 0x3, 0x2, 
       0x2, 0x2, 0x8b8, 0x8ba, 0x7, 0x67, 0x2, 0x2, 0x8b9, 0x8bb, 0x7, 0xa, 
       0x2, 0x2, 0x8ba, 0x8b9, 0x3, 0x2, 0x2, 0x2, 0x8ba, 0x8bb, 0x3, 0x2, 
       0x2, 0x2, 0x8bb, 0x8c1, 0x3, 0x2, 0x2, 0x2, 0x8bc, 0x8be, 0x7, 0x97, 
       0x2, 0x2, 0x8bd, 0x8bf, 0x7, 0xa, 0x2, 0x2, 0x8be, 0x8bd, 0x3, 0x2, 
       0x2, 0x2, 0x8be, 0x8bf, 0x3, 0x2, 0x2, 0x2, 0x8bf, 0x8c1, 0x3, 0x2, 
       0x2, 0x2, 0x8c0, 0x8b4, 0x3, 0x2, 0x2, 0x2, 0x8c0, 0x8b8, 0x3, 0x2, 
       0x2, 0x2, 0x8c0, 0x8bc, 0x3, 0x2, 0x2, 0x2, 0x8c1, 0x125, 0x3, 0x2, 
       0x2, 0x2, 0x8c2, 0x8c3, 0x9, 0x25, 0x2, 0x2, 0x8c3, 0x8c5, 0x5, 0x128, 
       0x95, 0x2, 0x8c4, 0x8c6, 0x5, 0x134, 0x9b, 0x2, 0x8c5, 0x8c4, 0x3, 
       0x2, 0x2, 0x2, 0x8c5, 0x8c6, 0x3, 0x2, 0x2, 0x2, 0x8c6, 0x8c8, 0x3, 
       0x2, 0x2, 0x2, 0x8c7, 0x8c9, 0x5, 0x136, 0x9c, 0x2, 0x8c8, 0x8c7, 
       0x3, 0x2, 0x2, 0x2, 0x8c8, 0x8c9, 0x3, 0x2, 0x2, 0x2, 0x8c9, 0x8cb, 
       0x3, 0x2, 0x2, 0x2, 0x8ca, 0x8cc, 0x5, 0x14a, 0xa6, 0x2, 0x8cb, 0x8ca, 
       0x3, 0x2, 0x2, 0x2, 0x8cb, 0x8cc, 0x3, 0x2, 0x2, 0x2, 0x8cc, 0x8ce, 
       0x3, 0x2, 0x2, 0x2, 0x8cd, 0x8cf, 0x5, 0x14c, 0xa7, 0x2, 0x8ce, 0x8cd, 
       0x3, 0x2, 0x2, 0x2, 0x8ce, 0x8cf, 0x3, 0x2, 0x2, 0x2, 0x8cf, 0x8d2, 
       0x3, 0x2, 0x2, 0x2, 0x8d0, 0x8d3, 0x5, 0x14e, 0xa8, 0x2, 0x8d1, 0x8d3, 
       0x5, 0x150, 0xa9, 0x2, 0x8d2, 0x8d0, 0x3, 0x2, 0x2, 0x2, 0x8d2, 0x8d1, 
       0x3, 0x2, 0x2, 0x2, 0x8d2, 0x8d3, 0x3, 0x2, 0x2, 0x2, 0x8d3, 0x8d5, 
       0x3, 0x2, 0x2, 0x2, 0x8d4, 0x8d6, 0x5, 0x152, 0xaa, 0x2, 0x8d5, 0x8d4, 
       0x3, 0x2, 0x2, 0x2, 0x8d5, 0x8d6, 0x3, 0x2, 0x2, 0x2, 0x8d6, 0x8d8, 
       0x3, 0x2, 0x2, 0x2, 0x8d7, 0x8d9, 0x5, 0x154, 0xab, 0x2, 0x8d8, 0x8d7, 
       0x3, 0x2, 0x2, 0x2, 0x8d8, 0x8d9, 0x3, 0x2, 0x2, 0x2, 0x8d9, 0x127, 
       0x3, 0x2, 0x2, 0x2, 0x8da, 0x8dc, 0x5, 0x12a, 0x96, 0x2, 0x8db, 0x8da, 
       0x3, 0x2, 0x2, 0x2, 0x8db, 0x8dc, 0x3, 0x2, 0x2, 0x2, 0x8dc, 0x8de, 
       0x3, 0x2, 0x2, 0x2, 0x8dd, 0x8df, 0x5, 0x12c, 0x97, 0x2, 0x8de, 0x8dd, 
       0x3, 0x2, 0x2, 0x2, 0x8de, 0x8df, 0x3, 0x2, 0x2, 0x2, 0x8df, 0x8e0, 
       0x3, 0x2, 0x2, 0x2, 0x8e0, 0x8e5, 0x5, 0x12e, 0x98, 0x2, 0x8e1, 0x8e2, 
       0x7, 0x15b, 0x2, 0x2, 0x8e2, 0x8e4, 0x5, 0x12e, 0x98, 0x2, 0x8e3, 
       0x8e1, 0x3, 0x2, 0x2, 0x2, 0x8e4, 0x8e7, 0x3, 0x2, 0x2, 0x2, 0x8e5, 
       0x8e3, 0x3, 0x2, 0x2, 0x2, 0x8e5, 0x8e6, 0x3, 0x2, 0x2, 0x2, 0x8e6, 
       0x129, 0x3, 0x2, 0x2, 0x2, 0x8e7, 0x8e5, 0x3, 0x2, 0x2, 0x2, 0x8e8, 
       0x8e9, 0x9, 0x26, 0x2, 0x2, 0x8e9, 0x12b, 0x3, 0x2, 0x2, 0x2, 0x8ea, 
       0x8eb, 0x7, 0x126, 0x2, 0x2, 0x8eb, 0x8ec, 0x5, 0x17e, 0xc0, 0x2, 
       0x8ec, 0x12d, 0x3, 0x2, 0x2, 0x2, 0x8ed, 0x8ee, 0x5, 0x1b6, 0xdc, 
       0x2, 0x8ee, 0x8ef, 0x7, 0x15f, 0x2, 0x2, 0x8ef, 0x8f1, 0x3, 0x2, 
       0x2, 0x2, 0x8f0, 0x8ed, 0x3, 0x2, 0x2, 0x2, 0x8f0, 0x8f1, 0x3, 0x2, 
       0x2, 0x2, 0x8f1, 0x8f2, 0x3, 0x2, 0x2, 0x2, 0x8f2, 0x8f4, 0x5, 0x17e, 
       0xc0, 0x2, 0x8f3, 0x8f5, 0x5, 0x130, 0x99, 0x2, 0x8f4, 0x8f3, 0x3, 
       0x2, 0x2, 0x2, 0x8f4, 0x8f5, 0x3, 0x2, 0x2, 0x2, 0x8f5, 0x8f8, 0x3, 
       0x2, 0x2, 0x2, 0x8f6, 0x8f8, 0x5, 0x132, 0x9a, 0x2, 0x8f7, 0x8f0, 
       0x3, 0x2, 0x2, 0x2, 0x8f7, 0x8f6, 0x3, 0x2, 0x2, 0x2, 0x8f8, 0x12f, 
       0x3, 0x2, 0x2, 0x2, 0x8f9, 0x8fb, 0x6, 0x99, 0x5, 0x2, 0x8fa, 0x8fc, 
       0x7, 0x10, 0x2, 0x2, 0x8fb, 0x8fa, 0x3, 0x2, 0x2, 0x2, 0x8fb, 0x8fc, 
       0x3, 0x2, 0x2, 0x2, 0x8fc, 0x8fd, 0x3, 0x2, 0x2, 0x2, 0x8fd, 0x903, 
       0x5, 0x1b6, 0xdc, 0x2, 0x8fe, 0x8ff, 0x7, 0x169, 0x2, 0x2, 0x8ff, 
       0x900, 0x7, 0x124, 0x2, 0x2, 0x900, 0x901, 0x7, 0x171, 0x2, 0x2, 
       0x901, 0x903, 0x7, 0x16c, 0x2, 0x2, 0x902, 0x8f9, 0x3, 0x2, 0x2, 
       0x2, 0x902, 0x8fe, 0x3, 0x2, 0x2, 0x2, 0x903, 0x131, 0x3, 0x2, 0x2, 
       0x2, 0x904, 0x905, 0x7, 0x170, 0x2, 0x2, 0x905, 0x907, 0x7, 0x6, 
       0x2, 0x2, 0x906, 0x904, 0x3, 0x2, 0x2, 0x2, 0x906, 0x907, 0x3, 0x2, 
       0x2, 0x2, 0x907, 0x908, 0x3, 0x2, 0x2, 0x2, 0x908, 0x909, 0x7, 0x167, 
       0x2, 0x2, 0x909, 0x133, 0x3, 0x2, 0x2, 0x2, 0x90a, 0x90b, 0x7, 0x99, 
       0x2, 0x2, 0x90b, 0x910, 0x5, 0x1b6, 0xdc, 0x2, 0x90c, 0x90d, 0x7, 
       0x15b, 0x2, 0x2, 0x90d, 0x90f, 0x5, 0x1b6, 0xdc, 0x2, 0x90e, 0x90c, 
       0x3, 0x2, 0x2, 0x2, 0x90f, 0x912, 0x3, 0x2, 0x2, 0x2, 0x910, 0x90e, 
       0x3, 0x2, 0x2, 0x2, 0x910, 0x911, 0x3, 0x2, 0x2, 0x2, 0x911, 0x135, 
       0x3, 0x2, 0x2, 0x2, 0x912, 0x910, 0x3, 0x2, 0x2, 0x2, 0x913, 0x914, 
       0x7, 0x79, 0x2, 0x2, 0x914, 0x918, 0x5, 0x138, 0x9d, 0x2, 0x915, 
       0x917, 0x5, 0x13e, 0xa0, 0x2, 0x916, 0x915, 0x3, 0x2, 0x2, 0x2, 0x917, 
       0x91a, 0x3, 0x2, 0x2, 0x2, 0x918, 0x916, 0x3, 0x2, 0x2, 0x2, 0x918, 
       0x919, 0x3, 0x2, 0x2, 0x2, 0x919, 0x137, 0x3, 0x2, 0x2, 0x2, 0x91a, 
       0x918, 0x3, 0x2, 0x2, 0x2, 0x91b, 0x91f, 0x5, 0x13a, 0x9e, 0x2, 0x91c, 
       0x91f, 0x5, 0x13c, 0x9f, 0x2, 0x91d, 0x91f, 0x5, 0x142, 0xa2, 0x2, 
       0x91e, 0x91b, 0x3, 0x2, 0x2, 0x2, 0x91e, 0x91c, 0x3, 0x2, 0x2, 0x2, 
       0x91e, 0x91d, 0x3, 0x2, 0x2, 0x2, 0x91f, 0x139, 0x3, 0x2, 0x2, 0x2, 
       0x920, 0x922, 0x5, 0x148, 0xa5, 0x2, 0x921, 0x923, 0x5, 0x146, 0xa4, 
       0x2, 0x922, 0x921, 0x3, 0x2, 0x2, 0x2, 0x922, 0x923, 0x3, 0x2, 0x2, 
       0x2, 0x923, 0x13b, 0x3, 0x2, 0x2, 0x2, 0x924, 0x925, 0x7, 0x169, 
       0x2, 0x2, 0x925, 0x926, 0x5, 0x118, 0x8d, 0x2, 0x926, 0x928, 0x7, 
       0x16c, 0x2, 0x2, 0x927, 0x929, 0x5, 0x146, 0xa4, 0x2, 0x928, 0x927, 
       0x3, 0x2, 0x2, 0x2, 0x928, 0x929, 0x3, 0x2, 0x2, 0x2, 0x929, 0x13d, 
       0x3, 0x2, 0x2, 0x2, 0x92a, 0x92b, 0x7, 0x15b, 0x2, 0x2, 0x92b, 0x932, 
       0x5, 0x138, 0x9d, 0x2, 0x92c, 0x92d, 0x5, 0x140, 0xa1, 0x2, 0x92d, 
       0x92e, 0x5, 0x138, 0x9d, 0x2, 0x92e, 0x92f, 0x7, 0xca, 0x2, 0x2, 
       0x92f, 0x930, 0x5, 0x16e, 0xb8, 0x2, 0x930, 0x932, 0x3, 0x2, 0x2, 
       0x2, 0x931, 0x92a, 0x3, 0x2, 0x2, 0x2, 0x931, 0x92c, 0x3, 0x2, 0x2, 
       0x2, 0x932, 0x13f, 0x3, 0x2, 0x2, 0x2, 0x933, 0x935, 0x7, 0x8f, 0x2, 
       0x2, 0x934, 0x933, 0x3, 0x2, 0x2, 0x2, 0x934, 0x935, 0x3, 0x2, 0x2, 
       0x2, 0x935, 0x936, 0x3, 0x2, 0x2, 0x2, 0x936, 0x93d, 0x7, 0x9e, 0x2, 
       0x2, 0x937, 0x939, 0x9, 0x27, 0x2, 0x2, 0x938, 0x93a, 0x7, 0xd0, 
       0x2, 0x2, 0x939, 0x938, 0x3, 0x2, 0x2, 0x2, 0x939, 0x93a, 0x3, 0x2, 
       0x2, 0x2, 0x93a, 0x93b, 0x3, 0x2, 0x2, 0x2, 0x93b, 0x93d, 0x7, 0x9e, 
       0x2, 0x2, 0x93c, 0x934, 0x3, 0x2, 0x2, 0x2, 0x93c, 0x937, 0x3, 0x2, 
       0x2, 0x2, 0x93d, 0x141, 0x3, 0x2, 0x2, 0x2, 0x93e, 0x93f, 0x7, 0x11c, 
       0x2, 0x2, 0x93f, 0x940, 0x7, 0x169, 0x2, 0x2, 0x940, 0x941, 0x7, 
       0x132, 0x2, 0x2, 0x941, 0x946, 0x5, 0x144, 0xa3, 0x2, 0x942, 0x943, 
       0x7, 0x15b, 0x2, 0x2, 0x943, 0x945, 0x5, 0x144, 0xa3, 0x2, 0x944, 
       0x942, 0x3, 0x2, 0x2, 0x2, 0x945, 0x948, 0x3, 0x2, 0x2, 0x2, 0x946, 
       0x944, 0x3, 0x2, 0x2, 0x2, 0x946, 0x947, 0x3, 0x2, 0x2, 0x2, 0x947, 
       0x949, 0x3, 0x2, 0x2, 0x2, 0x948, 0x946, 0x3, 0x2, 0x2, 0x2, 0x949, 
       0x94b, 0x7, 0x16c, 0x2, 0x2, 0x94a, 0x94c, 0x5, 0x146, 0xa4, 0x2, 
       0x94b, 0x94a, 0x3, 0x2, 0x2, 0x2, 0x94b, 0x94c, 0x3, 0x2, 0x2, 0x2, 
       0x94c, 0x143, 0x3, 0x2, 0x2, 0x2, 0x94d, 0x95a, 0x5, 0x17e, 0xc0, 
       0x2, 0x94e, 0x94f, 0x7, 0x169, 0x2, 0x2, 0x94f, 0x954, 0x5, 0x17e, 
       0xc0, 0x2, 0x950, 0x951, 0x7, 0x15b, 0x2, 0x2, 0x951, 0x953, 0x5, 
       0x17e, 0xc0, 0x2, 0x952, 0x950, 0x3, 0x2, 0x2, 0x2, 0x953, 0x956, 
       0x3, 0x2, 0x2, 0x2, 0x954, 0x952, 0x3, 0x2, 0x2, 0x2, 0x954, 0x955, 
       0x3, 0x2, 0x2, 0x2, 0x955, 0x957, 0x3, 0x2, 0x2, 0x2, 0x956, 0x954, 
       0x3, 0x2, 0x2, 0x2, 0x957, 0x958, 0x7, 0x16c, 0x2, 0x2, 0x958, 0x95a, 
       0x3, 0x2, 0x2, 0x2, 0x959, 0x94d, 0x3, 0x2, 0x2, 0x2, 0x959, 0x94e, 
       0x3, 0x2, 0x2, 0x2, 0x95a, 0x145, 0x3, 0x2, 0x2, 0x2, 0x95b, 0x95d, 
       0x6, 0xa4, 0x6, 0x2, 0x95c, 0x95e, 0x7, 0x10, 0x2, 0x2, 0x95d, 0x95c, 
       0x3, 0x2, 0x2, 0x2, 0x95d, 0x95e, 0x3, 0x2, 0x2, 0x2, 0x95e, 0x95f, 
       0x3, 0x2, 0x2, 0x2, 0x95f, 0x96a, 0x5, 0x1b6, 0xdc, 0x2, 0x960, 0x961, 
       0x7, 0x169, 0x2, 0x2, 0x961, 0x966, 0x7, 0x170, 0x2, 0x2, 0x962, 
       0x963, 0x7, 0x15b, 0x2, 0x2, 0x963, 0x965, 0x7, 0x170, 0x2, 0x2, 
       0x964, 0x962, 0x3, 0x2, 0x2, 0x2, 0x965, 0x968, 0x3, 0x2, 0x2, 0x2, 
       0x966, 0x964, 0x3, 0x2, 0x2, 0x2, 0x966, 0x967, 0x3, 0x2, 0x2, 0x2, 
       0x967, 0x969, 0x3, 0x2, 0x2, 0x2, 0x968, 0x966, 0x3, 0x2, 0x2, 0x2, 
       0x969, 0x96b, 0x7, 0x16c, 0x2, 0x2, 0x96a, 0x960, 0x3, 0x2, 0x2, 
       0x2, 0x96a, 0x96b, 0x3, 0x2, 0x2, 0x2, 0x96b, 0x147, 0x3, 0x2, 0x2, 
       0x2, 0x96c, 0x96d, 0x5, 0x1b6, 0xdc, 0x2, 0x96d, 0x149, 0x3, 0x2, 
       0x2, 0x2, 0x96e, 0x96f, 0x7, 0x139, 0x2, 0x2, 0x96f, 0x970, 0x5, 
       0x16e, 0xb8, 0x2, 0x970, 0x14b, 0x3, 0x2, 0x2, 0x2, 0x971, 0x972, 
       0x7, 0x80, 0x2, 0x2, 0x972, 0x973, 0x7, 0x20, 0x2, 0x2, 0x973, 0x978, 
       0x5, 0x17e, 0xc0, 0x2, 0x974, 0x975, 0x7, 0x15b, 0x2, 0x2, 0x975, 
       0x977, 0x5, 0x17e, 0xc0, 0x2, 0x976, 0x974, 0x3, 0x2, 0x2, 0x2, 0x977, 
       0x97a, 0x3, 0x2, 0x2, 0x2, 0x978, 0x976, 0x3, 0x2, 0x2, 0x2, 0x978, 
       0x979, 0x3, 0x2, 0x2, 0x2, 0x979, 0x14d, 0x3, 0x2, 0x2, 0x2, 0x97a, 
       0x978, 0x3, 0x2, 0x2, 0x2, 0x97b, 0x97c, 0x7, 0x83, 0x2, 0x2, 0x97c, 
       0x97d, 0x5, 0x16e, 0xb8, 0x2, 0x97d, 0x14f, 0x3, 0x2, 0x2, 0x2, 0x97e, 
       0x97f, 0x7, 0xdf, 0x2, 0x2, 0x97f, 0x980, 0x5, 0x16e, 0xb8, 0x2, 
       0x980, 0x151, 0x3, 0x2, 0x2, 0x2, 0x981, 0x982, 0x7, 0xce, 0x2, 0x2, 
       0x982, 0x983, 0x7, 0x20, 0x2, 0x2, 0x983, 0x985, 0x5, 0x17e, 0xc0, 
       0x2, 0x984, 0x986, 0x9, 0x9, 0x2, 0x2, 0x985, 0x984, 0x3, 0x2, 0x2, 
       0x2, 0x985, 0x986, 0x3, 0x2, 0x2, 0x2, 0x986, 0x98e, 0x3, 0x2, 0x2, 
       0x2, 0x987, 0x988, 0x7, 0x15b, 0x2, 0x2, 0x988, 0x98a, 0x5, 0x17e, 
       0xc0, 0x2, 0x989, 0x98b, 0x9, 0x9, 0x2, 0x2, 0x98a, 0x989, 0x3, 0x2, 
       0x2, 0x2, 0x98a, 0x98b, 0x3, 0x2, 0x2, 0x2, 0x98b, 0x98d, 0x3, 0x2, 
       0x2, 0x2, 0x98c, 0x987, 0x3, 0x2, 0x2, 0x2, 0x98d, 0x990, 0x3, 0x2, 
       0x2, 0x2, 0x98e, 0x98c, 0x3, 0x2, 0x2, 0x2, 0x98e, 0x98f, 0x3, 0x2, 
       0x2, 0x2, 0x98f, 0x153, 0x3, 0x2, 0x2, 0x2, 0x990, 0x98e, 0x3, 0x2, 
       0x2, 0x2, 0x991, 0x993, 0x5, 0x156, 0xac, 0x2, 0x992, 0x991, 0x3, 
       0x2, 0x2, 0x2, 0x993, 0x994, 0x3, 0x2, 0x2, 0x2, 0x994, 0x992, 0x3, 
       0x2, 0x2, 0x2, 0x994, 0x995, 0x3, 0x2, 0x2, 0x2, 0x995, 0x155, 0x3, 
       0x2, 0x2, 0x2, 0x996, 0x997, 0x7, 0xa6, 0x2, 0x2, 0x997, 0x9a2, 0x5, 
       0x17e, 0xc0, 0x2, 0x998, 0x999, 0x7, 0x13b, 0x2, 0x2, 0x999, 0x99f, 
       0x9, 0x28, 0x2, 0x2, 0x99a, 0x99b, 0x7, 0x12f, 0x2, 0x2, 0x99b, 0x99c, 
       0x7, 0xd, 0x2, 0x2, 0x99c, 0x99d, 0x7, 0x9f, 0x2, 0x2, 0x99d, 0x99e, 
       0x9, 0x29, 0x2, 0x2, 0x99e, 0x9a0, 0x7, 0xac, 0x2, 0x2, 0x99f, 0x99a, 
       0x3, 0x2, 0x2, 0x2, 0x99f, 0x9a0, 0x3, 0x2, 0x2, 0x2, 0x9a0, 0x9a2, 
       0x3, 0x2, 0x2, 0x2, 0x9a1, 0x996, 0x3, 0x2, 0x2, 0x2, 0x9a1, 0x998, 
       0x3, 0x2, 0x2, 0x2, 0x9a2, 0x157, 0x3, 0x2, 0x2, 0x2, 0x9a3, 0x9a4, 
       0x7, 0x12d, 0x2, 0x2, 0x9a4, 0x9a5, 0x5, 0x15c, 0xaf, 0x2, 0x9a5, 
       0x9a6, 0x7, 0x102, 0x2, 0x2, 0x9a6, 0x9a8, 0x5, 0x15a, 0xae, 0x2, 
       0x9a7, 0x9a9, 0x5, 0x14a, 0xa6, 0x2, 0x9a8, 0x9a7, 0x3, 0x2, 0x2, 
       0x2, 0x9a8, 0x9a9, 0x3, 0x2, 0x2, 0x2, 0x9a9, 0x9ab, 0x3, 0x2, 0x2, 
       0x2, 0x9aa, 0x9ac, 0x5, 0x15e, 0xb0, 0x2, 0x9ab, 0x9aa, 0x3, 0x2, 
       0x2, 0x2, 0x9ab, 0x9ac, 0x3, 0x2, 0x2, 0x2, 0x9ac, 0x159, 0x3, 0x2, 
       0x2, 0x2, 0x9ad, 0x9b2, 0x5, 0x1c, 0xf, 0x2, 0x9ae, 0x9af, 0x7, 0x15b, 
       0x2, 0x2, 0x9af, 0x9b1, 0x5, 0x1c, 0xf, 0x2, 0x9b0, 0x9ae, 0x3, 0x2, 
       0x2, 0x2, 0x9b1, 0x9b4, 0x3, 0x2, 0x2, 0x2, 0x9b2, 0x9b0, 0x3, 0x2, 
       0x2, 0x2, 0x9b2, 0x9b3, 0x3, 0x2, 0x2, 0x2, 0x9b3, 0x15b, 0x3, 0x2, 
       0x2, 0x2, 0x9b4, 0x9b2, 0x3, 0x2, 0x2, 0x2, 0x9b5, 0x9b7, 0x5, 0x148, 
       0xa5, 0x2, 0x9b6, 0x9b8, 0x5, 0x136, 0x9c, 0x2, 0x9b7, 0x9b6, 0x3, 
       0x2, 0x2, 0x2, 0x9b7, 0x9b8, 0x3, 0x2, 0x2, 0x2, 0x9b8, 0x9be, 0x3, 
       0x2, 0x2, 0x2, 0x9b9, 0x9ba, 0x7, 0x169, 0x2, 0x2, 0x9ba, 0x9bb, 
       0x5, 0x118, 0x8d, 0x2, 0x9bb, 0x9bc, 0x7, 0x16c, 0x2, 0x2, 0x9bc, 
       0x9be, 0x3, 0x2, 0x2, 0x2, 0x9bd, 0x9b5, 0x3, 0x2, 0x2, 0x2, 0x9bd, 
       0x9b9, 0x3, 0x2, 0x2, 0x2, 0x9be, 0x9c3, 0x3, 0x2, 0x2, 0x2, 0x9bf, 
       0x9c1, 0x7, 0x10, 0x2, 0x2, 0x9c0, 0x9bf, 0x3, 0x2, 0x2, 0x2, 0x9c0, 
       0x9c1, 0x3, 0x2, 0x2, 0x2, 0x9c1, 0x9c2, 0x3, 0x2, 0x2, 0x2, 0x9c2, 
       0x9c4, 0x5, 0x1b6, 0xdc, 0x2, 0x9c3, 0x9c0, 0x3, 0x2, 0x2, 0x2, 0x9c3, 
       0x9c4, 0x3, 0x2, 0x2, 0x2, 0x9c4, 0x15d, 0x3, 0x2, 0x2, 0x2, 0x9c5, 
       0x9c6, 0x7, 0x60, 0x2, 0x2, 0x9c6, 0x9c7, 0x5, 0xb2, 0x5a, 0x2, 0x9c7, 
       0x15f, 0x3, 0x2, 0x2, 0x2, 0x9c8, 0x9c9, 0x7, 0xb5, 0x2, 0x2, 0x9c9, 
       0x9ca, 0x7, 0x99, 0x2, 0x2, 0x9ca, 0x9cb, 0x5, 0x162, 0xb2, 0x2, 
       0x9cb, 0x9cc, 0x7, 0x130, 0x2, 0x2, 0x9cc, 0x9cd, 0x5, 0x162, 0xb2, 
       0x2, 0x9cd, 0x9ce, 0x7, 0xca, 0x2, 0x2, 0x9ce, 0x9d0, 0x5, 0x16e, 
       0xb8, 0x2, 0x9cf, 0x9d1, 0x5, 0x164, 0xb3, 0x2, 0x9d0, 0x9cf, 0x3, 
       0x2, 0x2, 0x2, 0x9d1, 0x9d2, 0x3, 0x2, 0x2, 0x2, 0x9d2, 0x9d0, 0x3, 
       0x2, 0x2, 0x2, 0x9d2, 0x9d3, 0x3, 0x2, 0x2, 0x2, 0x9d3, 0x161, 0x3, 
       0x2, 0x2, 0x2, 0x9d4, 0x9da, 0x5, 0x148, 0xa5, 0x2, 0x9d5, 0x9d6, 
       0x7, 0x169, 0x2, 0x2, 0x9d6, 0x9d7, 0x5, 0x118, 0x8d, 0x2, 0x9d7, 
       0x9d8, 0x7, 0x16c, 0x2, 0x2, 0x9d8, 0x9da, 0x3, 0x2, 0x2, 0x2, 0x9d9, 
       0x9d4, 0x3, 0x2, 0x2, 0x2, 0x9d9, 0x9d5, 0x3, 0x2, 0x2, 0x2, 0x9da, 
       0x9df, 0x3, 0x2, 0x2, 0x2, 0x9db, 0x9dd, 0x7, 0x10, 0x2, 0x2, 0x9dc, 
       0x9db, 0x3, 0x2, 0x2, 0x2, 0x9dc, 0x9dd, 0x3, 0x2, 0x2, 0x2, 0x9dd, 
       0x9de, 0x3, 0x2, 0x2, 0x2, 0x9de, 0x9e0, 0x5, 0x1b6, 0xdc, 0x2, 0x9df, 
       0x9dc, 0x3, 0x2, 0x2, 0x2, 0x9df, 0x9e0, 0x3, 0x2, 0x2, 0x2, 0x9e0, 
       0x163, 0x3, 0x2, 0x2, 0x2, 0x9e1, 0x9e3, 0x7, 0x138, 0x2, 0x2, 0x9e2, 
       0x9e4, 0x7, 0xc3, 0x2, 0x2, 0x9e3, 0x9e2, 0x3, 0x2, 0x2, 0x2, 0x9e3, 
       0x9e4, 0x3, 0x2, 0x2, 0x2, 0x9e4, 0x9e5, 0x3, 0x2, 0x2, 0x2, 0x9e5, 
       0x9e8, 0x7, 0xb2, 0x2, 0x2, 0x9e6, 0x9e7, 0x7, 0xd, 0x2, 0x2, 0x9e7, 
       0x9e9, 0x5, 0x16e, 0xb8, 0x2, 0x9e8, 0x9e6, 0x3, 0x2, 0x2, 0x2, 0x9e8, 
       0x9e9, 0x3, 0x2, 0x2, 0x2, 0x9e9, 0x9ea, 0x3, 0x2, 0x2, 0x2, 0x9ea, 
       0x9eb, 0x7, 0x121, 0x2, 0x2, 0x9eb, 0x9ef, 0x5, 0x166, 0xb4, 0x2, 
       0x9ec, 0x9ed, 0x7, 0x60, 0x2, 0x2, 0x9ed, 0x9ef, 0x7, 0x89, 0x2, 
       0x2, 0x9ee, 0x9e1, 0x3, 0x2, 0x2, 0x2, 0x9ee, 0x9ec, 0x3, 0x2, 0x2, 
       0x2, 0x9ef, 0x165, 0x3, 0x2, 0x2, 0x2, 0x9f0, 0x9f2, 0x7, 0x91, 0x2, 
       0x2, 0x9f1, 0x9f3, 0x5, 0xb4, 0x5b, 0x2, 0x9f2, 0x9f1, 0x3, 0x2, 
       0x2, 0x2, 0x9f2, 0x9f3, 0x3, 0x2, 0x2, 0x2, 0x9f3, 0x9f4, 0x3, 0x2, 
       0x2, 0x2, 0x9f4, 0x9f5, 0x7, 0x132, 0x2, 0x2, 0x9f5, 0xa05, 0x5, 
       0xb8, 0x5d, 0x2, 0x9f6, 0x9f7, 0x7, 0x12d, 0x2, 0x2, 0x9f7, 0x9f8, 
       0x7, 0x102, 0x2, 0x2, 0x9f8, 0x9fd, 0x5, 0x1c, 0xf, 0x2, 0x9f9, 0x9fa, 
       0x7, 0x15b, 0x2, 0x2, 0x9fa, 0x9fc, 0x5, 0x1c, 0xf, 0x2, 0x9fb, 0x9f9, 
       0x3, 0x2, 0x2, 0x2, 0x9fc, 0x9ff, 0x3, 0x2, 0x2, 0x2, 0x9fd, 0x9fb, 
       0x3, 0x2, 0x2, 0x2, 0x9fd, 0x9fe, 0x3, 0x2, 0x2, 0x2, 0x9fe, 0xa01, 
       0x3, 0x2, 0x2, 0x2, 0x9ff, 0x9fd, 0x3, 0x2, 0x2, 0x2, 0xa00, 0xa02, 
       0x5, 0x14a, 0xa6, 0x2, 0xa01, 0xa00, 0x3, 0x2, 0x2, 0x2, 0xa01, 0xa02, 
       0x3, 0x2, 0x2, 0x2, 0xa02, 0xa05, 0x3, 0x2, 0x2, 0x2, 0xa03, 0xa05, 
       0x7, 0x52, 0x2, 0x2, 0xa04, 0x9f0, 0x3, 0x2, 0x2, 0x2, 0xa04, 0x9f6, 
       0x3, 0x2, 0x2, 0x2, 0xa04, 0xa03, 0x3, 0x2, 0x2, 0x2, 0xa05, 0x167, 
       0x3, 0x2, 0x2, 0x2, 0xa06, 0xa08, 0x7, 0x52, 0x2, 0x2, 0xa07, 0xa09, 
       0x7, 0x79, 0x2, 0x2, 0xa08, 0xa07, 0x3, 0x2, 0x2, 0x2, 0xa08, 0xa09, 
       0x3, 0x2, 0x2, 0x2, 0xa09, 0xa0a, 0x3, 0x2, 0x2, 0x2, 0xa0a, 0xa0c, 
       0x5, 0x148, 0xa5, 0x2, 0xa0b, 0xa0d, 0x5, 0x16a, 0xb6, 0x2, 0xa0c, 
       0xa0b, 0x3, 0x2, 0x2, 0x2, 0xa0c, 0xa0d, 0x3, 0x2, 0x2, 0x2, 0xa0d, 
       0xa10, 0x3, 0x2, 0x2, 0x2, 0xa0e, 0xa11, 0x5, 0x14a, 0xa6, 0x2, 0xa0f, 
       0xa11, 0x7, 0xa, 0x2, 0x2, 0xa10, 0xa0e, 0x3, 0x2, 0x2, 0x2, 0xa10, 
       0xa0f, 0x3, 0x2, 0x2, 0x2, 0xa10, 0xa11, 0x3, 0x2, 0x2, 0x2, 0xa11, 
       0x169, 0x3, 0x2, 0x2, 0x2, 0xa12, 0xa14, 0x6, 0xb6, 0x7, 0x2, 0xa13, 
       0xa15, 0x7, 0x10, 0x2, 0x2, 0xa14, 0xa13, 0x3, 0x2, 0x2, 0x2, 0xa14, 
       0xa15, 0x3, 0x2, 0x2, 0x2, 0xa15, 0xa16, 0x3, 0x2, 0x2, 0x2, 0xa16, 
       0xa17, 0x5, 0x1b6, 0xdc, 0x2, 0xa17, 0x16b, 0x3, 0x2, 0x2, 0x2, 0xa18, 
       0xa1a, 0x9, 0x2a, 0x2, 0x2, 0xa19, 0xa1b, 0x7, 0x11c, 0x2, 0x2, 0xa1a, 
       0xa19, 0x3, 0x2, 0x2, 0x2, 0xa1a, 0xa1b, 0x3, 0x2, 0x2, 0x2, 0xa1b, 
       0xa1c, 0x3, 0x2, 0x2, 0x2, 0xa1c, 0xa1d, 0x5, 0x148, 0xa5, 0x2, 0xa1d, 
       0x16d, 0x3, 0x2, 0x2, 0x2, 0xa1e, 0xa20, 0x8, 0xb8, 0x1, 0x2, 0xa1f, 
       0xa21, 0x7, 0xc3, 0x2, 0x2, 0xa20, 0xa1f, 0x3, 0x2, 0x2, 0x2, 0xa20, 
       0xa21, 0x3, 0x2, 0x2, 0x2, 0xa21, 0xa22, 0x3, 0x2, 0x2, 0x2, 0xa22, 
       0xa23, 0x7, 0x169, 0x2, 0x2, 0xa23, 0xa24, 0x5, 0x16e, 0xb8, 0x2, 
       0xa24, 0xa25, 0x7, 0x16c, 0x2, 0x2, 0xa25, 0xa28, 0x3, 0x2, 0x2, 
       0x2, 0xa26, 0xa28, 0x5, 0x170, 0xb9, 0x2, 0xa27, 0xa1e, 0x3, 0x2, 
       0x2, 0x2, 0xa27, 0xa26, 0x3, 0x2, 0x2, 0x2, 0xa28, 0xa2f, 0x3, 0x2, 
       0x2, 0x2, 0xa29, 0xa2a, 0xc, 0x4, 0x2, 0x2, 0xa2a, 0xa2b, 0x5, 0x17a, 
       0xbe, 0x2, 0xa2b, 0xa2c, 0x5, 0x16e, 0xb8, 0x5, 0xa2c, 0xa2e, 0x3, 
       0x2, 0x2, 0x2, 0xa2d, 0xa29, 0x3, 0x2, 0x2, 0x2, 0xa2e, 0xa31, 0x3, 
       0x2, 0x2, 0x2, 0xa2f, 0xa2d, 0x3, 0x2, 0x2, 0x2, 0xa2f, 0xa30, 0x3, 
       0x2, 0x2, 0x2, 0xa30, 0x16f, 0x3, 0x2, 0x2, 0x2, 0xa31, 0xa2f, 0x3, 
       0x2, 0x2, 0x2, 0xa32, 0xa36, 0x5, 0x172, 0xba, 0x2, 0xa33, 0xa36, 
       0x5, 0x178, 0xbd, 0x2, 0xa34, 0xa36, 0x5, 0x17e, 0xc0, 0x2, 0xa35, 
       0xa32, 0x3, 0x2, 0x2, 0x2, 0xa35, 0xa33, 0x3, 0x2, 0x2, 0x2, 0xa35, 
       0xa34, 0x3, 0x2, 0x2, 0x2, 0xa36, 0x171, 0x3, 0x2, 0x2, 0x2, 0xa37, 
       0xa38, 0x5, 0x17e, 0xc0, 0x2, 0xa38, 0xa3a, 0x7, 0x9b, 0x2, 0x2, 
       0xa39, 0xa3b, 0x7, 0xc3, 0x2, 0x2, 0xa3a, 0xa39, 0x3, 0x2, 0x2, 0x2, 
       0xa3a, 0xa3b, 0x3, 0x2, 0x2, 0x2, 0xa3b, 0xa3c, 0x3, 0x2, 0x2, 0x2, 
       0xa3c, 0xa3d, 0x7, 0xc5, 0x2, 0x2, 0xa3d, 0xa4f, 0x3, 0x2, 0x2, 0x2, 
       0xa3e, 0xa3f, 0x5, 0x17e, 0xc0, 0x2, 0xa3f, 0xa40, 0x7, 0x18, 0x2, 
       0x2, 0xa40, 0xa41, 0x5, 0x17e, 0xc0, 0x2, 0xa41, 0xa42, 0x7, 0xd, 
       0x2, 0x2, 0xa42, 0xa43, 0x5, 0x17e, 0xc0, 0x2, 0xa43, 0xa4f, 0x3, 
       0x2, 0x2, 0x2, 0xa44, 0xa46, 0x7, 0xc3, 0x2, 0x2, 0xa45, 0xa44, 0x3, 
       0x2, 0x2, 0x2, 0xa45, 0xa46, 0x3, 0x2, 0x2, 0x2, 0xa46, 0xa47, 0x3, 
       0x2, 0x2, 0x2, 0xa47, 0xa48, 0x7, 0x6c, 0x2, 0x2, 0xa48, 0xa49, 0x7, 
       0x169, 0x2, 0x2, 0xa49, 0xa4a, 0x5, 0x118, 0x8d, 0x2, 0xa4a, 0xa4b, 
       0x7, 0x16c, 0x2, 0x2, 0xa4b, 0xa4f, 0x3, 0x2, 0x2, 0x2, 0xa4c, 0xa4f, 
       0x5, 0x174, 0xbb, 0x2, 0xa4d, 0xa4f, 0x5, 0x176, 0xbc, 0x2, 0xa4e, 
       0xa37, 0x3, 0x2, 0x2, 0x2, 0xa4e, 0xa3e, 0x3, 0x2, 0x2, 0x2, 0xa4e, 
       0xa45, 0x3, 0x2, 0x2, 0x2, 0xa4e, 0xa4c, 0x3, 0x2, 0x2, 0x2, 0xa4e, 
       0xa4d, 0x3, 0x2, 0x2, 0x2, 0xa4f, 0x173, 0x3, 0x2, 0x2, 0x2, 0xa50, 
       0xa52, 0x5, 0x17e, 0xc0, 0x2, 0xa51, 0xa53, 0x7, 0xc3, 0x2, 0x2, 
       0xa52, 0xa51, 0x3, 0x2, 0x2, 0x2, 0xa52, 0xa53, 0x3, 0x2, 0x2, 0x2, 
       0xa53, 0xa54, 0x3, 0x2, 0x2, 0x2, 0xa54, 0xa55, 0x7, 0x8b, 0x2, 0x2, 
       0xa55, 0xa5f, 0x7, 0x169, 0x2, 0x2, 0xa56, 0xa5b, 0x5, 0x17e, 0xc0, 
       0x2, 0xa57, 0xa58, 0x7, 0x15b, 0x2, 0x2, 0xa58, 0xa5a, 0x5, 0x17e, 
       0xc0, 0x2, 0xa59, 0xa57, 0x3, 0x2, 0x2, 0x2, 0xa5a, 0xa5d, 0x3, 0x2, 
       0x2, 0x2, 0xa5b, 0xa59, 0x3, 0x2, 0x2, 0x2, 0xa5b, 0xa5c, 0x3, 0x2, 
       0x2, 0x2, 0xa5c, 0xa60, 0x3, 0x2, 0x2, 0x2, 0xa5d, 0xa5b, 0x3, 0x2, 
       0x2, 0x2, 0xa5e, 0xa60, 0x5, 0x118, 0x8d, 0x2, 0xa5f, 0xa56, 0x3, 
       0x2, 0x2, 0x2, 0xa5f, 0xa5e, 0x3, 0x2, 0x2, 0x2, 0xa60, 0xa61, 0x3, 
       0x2, 0x2, 0x2, 0xa61, 0xa62, 0x7, 0x16c, 0x2, 0x2, 0xa62, 0x175, 
       0x3, 0x2, 0x2, 0x2, 0xa63, 0xa64, 0x7, 0x169, 0x2, 0x2, 0xa64, 0xa69, 
       0x5, 0x17e, 0xc0, 0x2, 0xa65, 0xa66, 0x7, 0x15b, 0x2, 0x2, 0xa66, 
       0xa68, 0x5, 0x17e, 0xc0, 0x2, 0xa67, 0xa65, 0x3, 0x2, 0x2, 0x2, 0xa68, 
       0xa6b, 0x3, 0x2, 0x2, 0x2, 0xa69, 0xa67, 0x3, 0x2, 0x2, 0x2, 0xa69, 
       0xa6a, 0x3, 0x2, 0x2, 0x2, 0xa6a, 0xa6c, 0x3, 0x2, 0x2, 0x2, 0xa6b, 
       0xa69, 0x3, 0x2, 0x2, 0x2, 0xa6c, 0xa6e, 0x7, 0x16c, 0x2, 0x2, 0xa6d, 
       0xa6f, 0x7, 0xc3, 0x2, 0x2, 0xa6e, 0xa6d, 0x3, 0x2, 0x2, 0x2, 0xa6e, 
       0xa6f, 0x3, 0x2, 0x2, 0x2, 0xa6f, 0xa70, 0x3, 0x2, 0x2, 0x2, 0xa70, 
       0xa71, 0x7, 0x8b, 0x2, 0x2, 0xa71, 0xa72, 0x7, 0x169, 0x2, 0x2, 0xa72, 
       0xa73, 0x5, 0x118, 0x8d, 0x2, 0xa73, 0xa74, 0x7, 0x16c, 0x2, 0x2, 
       0xa74, 0x177, 0x3, 0x2, 0x2, 0x2, 0xa75, 0xa76, 0x5, 0x17e, 0xc0, 
       0x2, 0xa76, 0xa77, 0x5, 0x17c, 0xbf, 0x2, 0xa77, 0xa78, 0x5, 0x17e, 
       0xc0, 0x2, 0xa78, 0x179, 0x3, 0x2, 0x2, 0x2, 0xa79, 0xa7a, 0x9, 0x2b, 
       0x2, 0x2, 0xa7a, 0x17b, 0x3, 0x2, 0x2, 0x2, 0xa7b, 0xa88, 0x7, 0x15f, 
       0x2, 0x2, 0xa7c, 0xa88, 0x7, 0x160, 0x2, 0x2, 0xa7d, 0xa88, 0x7, 
       0x161, 0x2, 0x2, 0xa7e, 0xa88, 0x7, 0x162, 0x2, 0x2, 0xa7f, 0xa88, 
       0x7, 0x165, 0x2, 0x2, 0xa80, 0xa88, 0x7, 0x166, 0x2, 0x2, 0xa81, 
       0xa88, 0x7, 0x163, 0x2, 0x2, 0xa82, 0xa88, 0x7, 0x164, 0x2, 0x2, 
       0xa83, 0xa85, 0x7, 0xc3, 0x2, 0x2, 0xa84, 0xa83, 0x3, 0x2, 0x2, 0x2, 
       0xa84, 0xa85, 0x3, 0x2, 0x2, 0x2, 0xa85, 0xa86, 0x3, 0x2, 0x2, 0x2, 
       0xa86, 0xa88, 0x9, 0x2c, 0x2, 0x2, 0xa87, 0xa7b, 0x3, 0x2, 0x2, 0x2, 
       0xa87, 0xa7c, 0x3, 0x2, 0x2, 0x2, 0xa87, 0xa7d, 0x3, 0x2, 0x2, 0x2, 
       0xa87, 0xa7e, 0x3, 0x2, 0x2, 0x2, 0xa87, 0xa7f, 0x3, 0x2, 0x2, 0x2, 
       0xa87, 0xa80, 0x3, 0x2, 0x2, 0x2, 0xa87, 0xa81, 0x3, 0x2, 0x2, 0x2, 
       0xa87, 0xa82, 0x3, 0x2, 0x2, 0x2, 0xa87, 0xa84, 0x3, 0x2, 0x2, 0x2, 
       0xa88, 0x17d, 0x3, 0x2, 0x2, 0x2, 0xa89, 0xa8a, 0x8, 0xc0, 0x1, 0x2, 
       0xa8a, 0xa8b, 0x7, 0x169, 0x2, 0x2, 0xa8b, 0xa8c, 0x5, 0x118, 0x8d, 
       0x2, 0xa8c, 0xa8d, 0x7, 0x16c, 0x2, 0x2, 0xa8d, 0xa9b, 0x3, 0x2, 
       0x2, 0x2, 0xa8e, 0xa8f, 0x7, 0x169, 0x2, 0x2, 0xa8f, 0xa90, 0x5, 
       0x17e, 0xc0, 0x2, 0xa90, 0xa91, 0x7, 0x16c, 0x2, 0x2, 0xa91, 0xa9b, 
       0x3, 0x2, 0x2, 0x2, 0xa92, 0xa9b, 0x5, 0x182, 0xc2, 0x2, 0xa93, 0xa9b, 
       0x5, 0x186, 0xc4, 0x2, 0xa94, 0xa9b, 0x5, 0x18a, 0xc6, 0x2, 0xa95, 
       0xa9b, 0x5, 0x190, 0xc9, 0x2, 0xa96, 0xa9b, 0x5, 0x192, 0xca, 0x2, 
       0xa97, 0xa9b, 0x5, 0x19a, 0xce, 0x2, 0xa98, 0xa9b, 0x5, 0x19c, 0xcf, 
       0x2, 0xa99, 0xa9b, 0x5, 0x180, 0xc1, 0x2, 0xa9a, 0xa89, 0x3, 0x2, 
       0x2, 0x2, 0xa9a, 0xa8e, 0x3, 0x2, 0x2, 0x2, 0xa9a, 0xa92, 0x3, 0x2, 
       0x2, 0x2, 0xa9a, 0xa93, 0x3, 0x2, 0x2, 0x2, 0xa9a, 0xa94, 0x3, 0x2, 
       0x2, 0x2, 0xa9a, 0xa95, 0x3, 0x2, 0x2, 0x2, 0xa9a, 0xa96, 0x3, 0x2, 
       0x2, 0x2, 0xa9a, 0xa97, 0x3, 0x2, 0x2, 0x2, 0xa9a, 0xa98, 0x3, 0x2, 
       0x2, 0x2, 0xa9a, 0xa99, 0x3, 0x2, 0x2, 0x2, 0xa9b, 0xaac, 0x3, 0x2, 
       0x2, 0x2, 0xa9c, 0xa9d, 0xc, 0x10, 0x2, 0x2, 0xa9d, 0xa9e, 0x7, 0x167, 
       0x2, 0x2, 0xa9e, 0xaab, 0x5, 0x17e, 0xc0, 0x11, 0xa9f, 0xaa0, 0xc, 
       0xf, 0x2, 0x2, 0xaa0, 0xaa1, 0x7, 0x15d, 0x2, 0x2, 0xaa1, 0xaab, 
       0x5, 0x17e, 0xc0, 0x10, 0xaa2, 0xaa3, 0xc, 0xe, 0x2, 0x2, 0xaa3, 
       0xaa4, 0x7, 0x159, 0x2, 0x2, 0xaa4, 0xaab, 0x5, 0x17e, 0xc0, 0xf, 
       0xaa5, 0xaa6, 0xc, 0xd, 0x2, 0x2, 0xaa6, 0xaa7, 0x7, 0x16f, 0x2, 
       0x2, 0xaa7, 0xaab, 0x5, 0x17e, 0xc0, 0xe, 0xaa8, 0xaa9, 0xc, 0x11, 
       0x2, 0x2, 0xaa9, 0xaab, 0x5, 0x184, 0xc3, 0x2, 0xaaa, 0xa9c, 0x3, 
       0x2, 0x2, 0x2, 0xaaa, 0xa9f, 0x3, 0x2, 0x2, 0x2, 0xaaa, 0xaa2, 0x3, 
       0x2, 0x2, 0x2, 0xaaa, 0xaa5, 0x3, 0x2, 0x2, 0x2, 0xaaa, 0xaa8, 0x3, 
       0x2, 0x2, 0x2, 0xaab, 0xaae, 0x3, 0x2, 0x2, 0x2, 0xaac, 0xaaa, 0x3, 
       0x2, 0x2, 0x2, 0xaac, 0xaad, 0x3, 0x2, 0x2, 0x2, 0xaad, 0x17f, 0x3, 
       0x2, 0x2, 0x2, 0xaae, 0xaac, 0x3, 0x2, 0x2, 0x2, 0xaaf, 0xab8, 0x5, 
       0x1b2, 0xda, 0x2, 0xab0, 0xab8, 0x5, 0x1b4, 0xdb, 0x2, 0xab1, 0xab8, 
       0x5, 0x1be, 0xe0, 0x2, 0xab2, 0xab8, 0x5, 0x1b6, 0xdc, 0x2, 0xab3, 
       0xab8, 0x5, 0x1b8, 0xdd, 0x2, 0xab4, 0xab8, 0x5, 0x1bc, 0xdf, 0x2, 
       0xab5, 0xab8, 0x5, 0x1ba, 0xde, 0x2, 0xab6, 0xab8, 0x5, 0x1c0, 0xe1, 
       0x2, 0xab7, 0xaaf, 0x3, 0x2, 0x2, 0x2, 0xab7, 0xab0, 0x3, 0x2, 0x2, 
       0x2, 0xab7, 0xab1, 0x3, 0x2, 0x2, 0x2, 0xab7, 0xab2, 0x3, 0x2, 0x2, 
       0x2, 0xab7, 0xab3, 0x3, 0x2, 0x2, 0x2, 0xab7, 0xab4, 0x3, 0x2, 0x2, 
       0x2, 0xab7, 0xab5, 0x3, 0x2, 0x2, 0x2, 0xab7, 0xab6, 0x3, 0x2, 0x2, 
       0x2, 0xab8, 0x181, 0x3, 0x2, 0x2, 0x2, 0xab9, 0xaba, 0x7, 0x98, 0x2, 
       0x2, 0xaba, 0xabb, 0x5, 0x17e, 0xc0, 0x2, 0xabb, 0xabc, 0x5, 0x184, 
       0xc3, 0x2, 0xabc, 0x183, 0x3, 0x2, 0x2, 0x2, 0xabd, 0xabe, 0x9, 0x2d, 
       0x2, 0x2, 0xabe, 0x185, 0x3, 0x2, 0x2, 0x2, 0xabf, 0xac0, 0x5, 0x188, 
       0xc5, 0x2, 0xac0, 0xac1, 0x9, 0x2e, 0x2, 0x2, 0xac1, 0xac6, 0x5, 
       0x188, 0xc5, 0x2, 0xac2, 0xac3, 0x9, 0x2e, 0x2, 0x2, 0xac3, 0xac5, 
       0x5, 0x188, 0xc5, 0x2, 0xac4, 0xac2, 0x3, 0x2, 0x2, 0x2, 0xac5, 0xac8, 
       0x3, 0x2, 0x2, 0x2, 0xac6, 0xac4, 0x3, 0x2, 0x2, 0x2, 0xac6, 0xac7, 
       0x3, 0x2, 0x2, 0x2, 0xac7, 0x187, 0x3, 0x2, 0x2, 0x2, 0xac8, 0xac6, 
       0x3, 0x2, 0x2, 0x2, 0xac9, 0xaca, 0x7, 0x169, 0x2, 0x2, 0xaca, 0xacb, 
       0x5, 0x17e, 0xc0, 0x2, 0xacb, 0xacc, 0x7, 0x16c, 0x2, 0x2, 0xacc, 
       0xad3, 0x3, 0x2, 0x2, 0x2, 0xacd, 0xad3, 0x5, 0x18a, 0xc6, 0x2, 0xace, 
       0xad3, 0x5, 0x192, 0xca, 0x2, 0xacf, 0xad3, 0x5, 0x19a, 0xce, 0x2, 
       0xad0, 0xad3, 0x5, 0x19c, 0xcf, 0x2, 0xad1, 0xad3, 0x5, 0x180, 0xc1, 
       0x2, 0xad2, 0xac9, 0x3, 0x2, 0x2, 0x2, 0xad2, 0xacd, 0x3, 0x2, 0x2, 
       0x2, 0xad2, 0xace, 0x3, 0x2, 0x2, 0x2, 0xad2, 0xacf, 0x3, 0x2, 0x2, 
       0x2, 0xad2, 0xad0, 0x3, 0x2, 0x2, 0x2, 0xad2, 0xad1, 0x3, 0x2, 0x2, 
       0x2, 0xad3, 0x189, 0x3, 0x2, 0x2, 0x2, 0xad4, 0xad7, 0x5, 0x18c, 
       0xc7, 0x2, 0xad5, 0xad7, 0x5, 0x18e, 0xc8, 0x2, 0xad6, 0xad4, 0x3, 
       0x2, 0x2, 0x2, 0xad6, 0xad5, 0x3, 0x2, 0x2, 0x2, 0xad7, 0x18b, 0x3, 
       0x2, 0x2, 0x2, 0xad8, 0xad9, 0x7, 0x25, 0x2, 0x2, 0xad9, 0xadf, 0x5, 
       0x17e, 0xc0, 0x2, 0xada, 0xadb, 0x7, 0x138, 0x2, 0x2, 0xadb, 0xadc, 
       0x5, 0x17e, 0xc0, 0x2, 0xadc, 0xadd, 0x7, 0x121, 0x2, 0x2, 0xadd, 
       0xade, 0x5, 0x17e, 0xc0, 0x2, 0xade, 0xae0, 0x3, 0x2, 0x2, 0x2, 0xadf, 
       0xada, 0x3, 0x2, 0x2, 0x2, 0xae0, 0xae1, 0x3, 0x2, 0x2, 0x2, 0xae1, 
       0xadf, 0x3, 0x2, 0x2, 0x2, 0xae1, 0xae2, 0x3, 0x2, 0x2, 0x2, 0xae2, 
       0xae5, 0x3, 0x2, 0x2, 0x2, 0xae3, 0xae4, 0x7, 0x60, 0x2, 0x2, 0xae4, 
       0xae6, 0x5, 0x17e, 0xc0, 0x2, 0xae5, 0xae3, 0x3, 0x2, 0x2, 0x2, 0xae5, 
       0xae6, 0x3, 0x2, 0x2, 0x2, 0xae6, 0xae7, 0x3, 0x2, 0x2, 0x2, 0xae7, 
       0xae8, 0x7, 0x64, 0x2, 0x2, 0xae8, 0x18d, 0x3, 0x2, 0x2, 0x2, 0xae9, 
       0xaef, 0x7, 0x25, 0x2, 0x2, 0xaea, 0xaeb, 0x7, 0x138, 0x2, 0x2, 0xaeb, 
       0xaec, 0x5, 0x16e, 0xb8, 0x2, 0xaec, 0xaed, 0x7, 0x121, 0x2, 0x2, 
       0xaed, 0xaee, 0x5, 0x17e, 0xc0, 0x2, 0xaee, 0xaf0, 0x3, 0x2, 0x2, 
       0x2, 0xaef, 0xaea, 0x3, 0x2, 0x2, 0x2, 0xaf0, 0xaf1, 0x3, 0x2, 0x2, 
       0x2, 0xaf1, 0xaef, 0x3, 0x2, 0x2, 0x2, 0xaf1, 0xaf2, 0x3, 0x2, 0x2, 
       0x2, 0xaf2, 0xaf5, 0x3, 0x2, 0x2, 0x2, 0xaf3, 0xaf4, 0x7, 0x60, 0x2, 
       0x2, 0xaf4, 0xaf6, 0x5, 0x17e, 0xc0, 0x2, 0xaf5, 0xaf3, 0x3, 0x2, 
       0x2, 0x2, 0xaf5, 0xaf6, 0x3, 0x2, 0x2, 0x2, 0xaf6, 0xaf7, 0x3, 0x2, 
       0x2, 0x2, 0xaf7, 0xaf8, 0x7, 0x64, 0x2, 0x2, 0xaf8, 0x18f, 0x3, 0x2, 
       0x2, 0x2, 0xaf9, 0xafa, 0x5, 0x1b6, 0xdc, 0x2, 0xafa, 0xafb, 0x7, 
       0x5, 0x2, 0x2, 0xafb, 0xafc, 0x9, 0x2f, 0x2, 0x2, 0xafc, 0x191, 0x3, 
       0x2, 0x2, 0x2, 0xafd, 0xafe, 0x7, 0x15, 0x2, 0x2, 0xafe, 0xb00, 0x7, 
       0x169, 0x2, 0x2, 0xaff, 0xb01, 0x5, 0x194, 0xcb, 0x2, 0xb00, 0xaff, 
       0x3, 0x2, 0x2, 0x2, 0xb00, 0xb01, 0x3, 0x2, 0x2, 0x2, 0xb01, 0xb02, 
       0x3, 0x2, 0x2, 0x2, 0xb02, 0xb03, 0x5, 0x17e, 0xc0, 0x2, 0xb03, 0xb05, 
       0x7, 0x16c, 0x2, 0x2, 0xb04, 0xb06, 0x5, 0x196, 0xcc, 0x2, 0xb05, 
       0xb04, 0x3, 0x2, 0x2, 0x2, 0xb05, 0xb06, 0x3, 0x2, 0x2, 0x2, 0xb06, 
       0xb96, 0x3, 0x2, 0x2, 0x2, 0xb07, 0xb08, 0x7, 0x3b, 0x2, 0x2, 0xb08, 
       0xb0e, 0x7, 0x169, 0x2, 0x2, 0xb09, 0xb0b, 0x5, 0x194, 0xcb, 0x2, 
       0xb0a, 0xb09, 0x3, 0x2, 0x2, 0x2, 0xb0a, 0xb0b, 0x3, 0x2, 0x2, 0x2, 
       0xb0b, 0xb0c, 0x3, 0x2, 0x2, 0x2, 0xb0c, 0xb0f, 0x5, 0x17e, 0xc0, 
       0x2, 0xb0d, 0xb0f, 0x7, 0x167, 0x2, 0x2, 0xb0e, 0xb0a, 0x3, 0x2, 
       0x2, 0x2, 0xb0e, 0xb0d, 0x3, 0x2, 0x2, 0x2, 0xb0f, 0xb10, 0x3, 0x2, 
       0x2, 0x2, 0xb10, 0xb12, 0x7, 0x16c, 0x2, 0x2, 0xb11, 0xb13, 0x5, 
       0x196, 0xcc, 0x2, 0xb12, 0xb11, 0x3, 0x2, 0x2, 0x2, 0xb12, 0xb13, 
       0x3, 0x2, 0x2, 0x2, 0xb13, 0xb96, 0x3, 0x2, 0x2, 0x2, 0xb14, 0xb15, 
       0x7, 0x3c, 0x2, 0x2, 0xb15, 0xb1b, 0x7, 0x169, 0x2, 0x2, 0xb16, 0xb18, 
       0x5, 0x194, 0xcb, 0x2, 0xb17, 0xb16, 0x3, 0x2, 0x2, 0x2, 0xb17, 0xb18, 
       0x3, 0x2, 0x2, 0x2, 0xb18, 0xb19, 0x3, 0x2, 0x2, 0x2, 0xb19, 0xb1c, 
       0x5, 0x17e, 0xc0, 0x2, 0xb1a, 0xb1c, 0x7, 0x167, 0x2, 0x2, 0xb1b, 
       0xb17, 0x3, 0x2, 0x2, 0x2, 0xb1b, 0xb1a, 0x3, 0x2, 0x2, 0x2, 0xb1c, 
       0xb1d, 0x3, 0x2, 0x2, 0x2, 0xb1d, 0xb1f, 0x7, 0x16c, 0x2, 0x2, 0xb1e, 
       0xb20, 0x5, 0x196, 0xcc, 0x2, 0xb1f, 0xb1e, 0x3, 0x2, 0x2, 0x2, 0xb1f, 
       0xb20, 0x3, 0x2, 0x2, 0x2, 0xb20, 0xb96, 0x3, 0x2, 0x2, 0x2, 0xb21, 
       0xb22, 0x7, 0x142, 0x2, 0x2, 0xb22, 0xb23, 0x7, 0x169, 0x2, 0x2, 
       0xb23, 0xb24, 0x7, 0x16c, 0x2, 0x2, 0xb24, 0xb96, 0x5, 0x196, 0xcc, 
       0x2, 0xb25, 0xb26, 0x7, 0x146, 0x2, 0x2, 0xb26, 0xb27, 0x7, 0x169, 
       0x2, 0x2, 0xb27, 0xb28, 0x7, 0x16c, 0x2, 0x2, 0xb28, 0xb96, 0x5, 
       0x196, 0xcc, 0x2, 0xb29, 0xb2a, 0x7, 0x147, 0x2, 0x2, 0xb2a, 0xb2b, 
       0x7, 0x169, 0x2, 0x2, 0xb2b, 0xb2c, 0x5, 0x17e, 0xc0, 0x2, 0xb2c, 
       0xb2d, 0x7, 0x16c, 0x2, 0x2, 0xb2d, 0xb2e, 0x5, 0x196, 0xcc, 0x2, 
       0xb2e, 0xb96, 0x3, 0x2, 0x2, 0x2, 0xb2f, 0xb30, 0x7, 0x148, 0x2, 
       0x2, 0xb30, 0xb31, 0x7, 0x169, 0x2, 0x2, 0xb31, 0xb38, 0x5, 0x17e, 
       0xc0, 0x2, 0xb32, 0xb33, 0x7, 0x15b, 0x2, 0x2, 0xb33, 0xb36, 0x5, 
       0x17e, 0xc0, 0x2, 0xb34, 0xb35, 0x7, 0x15b, 0x2, 0x2, 0xb35, 0xb37, 
       0x5, 0x17e, 0xc0, 0x2, 0xb36, 0xb34, 0x3, 0x2, 0x2, 0x2, 0xb36, 0xb37, 
       0x3, 0x2, 0x2, 0x2, 0xb37, 0xb39, 0x3, 0x2, 0x2, 0x2, 0xb38, 0xb32, 
       0x3, 0x2, 0x2, 0x2, 0xb38, 0xb39, 0x3, 0x2, 0x2, 0x2, 0xb39, 0xb3a, 
       0x3, 0x2, 0x2, 0x2, 0xb3a, 0xb3b, 0x7, 0x16c, 0x2, 0x2, 0xb3b, 0xb3c, 
       0x5, 0x196, 0xcc, 0x2, 0xb3c, 0xb96, 0x3, 0x2, 0x2, 0x2, 0xb3d, 0xb3e, 
       0x7, 0x149, 0x2, 0x2, 0xb3e, 0xb3f, 0x7, 0x169, 0x2, 0x2, 0xb3f, 
       0xb40, 0x5, 0x17e, 0xc0, 0x2, 0xb40, 0xb41, 0x7, 0x16c, 0x2, 0x2, 
       0xb41, 0xb42, 0x5, 0x196, 0xcc, 0x2, 0xb42, 0xb96, 0x3, 0x2, 0x2, 
       0x2, 0xb43, 0xb44, 0x7, 0x14a, 0x2, 0x2, 0xb44, 0xb45, 0x7, 0x169, 
       0x2, 0x2, 0xb45, 0xb4c, 0x5, 0x17e, 0xc0, 0x2, 0xb46, 0xb47, 0x7, 
       0x15b, 0x2, 0x2, 0xb47, 0xb4a, 0x5, 0x17e, 0xc0, 0x2, 0xb48, 0xb49, 
       0x7, 0x15b, 0x2, 0x2, 0xb49, 0xb4b, 0x5, 0x17e, 0xc0, 0x2, 0xb4a, 
       0xb48, 0x3, 0x2, 0x2, 0x2, 0xb4a, 0xb4b, 0x3, 0x2, 0x2, 0x2, 0xb4b, 
       0xb4d, 0x3, 0x2, 0x2, 0x2, 0xb4c, 0xb46, 0x3, 0x2, 0x2, 0x2, 0xb4c, 
       0xb4d, 0x3, 0x2, 0x2, 0x2, 0xb4d, 0xb4e, 0x3, 0x2, 0x2, 0x2, 0xb4e, 
       0xb4f, 0x7, 0x16c, 0x2, 0x2, 0xb4f, 0xb50, 0x5, 0x196, 0xcc, 0x2, 
       0xb50, 0xb96, 0x3, 0x2, 0x2, 0x2, 0xb51, 0xb52, 0x7, 0xb3, 0x2, 0x2, 
       0xb52, 0xb54, 0x7, 0x169, 0x2, 0x2, 0xb53, 0xb55, 0x5, 0x194, 0xcb, 
       0x2, 0xb54, 0xb53, 0x3, 0x2, 0x2, 0x2, 0xb54, 0xb55, 0x3, 0x2, 0x2, 
       0x2, 0xb55, 0xb56, 0x3, 0x2, 0x2, 0x2, 0xb56, 0xb57, 0x5, 0x17e, 
       0xc0, 0x2, 0xb57, 0xb59, 0x7, 0x16c, 0x2, 0x2, 0xb58, 0xb5a, 0x5, 
       0x196, 0xcc, 0x2, 0xb59, 0xb58, 0x3, 0x2, 0x2, 0x2, 0xb59, 0xb5a, 
       0x3, 0x2, 0x2, 0x2, 0xb5a, 0xb96, 0x3, 0x2, 0x2, 0x2, 0xb5b, 0xb5c, 
       0x7, 0xb9, 0x2, 0x2, 0xb5c, 0xb5e, 0x7, 0x169, 0x2, 0x2, 0xb5d, 0xb5f, 
       0x5, 0x194, 0xcb, 0x2, 0xb5e, 0xb5d, 0x3, 0x2, 0x2, 0x2, 0xb5e, 0xb5f, 
       0x3, 0x2, 0x2, 0x2, 0xb5f, 0xb60, 0x3, 0x2, 0x2, 0x2, 0xb60, 0xb61, 
       0x5, 0x17e, 0xc0, 0x2, 0xb61, 0xb63, 0x7, 0x16c, 0x2, 0x2, 0xb62, 
       0xb64, 0x5, 0x196, 0xcc, 0x2, 0xb63, 0xb62, 0x3, 0x2, 0x2, 0x2, 0xb63, 
       0xb64, 0x3, 0x2, 0x2, 0x2, 0xb64, 0xb96, 0x3, 0x2, 0x2, 0x2, 0xb65, 
       0xb66, 0x7, 0x153, 0x2, 0x2, 0xb66, 0xb67, 0x7, 0x169, 0x2, 0x2, 
       0xb67, 0xb68, 0x7, 0x16c, 0x2, 0x2, 0xb68, 0xb96, 0x5, 0x196, 0xcc, 
       0x2, 0xb69, 0xb6a, 0x7, 0x154, 0x2, 0x2, 0xb6a, 0xb6b, 0x7, 0x169, 
       0x2, 0x2, 0xb6b, 0xb6c, 0x7, 0x16c, 0x2, 0x2, 0xb6c, 0xb96, 0x5, 
       0x196, 0xcc, 0x2, 0xb6d, 0xb6e, 0x7, 0x155, 0x2, 0x2, 0xb6e, 0xb70, 
       0x7, 0x169, 0x2, 0x2, 0xb6f, 0xb71, 0x5, 0x194, 0xcb, 0x2, 0xb70, 
       0xb6f, 0x3, 0x2, 0x2, 0x2, 0xb70, 0xb71, 0x3, 0x2, 0x2, 0x2, 0xb71, 
       0xb72, 0x3, 0x2, 0x2, 0x2, 0xb72, 0xb73, 0x5, 0x17e, 0xc0, 0x2, 0xb73, 
       0xb75, 0x7, 0x16c, 0x2, 0x2, 0xb74, 0xb76, 0x5, 0x196, 0xcc, 0x2, 
       0xb75, 0xb74, 0x3, 0x2, 0x2, 0x2, 0xb75, 0xb76, 0x3, 0x2, 0x2, 0x2, 
       0xb76, 0xb96, 0x3, 0x2, 0x2, 0x2, 0xb77, 0xb78, 0x7, 0x11a, 0x2, 
       0x2, 0xb78, 0xb7a, 0x7, 0x169, 0x2, 0x2, 0xb79, 0xb7b, 0x5, 0x194, 
       0xcb, 0x2, 0xb7a, 0xb79, 0x3, 0x2, 0x2, 0x2, 0xb7a, 0xb7b, 0x3, 0x2, 
       0x2, 0x2, 0xb7b, 0xb7c, 0x3, 0x2, 0x2, 0x2, 0xb7c, 0xb7d, 0x5, 0x17e, 
       0xc0, 0x2, 0xb7d, 0xb7f, 0x7, 0x16c, 0x2, 0x2, 0xb7e, 0xb80, 0x5, 
       0x196, 0xcc, 0x2, 0xb7f, 0xb7e, 0x3, 0x2, 0x2, 0x2, 0xb7f, 0xb80, 
       0x3, 0x2, 0x2, 0x2, 0xb80, 0xb96, 0x3, 0x2, 0x2, 0x2, 0xb81, 0xb82, 
       0x7, 0x133, 0x2, 0x2, 0xb82, 0xb84, 0x7, 0x169, 0x2, 0x2, 0xb83, 
       0xb85, 0x5, 0x194, 0xcb, 0x2, 0xb84, 0xb83, 0x3, 0x2, 0x2, 0x2, 0xb84, 
       0xb85, 0x3, 0x2, 0x2, 0x2, 0xb85, 0xb86, 0x3, 0x2, 0x2, 0x2, 0xb86, 
       0xb87, 0x5, 0x17e, 0xc0, 0x2, 0xb87, 0xb89, 0x7, 0x16c, 0x2, 0x2, 
       0xb88, 0xb8a, 0x5, 0x196, 0xcc, 0x2, 0xb89, 0xb88, 0x3, 0x2, 0x2, 
       0x2, 0xb89, 0xb8a, 0x3, 0x2, 0x2, 0x2, 0xb8a, 0xb96, 0x3, 0x2, 0x2, 
       0x2, 0xb8b, 0xb8c, 0x7, 0x157, 0x2, 0x2, 0xb8c, 0xb8e, 0x7, 0x169, 
       0x2, 0x2, 0xb8d, 0xb8f, 0x5, 0x194, 0xcb, 0x2, 0xb8e, 0xb8d, 0x3, 
       0x2, 0x2, 0x2, 0xb8e, 0xb8f, 0x3, 0x2, 0x2, 0x2, 0xb8f, 0xb90, 0x3, 
       0x2, 0x2, 0x2, 0xb90, 0xb91, 0x5, 0x17e, 0xc0, 0x2, 0xb91, 0xb93, 
       0x7, 0x16c, 0x2, 0x2, 0xb92, 0xb94, 0x5, 0x196, 0xcc, 0x2, 0xb93, 
       0xb92, 0x3, 0x2, 0x2, 0x2, 0xb93, 0xb94, 0x3, 0x2, 0x2, 0x2, 0xb94, 
       0xb96, 0x3, 0x2, 0x2, 0x2, 0xb95, 0xafd, 0x3, 0x2, 0x2, 0x2, 0xb95, 
       0xb07, 0x3, 0x2, 0x2, 0x2, 0xb95, 0xb14, 0x3, 0x2, 0x2, 0x2, 0xb95, 
       0xb21, 0x3, 0x2, 0x2, 0x2, 0xb95, 0xb25, 0x3, 0x2, 0x2, 0x2, 0xb95, 
       0xb29, 0x3, 0x2, 0x2, 0x2, 0xb95, 0xb2f, 0x3, 0x2, 0x2, 0x2, 0xb95, 
       0xb3d, 0x3, 0x2, 0x2, 0x2, 0xb95, 0xb43, 0x3, 0x2, 0x2, 0x2, 0xb95, 
       0xb51, 0x3, 0x2, 0x2, 0x2, 0xb95, 0xb5b, 0x3, 0x2, 0x2, 0x2, 0xb95, 
       0xb65, 0x3, 0x2, 0x2, 0x2, 0xb95, 0xb69, 0x3, 0x2, 0x2, 0x2, 0xb95, 
       0xb6d, 0x3, 0x2, 0x2, 0x2, 0xb95, 0xb77, 0x3, 0x2, 0x2, 0x2, 0xb95, 
       0xb81, 0x3, 0x2, 0x2, 0x2, 0xb95, 0xb8b, 0x3, 0x2, 0x2, 0x2, 0xb96, 
       0x193, 0x3, 0x2, 0x2, 0x2, 0xb97, 0xb98, 0x9, 0x26, 0x2, 0x2, 0xb98, 
       0x195, 0x3, 0x2, 0x2, 0x2, 0xb99, 0xb9a, 0x7, 0xd1, 0x2, 0x2, 0xb9a, 
       0xb9c, 0x7, 0x169, 0x2, 0x2, 0xb9b, 0xb9d, 0x5, 0x198, 0xcd, 0x2, 
       0xb9c, 0xb9b, 0x3, 0x2, 0x2, 0x2, 0xb9c, 0xb9d, 0x3, 0x2, 0x2, 0x2, 
       0xb9d, 0xb9f, 0x3, 0x2, 0x2, 0x2, 0xb9e, 0xba0, 0x5, 0x152, 0xaa, 
       0x2, 0xb9f, 0xb9e, 0x3, 0x2, 0x2, 0x2, 0xb9f, 0xba0, 0x3, 0x2, 0x2, 
       0x2, 0xba0, 0xba1, 0x3, 0x2, 0x2, 0x2, 0xba1, 0xba2, 0x7, 0x16c, 
       0x2, 0x2, 0xba2, 0x197, 0x3, 0x2, 0x2, 0x2, 0xba3, 0xba4, 0x7, 0xd5, 
       0x2, 0x2, 0xba4, 0xba5, 0x7, 0x20, 0x2, 0x2, 0xba5, 0xbaa, 0x5, 0x17e, 
       0xc0, 0x2, 0xba6, 0xba7, 0x7, 0x15b, 0x2, 0x2, 0xba7, 0xba9, 0x5, 
       0x17e, 0xc0, 0x2, 0xba8, 0xba6, 0x3, 0x2, 0x2, 0x2, 0xba9, 0xbac, 
       0x3, 0x2, 0x2, 0x2, 0xbaa, 0xba8, 0x3, 0x2, 0x2, 0x2, 0xbaa, 0xbab, 
       0x3, 0x2, 0x2, 0x2, 0xbab, 0x199, 0x3, 0x2, 0x2, 0x2, 0xbac, 0xbaa, 
       0x3, 0x2, 0x2, 0x2, 0xbad, 0xc76, 0x7, 0x141, 0x2, 0x2, 0xbae, 0xbaf, 
       0x7, 0x27, 0x2, 0x2, 0xbaf, 0xbb0, 0x7, 0x169, 0x2, 0x2, 0xbb0, 0xbb1, 
       0x5, 0x17e, 0xc0, 0x2, 0xbb1, 0xbb2, 0x7, 0x10, 0x2, 0x2, 0xbb2, 
       0xbb4, 0x5, 0x78, 0x3d, 0x2, 0xbb3, 0xbb5, 0x5, 0x7a, 0x3e, 0x2, 
       0xbb4, 0xbb3, 0x3, 0x2, 0x2, 0x2, 0xbb4, 0xbb5, 0x3, 0x2, 0x2, 0x2, 
       0xbb5, 0xbb6, 0x3, 0x2, 0x2, 0x2, 0xbb6, 0xbb7, 0x7, 0x16c, 0x2, 
       0x2, 0xbb7, 0xc76, 0x3, 0x2, 0x2, 0x2, 0xbb8, 0xbb9, 0x7, 0x3b, 0x2, 
       0x2, 0xbb9, 0xbbc, 0x7, 0x169, 0x2, 0x2, 0xbba, 0xbbd, 0x5, 0x17e, 
       0xc0, 0x2, 0xbbb, 0xbbd, 0x7, 0x167, 0x2, 0x2, 0xbbc, 0xbba, 0x3, 
       0x2, 0x2, 0x2, 0xbbc, 0xbbb, 0x3, 0x2, 0x2, 0x2, 0xbbd, 0xbbe, 0x3, 
       0x2, 0x2, 0x2, 0xbbe, 0xc76, 0x7, 0x16c, 0x2, 0x2, 0xbbf, 0xc76, 
       0x7, 0x143, 0x2, 0x2, 0xbc0, 0xbc1, 0x7, 0x41, 0x2, 0x2, 0xbc1, 0xc76, 
       0x7, 0x46, 0x2, 0x2, 0xbc2, 0xbc6, 0x7, 0x144, 0x2, 0x2, 0xbc3, 0xbc4, 
       0x7, 0x41, 0x2, 0x2, 0xbc4, 0xbc6, 0x7, 0x122, 0x2, 0x2, 0xbc5, 0xbc2, 
       0x3, 0x2, 0x2, 0x2, 0xbc5, 0xbc3, 0x3, 0x2, 0x2, 0x2, 0xbc6, 0xbcb, 
       0x3, 0x2, 0x2, 0x2, 0xbc7, 0xbc8, 0x7, 0x169, 0x2, 0x2, 0xbc8, 0xbc9, 
       0x5, 0x17e, 0xc0, 0x2, 0xbc9, 0xbca, 0x7, 0x16c, 0x2, 0x2, 0xbca, 
       0xbcc, 0x3, 0x2, 0x2, 0x2, 0xbcb, 0xbc7, 0x3, 0x2, 0x2, 0x2, 0xbcb, 
       0xbcc, 0x3, 0x2, 0x2, 0x2, 0xbcc, 0xc76, 0x3, 0x2, 0x2, 0x2, 0xbcd, 
       0xc76, 0x7, 0x145, 0x2, 0x2, 0xbce, 0xbcf, 0x7, 0x41, 0x2, 0x2, 0xbcf, 
       0xc76, 0x7, 0x158, 0x2, 0x2, 0xbd0, 0xbd1, 0x7, 0x14b, 0x2, 0x2, 
       0xbd1, 0xbd2, 0x7, 0x169, 0x2, 0x2, 0xbd2, 0xbdf, 0x5, 0x17e, 0xc0, 
       0x2, 0xbd3, 0xbd4, 0x7, 0x15b, 0x2, 0x2, 0xbd4, 0xbdc, 0x5, 0x17e, 
       0xc0, 0x2, 0xbd5, 0xbd6, 0x7, 0x15b, 0x2, 0x2, 0xbd6, 0xbd7, 0x5, 
       0x17e, 0xc0, 0x2, 0xbd7, 0xbd8, 0x7, 0x15f, 0x2, 0x2, 0xbd8, 0xbd9, 
       0x5, 0x17e, 0xc0, 0x2, 0xbd9, 0xbdb, 0x3, 0x2, 0x2, 0x2, 0xbda, 0xbd5, 
       0x3, 0x2, 0x2, 0x2, 0xbdb, 0xbde, 0x3, 0x2, 0x2, 0x2, 0xbdc, 0xbda, 
       0x3, 0x2, 0x2, 0x2, 0xbdc, 0xbdd, 0x3, 0x2, 0x2, 0x2, 0xbdd, 0xbe0, 
       0x3, 0x2, 0x2, 0x2, 0xbde, 0xbdc, 0x3, 0x2, 0x2, 0x2, 0xbdf, 0xbd3, 
       0x3, 0x2, 0x2, 0x2, 0xbdf, 0xbe0, 0x3, 0x2, 0x2, 0x2, 0xbe0, 0xbe1, 
       0x3, 0x2, 0x2, 0x2, 0xbe1, 0xbe2, 0x7, 0x16c, 0x2, 0x2, 0xbe2, 0xc76, 
       0x3, 0x2, 0x2, 0x2, 0xbe3, 0xbe4, 0x7, 0x14c, 0x2, 0x2, 0xbe4, 0xbe5, 
       0x7, 0x169, 0x2, 0x2, 0xbe5, 0xbf2, 0x5, 0x17e, 0xc0, 0x2, 0xbe6, 
       0xbe7, 0x7, 0x15b, 0x2, 0x2, 0xbe7, 0xbef, 0x5, 0x17e, 0xc0, 0x2, 
       0xbe8, 0xbe9, 0x7, 0x15b, 0x2, 0x2, 0xbe9, 0xbea, 0x5, 0x17e, 0xc0, 
       0x2, 0xbea, 0xbeb, 0x7, 0x15f, 0x2, 0x2, 0xbeb, 0xbec, 0x5, 0x17e, 
       0xc0, 0x2, 0xbec, 0xbee, 0x3, 0x2, 0x2, 0x2, 0xbed, 0xbe8, 0x3, 0x2, 
       0x2, 0x2, 0xbee, 0xbf1, 0x3, 0x2, 0x2, 0x2, 0xbef, 0xbed, 0x3, 0x2, 
       0x2, 0x2, 0xbef, 0xbf0, 0x3, 0x2, 0x2, 0x2, 0xbf0, 0xbf3, 0x3, 0x2, 
       0x2, 0x2, 0xbf1, 0xbef, 0x3, 0x2, 0x2, 0x2, 0xbf2, 0xbe6, 0x3, 0x2, 
       0x2, 0x2, 0xbf2, 0xbf3, 0x3, 0x2, 0x2, 0x2, 0xbf3, 0xbf4, 0x3, 0x2, 
       0x2, 0x2, 0xbf4, 0xbf5, 0x7, 0x16c, 0x2, 0x2, 0xbf5, 0xc76, 0x3, 
       0x2, 0x2, 0x2, 0xbf6, 0xbf7, 0x7, 0x14d, 0x2, 0x2, 0xbf7, 0xbf8, 
       0x7, 0x169, 0x2, 0x2, 0xbf8, 0xc05, 0x5, 0x17e, 0xc0, 0x2, 0xbf9, 
       0xbfa, 0x7, 0x15b, 0x2, 0x2, 0xbfa, 0xc02, 0x5, 0x17e, 0xc0, 0x2, 
       0xbfb, 0xbfc, 0x7, 0x15b, 0x2, 0x2, 0xbfc, 0xbfd, 0x5, 0x17e, 0xc0, 
       0x2, 0xbfd, 0xbfe, 0x7, 0x15f, 0x2, 0x2, 0xbfe, 0xbff, 0x5, 0x17e, 
       0xc0, 0x2, 0xbff, 0xc01, 0x3, 0x2, 0x2, 0x2, 0xc00, 0xbfb, 0x3, 0x2, 
       0x2, 0x2, 0xc01, 0xc04, 0x3, 0x2, 0x2, 0x2, 0xc02, 0xc00, 0x3, 0x2, 
       0x2, 0x2, 0xc02, 0xc03, 0x3, 0x2, 0x2, 0x2, 0xc03, 0xc06, 0x3, 0x2, 
       0x2, 0x2, 0xc04, 0xc02, 0x3, 0x2, 0x2, 0x2, 0xc05, 0xbf9, 0x3, 0x2, 
       0x2, 0x2, 0xc05, 0xc06, 0x3, 0x2, 0x2, 0x2, 0xc06, 0xc07, 0x3, 0x2, 
       0x2, 0x2, 0xc07, 0xc08, 0x7, 0x16c, 0x2, 0x2, 0xc08, 0xc76, 0x3, 
       0x2, 0x2, 0x2, 0xc09, 0xc0a, 0x7, 0x14e, 0x2, 0x2, 0xc0a, 0xc0b, 
       0x7, 0x169, 0x2, 0x2, 0xc0b, 0xc18, 0x5, 0x17e, 0xc0, 0x2, 0xc0c, 
       0xc0d, 0x7, 0x15b, 0x2, 0x2, 0xc0d, 0xc15, 0x5, 0x17e, 0xc0, 0x2, 
       0xc0e, 0xc0f, 0x7, 0x15b, 0x2, 0x2, 0xc0f, 0xc10, 0x5, 0x17e, 0xc0, 
       0x2, 0xc10, 0xc11, 0x7, 0x15f, 0x2, 0x2, 0xc11, 0xc12, 0x5, 0x17e, 
       0xc0, 0x2, 0xc12, 0xc14, 0x3, 0x2, 0x2, 0x2, 0xc13, 0xc0e, 0x3, 0x2, 
       0x2, 0x2, 0xc14, 0xc17, 0x3, 0x2, 0x2, 0x2, 0xc15, 0xc13, 0x3, 0x2, 
       0x2, 0x2, 0xc15, 0xc16, 0x3, 0x2, 0x2, 0x2, 0xc16, 0xc19, 0x3, 0x2, 
       0x2, 0x2, 0xc17, 0xc15, 0x3, 0x2, 0x2, 0x2, 0xc18, 0xc0c, 0x3, 0x2, 
       0x2, 0x2, 0xc18, 0xc19, 0x3, 0x2, 0x2, 0x2, 0xc19, 0xc1a, 0x3, 0x2, 
       0x2, 0x2, 0xc1a, 0xc1b, 0x7, 0x16c, 0x2, 0x2, 0xc1b, 0xc76, 0x3, 
       0x2, 0x2, 0x2, 0xc1c, 0xc1d, 0x7, 0x14f, 0x2, 0x2, 0xc1d, 0xc1e, 
       0x7, 0x169, 0x2, 0x2, 0xc1e, 0xc2b, 0x5, 0x17e, 0xc0, 0x2, 0xc1f, 
       0xc20, 0x7, 0x15b, 0x2, 0x2, 0xc20, 0xc28, 0x5, 0x17e, 0xc0, 0x2, 
       0xc21, 0xc22, 0x7, 0x15b, 0x2, 0x2, 0xc22, 0xc23, 0x5, 0x17e, 0xc0, 
       0x2, 0xc23, 0xc24, 0x7, 0x15f, 0x2, 0x2, 0xc24, 0xc25, 0x5, 0x17e, 
       0xc0, 0x2, 0xc25, 0xc27, 0x3, 0x2, 0x2, 0x2, 0xc26, 0xc21, 0x3, 0x2, 
       0x2, 0x2, 0xc27, 0xc2a, 0x3, 0x2, 0x2, 0x2, 0xc28, 0xc26, 0x3, 0x2, 
       0x2, 0x2, 0xc28, 0xc29, 0x3, 0x2, 0x2, 0x2, 0xc29, 0xc2c, 0x3, 0x2, 
       0x2, 0x2, 0xc2a, 0xc28, 0x3, 0x2, 0x2, 0x2, 0xc2b, 0xc1f, 0x3, 0x2, 
       0x2, 0x2, 0xc2b, 0xc2c, 0x3, 0x2, 0x2, 0x2, 0xc2c, 0xc2d, 0x3, 0x2, 
       0x2, 0x2, 0xc2d, 0xc2e, 0x7, 0x16c, 0x2, 0x2, 0xc2e, 0xc76, 0x3, 
       0x2, 0x2, 0x2, 0xc2f, 0xc30, 0x7, 0x150, 0x2, 0x2, 0xc30, 0xc31, 
       0x7, 0x169, 0x2, 0x2, 0xc31, 0xc3e, 0x5, 0x17e, 0xc0, 0x2, 0xc32, 
       0xc33, 0x7, 0x15b, 0x2, 0x2, 0xc33, 0xc3b, 0x5, 0x17e, 0xc0, 0x2, 
       0xc34, 0xc35, 0x7, 0x15b, 0x2, 0x2, 0xc35, 0xc36, 0x5, 0x17e, 0xc0, 
       0x2, 0xc36, 0xc37, 0x7, 0x15f, 0x2, 0x2, 0xc37, 0xc38, 0x5, 0x17e, 
       0xc0, 0x2, 0xc38, 0xc3a, 0x3, 0x2, 0x2, 0x2, 0xc39, 0xc34, 0x3, 0x2, 
       0x2, 0x2, 0xc3a, 0xc3d, 0x3, 0x2, 0x2, 0x2, 0xc3b, 0xc39, 0x3, 0x2, 
       0x2, 0x2, 0xc3b, 0xc3c, 0x3, 0x2, 0x2, 0x2, 0xc3c, 0xc3f, 0x3, 0x2, 
       0x2, 0x2, 0xc3d, 0xc3b, 0x3, 0x2, 0x2, 0x2, 0xc3e, 0xc32, 0x3, 0x2, 
       0x2, 0x2, 0xc3e, 0xc3f, 0x3, 0x2, 0x2, 0x2, 0xc3f, 0xc40, 0x3, 0x2, 
       0x2, 0x2, 0xc40, 0xc41, 0x7, 0x16c, 0x2, 0x2, 0xc41, 0xc76, 0x3, 
       0x2, 0x2, 0x2, 0xc42, 0xc43, 0x7, 0x151, 0x2, 0x2, 0xc43, 0xc44, 
       0x7, 0x169, 0x2, 0x2, 0xc44, 0xc4c, 0x5, 0x17e, 0xc0, 0x2, 0xc45, 
       0xc46, 0x7, 0x15b, 0x2, 0x2, 0xc46, 0xc47, 0x5, 0x17e, 0xc0, 0x2, 
       0xc47, 0xc48, 0x7, 0x15f, 0x2, 0x2, 0xc48, 0xc49, 0x5, 0x17e, 0xc0, 
       0x2, 0xc49, 0xc4b, 0x3, 0x2, 0x2, 0x2, 0xc4a, 0xc45, 0x3, 0x2, 0x2, 
       0x2, 0xc4b, 0xc4e, 0x3, 0x2, 0x2, 0x2, 0xc4c, 0xc4a, 0x3, 0x2, 0x2, 
       0x2, 0xc4c, 0xc4d, 0x3, 0x2, 0x2, 0x2, 0xc4d, 0xc4f, 0x3, 0x2, 0x2, 
       0x2, 0xc4e, 0xc4c, 0x3, 0x2, 0x2, 0x2, 0xc4f, 0xc50, 0x7, 0x16c, 
       0x2, 0x2, 0xc50, 0xc76, 0x3, 0x2, 0x2, 0x2, 0xc51, 0xc52, 0x7, 0x152, 
       0x2, 0x2, 0xc52, 0xc53, 0x7, 0x169, 0x2, 0x2, 0xc53, 0xc59, 0x5, 
       0x17e, 0xc0, 0x2, 0xc54, 0xc55, 0x7, 0x15b, 0x2, 0x2, 0xc55, 0xc56, 
       0x5, 0x17e, 0xc0, 0x2, 0xc56, 0xc57, 0x7, 0x15f, 0x2, 0x2, 0xc57, 
       0xc58, 0x5, 0x17e, 0xc0, 0x2, 0xc58, 0xc5a, 0x3, 0x2, 0x2, 0x2, 0xc59, 
       0xc54, 0x3, 0x2, 0x2, 0x2, 0xc5a, 0xc5b, 0x3, 0x2, 0x2, 0x2, 0xc5b, 
       0xc59, 0x3, 0x2, 0x2, 0x2, 0xc5b, 0xc5c, 0x3, 0x2, 0x2, 0x2, 0xc5c, 
       0xc5f, 0x3, 0x2, 0x2, 0x2, 0xc5d, 0xc5e, 0x7, 0x15b, 0x2, 0x2, 0xc5e, 
       0xc60, 0x5, 0x17e, 0xc0, 0x2, 0xc5f, 0xc5d, 0x3, 0x2, 0x2, 0x2, 0xc5f, 
       0xc60, 0x3, 0x2, 0x2, 0x2, 0xc60, 0xc61, 0x3, 0x2, 0x2, 0x2, 0xc61, 
       0xc62, 0x7, 0x16c, 0x2, 0x2, 0xc62, 0xc76, 0x3, 0x2, 0x2, 0x2, 0xc63, 
       0xc64, 0x7, 0xfa, 0x2, 0x2, 0xc64, 0xc65, 0x7, 0x169, 0x2, 0x2, 0xc65, 
       0xc66, 0x5, 0x17e, 0xc0, 0x2, 0xc66, 0xc67, 0x7, 0x16c, 0x2, 0x2, 
       0xc67, 0xc76, 0x3, 0x2, 0x2, 0x2, 0xc68, 0xc69, 0x7, 0x119, 0x2, 
       0x2, 0xc69, 0xc6a, 0x7, 0x169, 0x2, 0x2, 0xc6a, 0xc6b, 0x5, 0x17e, 
       0xc0, 0x2, 0xc6b, 0xc6c, 0x7, 0x79, 0x2, 0x2, 0xc6c, 0xc6f, 0x5, 
       0x17e, 0xc0, 0x2, 0xc6d, 0xc6e, 0x7, 0x75, 0x2, 0x2, 0xc6e, 0xc70, 
       0x5, 0x17e, 0xc0, 0x2, 0xc6f, 0xc6d, 0x3, 0x2, 0x2, 0x2, 0xc6f, 0xc70, 
       0x3, 0x2, 0x2, 0x2, 0xc70, 0xc71, 0x3, 0x2, 0x2, 0x2, 0xc71, 0xc72, 
       0x7, 0x16c, 0x2, 0x2, 0xc72, 0xc76, 0x3, 0x2, 0x2, 0x2, 0xc73, 0xc76, 
       0x7, 0x156, 0x2, 0x2, 0xc74, 0xc76, 0x7, 0x158, 0x2, 0x2, 0xc75, 
       0xbad, 0x3, 0x2, 0x2, 0x2, 0xc75, 0xbae, 0x3, 0x2, 0x2, 0x2, 0xc75, 
       0xbb8, 0x3, 0x2, 0x2, 0x2, 0xc75, 0xbbf, 0x3, 0x2, 0x2, 0x2, 0xc75, 
       0xbc0, 0x3, 0x2, 0x2, 0x2, 0xc75, 0xbc5, 0x3, 0x2, 0x2, 0x2, 0xc75, 
       0xbcd, 0x3, 0x2, 0x2, 0x2, 0xc75, 0xbce, 0x3, 0x2, 0x2, 0x2, 0xc75, 
       0xbd0, 0x3, 0x2, 0x2, 0x2, 0xc75, 0xbe3, 0x3, 0x2, 0x2, 0x2, 0xc75, 
       0xbf6, 0x3, 0x2, 0x2, 0x2, 0xc75, 0xc09, 0x3, 0x2, 0x2, 0x2, 0xc75, 
       0xc1c, 0x3, 0x2, 0x2, 0x2, 0xc75, 0xc2f, 0x3, 0x2, 0x2, 0x2, 0xc75, 
       0xc42, 0x3, 0x2, 0x2, 0x2, 0xc75, 0xc51, 0x3, 0x2, 0x2, 0x2, 0xc75, 
       0xc63, 0x3, 0x2, 0x2, 0x2, 0xc75, 0xc68, 0x3, 0x2, 0x2, 0x2, 0xc75, 
       0xc73, 0x3, 0x2, 0x2, 0x2, 0xc75, 0xc74, 0x3, 0x2, 0x2, 0x2, 0xc76, 
       0x19b, 0x3, 0x2, 0x2, 0x2, 0xc77, 0xc78, 0x5, 0x1b6, 0xdc, 0x2, 0xc78, 
       0xc7a, 0x7, 0x169, 0x2, 0x2, 0xc79, 0xc7b, 0x5, 0x19e, 0xd0, 0x2, 
       0xc7a, 0xc79, 0x3, 0x2, 0x2, 0x2, 0xc7a, 0xc7b, 0x3, 0x2, 0x2, 0x2, 
       0xc7b, 0xc7c, 0x3, 0x2, 0x2, 0x2, 0xc7c, 0xc7d, 0x7, 0x16c, 0x2, 
       0x2, 0xc7d, 0x19d, 0x3, 0x2, 0x2, 0x2, 0xc7e, 0xc83, 0x5, 0x1a0, 
       0xd1, 0x2, 0xc7f, 0xc80, 0x7, 0x15b, 0x2, 0x2, 0xc80, 0xc82, 0x5, 
       0x1a0, 0xd1, 0x2, 0xc81, 0xc7f, 0x3, 0x2, 0x2, 0x2, 0xc82, 0xc85, 
       0x3, 0x2, 0x2, 0x2, 0xc83, 0xc81, 0x3, 0x2, 0x2, 0x2, 0xc83, 0xc84, 
       0x3, 0x2, 0x2, 0x2, 0xc84, 0x19f, 0x3, 0x2, 0x2, 0x2, 0xc85, 0xc83, 
       0x3, 0x2, 0x2, 0x2, 0xc86, 0xc8c, 0x6, 0xd1, 0xe, 0x2, 0xc87, 0xc88, 
       0x5, 0x1b6, 0xdc, 0x2, 0xc88, 0xc8a, 0x7, 0x15f, 0x2, 0x2, 0xc89, 
       0xc8b, 0x7, 0x163, 0x2, 0x2, 0xc8a, 0xc89, 0x3, 0x2, 0x2, 0x2, 0xc8a, 
       0xc8b, 0x3, 0x2, 0x2, 0x2, 0xc8b, 0xc8d, 0x3, 0x2, 0x2, 0x2, 0xc8c, 
       0xc87, 0x3, 0x2, 0x2, 0x2, 0xc8c, 0xc8d, 0x3, 0x2, 0x2, 0x2, 0xc8d, 
       0xc8e, 0x3, 0x2, 0x2, 0x2, 0xc8e, 0xc8f, 0x5, 0x17e, 0xc0, 0x2, 0xc8f, 
       0x1a1, 0x3, 0x2, 0x2, 0x2, 0xc90, 0xc93, 0x5, 0x118, 0x8d, 0x2, 0xc91, 
       0xc93, 0x5, 0x17e, 0xc0, 0x2, 0xc92, 0xc90, 0x3, 0x2, 0x2, 0x2, 0xc92, 
       0xc91, 0x3, 0x2, 0x2, 0x2, 0xc93, 0x1a3, 0x3, 0x2, 0x2, 0x2, 0xc94, 
       0xc97, 0x5, 0x1b0, 0xd9, 0x2, 0xc95, 0xc97, 0x5, 0x17e, 0xc0, 0x2, 
       0xc96, 0xc94, 0x3, 0x2, 0x2, 0x2, 0xc96, 0xc95, 0x3, 0x2, 0x2, 0x2, 
       0xc97, 0x1a5, 0x3, 0x2, 0x2, 0x2, 0xc98, 0xc9c, 0x7, 0x85, 0x2, 0x2, 
       0xc99, 0xc9b, 0x5, 0x1a8, 0xd5, 0x2, 0xc9a, 0xc99, 0x3, 0x2, 0x2, 
       0x2, 0xc9b, 0xc9e, 0x3, 0x2, 0x2, 0x2, 0xc9c, 0xc9a, 0x3, 0x2, 0x2, 
       0x2, 0xc9c, 0xc9d, 0x3, 0x2, 0x2, 0x2, 0xc9d, 0x1a7, 0x3, 0x2, 0x2, 
       0x2, 0xc9e, 0xc9c, 0x3, 0x2, 0x2, 0x2, 0xc9f, 0xca0, 0x7, 0x16f, 
       0x2, 0x2, 0xca0, 0xca1, 0x5, 0x1b6, 0xdc, 0x2, 0xca1, 0xca2, 0x5, 
       0x17e, 0xc0, 0x2, 0xca2, 0xcac, 0x3, 0x2, 0x2, 0x2, 0xca3, 0xca4, 
       0x7, 0x16f, 0x2, 0x2, 0xca4, 0xca5, 0x5, 0x1b6, 0xdc, 0x2, 0xca5, 
       0xca6, 0x7, 0x170, 0x2, 0x2, 0xca6, 0xca7, 0x7, 0x15f, 0x2, 0x2, 
       0xca7, 0xca8, 0x5, 0x17e, 0xc0, 0x2, 0xca8, 0xcac, 0x3, 0x2, 0x2, 
       0x2, 0xca9, 0xcaa, 0x7, 0x16f, 0x2, 0x2, 0xcaa, 0xcac, 0x5, 0x1b6, 
       0xdc, 0x2, 0xcab, 0xc9f, 0x3, 0x2, 0x2, 0x2, 0xcab, 0xca3, 0x3, 0x2, 
       0x2, 0x2, 0xcab, 0xca9, 0x3, 0x2, 0x2, 0x2, 0xcac, 0x1a9, 0x3, 0x2, 
       0x2, 0x2, 0xcad, 0xcae, 0x7, 0x7, 0x2, 0x2, 0xcae, 0xcaf, 0x5, 0x1ac, 
       0xd7, 0x2, 0xcaf, 0xcb0, 0x7, 0x16e, 0x2, 0x2, 0xcb0, 0xcb3, 0x3, 
       0x2, 0x2, 0x2, 0xcb1, 0xcb3, 0x5, 0x1ae, 0xd8, 0x2, 0xcb2, 0xcad, 
       0x3, 0x2, 0x2, 0x2, 0xcb2, 0xcb1, 0x3, 0x2, 0x2, 0x2, 0xcb3, 0x1ab, 
       0x3, 0x2, 0x2, 0x2, 0xcb4, 0xcb6, 0xb, 0x2, 0x2, 0x2, 0xcb5, 0xcb4, 
       0x3, 0x2, 0x2, 0x2, 0xcb6, 0xcb9, 0x3, 0x2, 0x2, 0x2, 0xcb7, 0xcb8, 
       0x3, 0x2, 0x2, 0x2, 0xcb7, 0xcb5, 0x3, 0x2, 0x2, 0x2, 0xcb8, 0x1ad, 
       0x3, 0x2, 0x2, 0x2, 0xcb9, 0xcb7, 0x3, 0x2, 0x2, 0x2, 0xcba, 0xcbb, 
       0x7, 0x86, 0x2, 0x2, 0xcbb, 0xcbc, 0x5, 0x17e, 0xc0, 0x2, 0xcbc, 
       0x1af, 0x3, 0x2, 0x2, 0x2, 0xcbd, 0xccc, 0x7, 0x178, 0x2, 0x2, 0xcbe, 
       0xcc2, 0x7, 0x15d, 0x2, 0x2, 0xcbf, 0xcc0, 0x7, 0x6, 0x2, 0x2, 0xcc0, 
       0xcc2, 0x7, 0x15d, 0x2, 0x2, 0xcc1, 0xcbe, 0x3, 0x2, 0x2, 0x2, 0xcc1, 
       0xcbf, 0x3, 0x2, 0x2, 0x2, 0xcc1, 0xcc2, 0x3, 0x2, 0x2, 0x2, 0xcc2, 
       0xcc3, 0x3, 0x2, 0x2, 0x2, 0xcc3, 0xcc8, 0x5, 0x1b6, 0xdc, 0x2, 0xcc4, 
       0xcc5, 0x7, 0x15d, 0x2, 0x2, 0xcc5, 0xcc7, 0x5, 0x1b6, 0xdc, 0x2, 
       0xcc6, 0xcc4, 0x3, 0x2, 0x2, 0x2, 0xcc7, 0xcca, 0x3, 0x2, 0x2, 0x2, 
       0xcc8, 0xcc6, 0x3, 0x2, 0x2, 0x2, 0xcc8, 0xcc9, 0x3, 0x2, 0x2, 0x2, 
       0xcc9, 0xccc, 0x3, 0x2, 0x2, 0x2, 0xcca, 0xcc8, 0x3, 0x2, 0x2, 0x2, 
       0xccb, 0xcbd, 0x3, 0x2, 0x2, 0x2, 0xccb, 0xcc1, 0x3, 0x2, 0x2, 0x2, 
       0xccc, 0x1b1, 0x3, 0x2, 0x2, 0x2, 0xccd, 0xcce, 0x7, 0x46, 0x2, 0x2, 
       0xcce, 0xccf, 0x5, 0x1b8, 0xdd, 0x2, 0xccf, 0x1b3, 0x3, 0x2, 0x2, 
       0x2, 0xcd0, 0xcd1, 0x7, 0x122, 0x2, 0x2, 0xcd1, 0xcd2, 0x5, 0x1b8, 
       0xdd, 0x2, 0xcd2, 0x1b5, 0x3, 0x2, 0x2, 0x2, 0xcd3, 0xcd6, 0x7, 0x170, 
       0x2, 0x2, 0xcd4, 0xcd6, 0x5, 0x1c2, 0xe2, 0x2, 0xcd5, 0xcd3, 0x3, 
       0x2, 0x2, 0x2, 0xcd5, 0xcd4, 0x3, 0x2, 0x2, 0x2, 0xcd6, 0xcde, 0x3, 
       0x2, 0x2, 0x2, 0xcd7, 0xcda, 0x7, 0x6, 0x2, 0x2, 0xcd8, 0xcdb, 0x7, 
       0x170, 0x2, 0x2, 0xcd9, 0xcdb, 0x5, 0x1c2, 0xe2, 0x2, 0xcda, 0xcd8, 
       0x3, 0x2, 0x2, 0x2, 0xcda, 0xcd9, 0x3, 0x2, 0x2, 0x2, 0xcdb, 0xcdd, 
       0x3, 0x2, 0x2, 0x2, 0xcdc, 0xcd7, 0x3, 0x2, 0x2, 0x2, 0xcdd, 0xce0, 
       0x3, 0x2, 0x2, 0x2, 0xcde, 0xcdc, 0x3, 0x2, 0x2, 0x2, 0xcde, 0xcdf, 
       0x3, 0x2, 0x2, 0x2, 0xcdf, 0x1b7, 0x3, 0x2, 0x2, 0x2, 0xce0, 0xcde, 
       0x3, 0x2, 0x2, 0x2, 0xce1, 0xce4, 0x7, 0x171, 0x2, 0x2, 0xce2, 0xce4, 
       0x7, 0x172, 0x2, 0x2, 0xce3, 0xce1, 0x3, 0x2, 0x2, 0x2, 0xce3, 0xce2, 
       0x3, 0x2, 0x2, 0x2, 0xce4, 0x1b9, 0x3, 0x2, 0x2, 0x2, 0xce5, 0xce7, 
       0x9, 0x30, 0x2, 0x2, 0xce6, 0xce5, 0x3, 0x2, 0x2, 0x2, 0xce6, 0xce7, 
       0x3, 0x2, 0x2, 0x2, 0xce7, 0xce8, 0x3, 0x2, 0x2, 0x2, 0xce8, 0xce9, 
       0x7, 0x173, 0x2, 0x2, 0xce9, 0x1bb, 0x3, 0x2, 0x2, 0x2, 0xcea, 0xcec, 
       0x9, 0x30, 0x2, 0x2, 0xceb, 0xcea, 0x3, 0x2, 0x2, 0x2, 0xceb, 0xcec, 
       0x3, 0x2, 0x2, 0x2, 0xcec, 0xced, 0x3, 0x2, 0x2, 0x2, 0xced, 0xcee, 
       0x7, 0x174, 0x2, 0x2, 0xcee, 0x1bd, 0x3, 0x2, 0x2, 0x2, 0xcef, 0xcf0, 
       0x9, 0x31, 0x2, 0x2, 0xcf0, 0x1bf, 0x3, 0x2, 0x2, 0x2, 0xcf1, 0xcf2, 
       0x7, 0xc5, 0x2, 0x2, 0xcf2, 0x1c1, 0x3, 0x2, 0x2, 0x2, 0xcf3, 0xcf4, 
       0x9, 0x32, 0x2, 0x2, 0xcf4, 0x1c3, 0x3, 0x2, 0x2, 0x2, 0x1a5, 0x1c8, 
       0x1cb, 0x1cf, 0x1d2, 0x1d7, 0x1de, 0x1e4, 0x1e6, 0x1ef, 0x1f2, 0x1f4, 
       0x232, 0x23a, 0x24a, 0x251, 0x254, 0x259, 0x25d, 0x266, 0x26b, 0x273, 
       0x278, 0x281, 0x28d, 0x292, 0x295, 0x2a3, 0x2aa, 0x2b3, 0x2c4, 0x2c8, 
       0x2d0, 0x2db, 0x2e5, 0x2ed, 0x2f4, 0x2f8, 0x2fc, 0x301, 0x305, 0x30a, 
       0x30e, 0x312, 0x31c, 0x320, 0x325, 0x32a, 0x32e, 0x33b, 0x340, 0x346, 
       0x34f, 0x353, 0x35b, 0x35e, 0x363, 0x368, 0x36f, 0x376, 0x379, 0x380, 
       0x386, 0x38b, 0x391, 0x396, 0x399, 0x39f, 0x3ad, 0x3b7, 0x3bd, 0x3c2, 
       0x3c7, 0x3cc, 0x3d0, 0x3d5, 0x3d8, 0x3e2, 0x3ee, 0x3f5, 0x3f8, 0x404, 
       0x409, 0x40e, 0x411, 0x418, 0x424, 0x431, 0x433, 0x438, 0x43b, 0x44a, 
       0x450, 0x45b, 0x45e, 0x468, 0x46f, 0x475, 0x47d, 0x487, 0x49b, 0x4a1, 
       0x4a5, 0x4aa, 0x4ae, 0x4b3, 0x4b6, 0x4bb, 0x4be, 0x4ca, 0x4d1, 0x4d6, 
       0x4db, 0x4df, 0x4e4, 0x4e7, 0x4f1, 0x4fd, 0x504, 0x50c, 0x51a, 0x539, 
       0x53b, 0x540, 0x544, 0x549, 0x550, 0x553, 0x556, 0x55b, 0x55f, 0x561, 
       0x568, 0x56e, 0x575, 0x57b, 0x57e, 0x583, 0x587, 0x58a, 0x591, 0x597, 
       0x59a, 0x5a4, 0x5ad, 0x5b4, 0x5bb, 0x5bd, 0x5c3, 0x5c6, 0x5d1, 0x5da, 
       0x5e0, 0x5e6, 0x5e9, 0x5ee, 0x5f1, 0x5f4, 0x5f7, 0x5fa, 0x600, 0x60a, 
       0x615, 0x618, 0x61f, 0x624, 0x629, 0x62d, 0x635, 0x639, 0x63e, 0x642, 
       0x644, 0x649, 0x651, 0x656, 0x65c, 0x663, 0x666, 0x66d, 0x675, 0x67d, 
       0x680, 0x683, 0x688, 0x691, 0x695, 0x69f, 0x6b2, 0x6b9, 0x6bb, 0x6bf, 
       0x6c3, 0x6cb, 0x6d6, 0x6df, 0x6e7, 0x6ef, 0x6f3, 0x6fb, 0x70d, 0x71b, 
       0x722, 0x726, 0x72d, 0x72f, 0x733, 0x73c, 0x744, 0x74d, 0x75d, 0x763, 
       0x767, 0x771, 0x779, 0x782, 0x786, 0x78c, 0x791, 0x795, 0x79f, 0x7a5, 
       0x7a9, 0x7b5, 0x7bc, 0x7cc, 0x7d3, 0x7dd, 0x7e0, 0x7e4, 0x7eb, 0x7f2, 
       0x7f4, 0x7f8, 0x7fc, 0x801, 0x804, 0x808, 0x80b, 0x816, 0x819, 0x823, 
       0x82c, 0x833, 0x837, 0x83b, 0x842, 0x846, 0x84e, 0x854, 0x858, 0x863, 
       0x86a, 0x877, 0x87f, 0x883, 0x88d, 0x892, 0x89f, 0x8aa, 0x8b2, 0x8b6, 
       0x8ba, 0x8be, 0x8c0, 0x8c5, 0x8c8, 0x8cb, 0x8ce, 0x8d2, 0x8d5, 0x8d8, 
       0x8db, 0x8de, 0x8e5, 0x8f0, 0x8f4, 0x8f7, 0x8fb, 0x902, 0x906, 0x910, 
       0x918, 0x91e, 0x922, 0x928, 0x931, 0x934, 0x939, 0x93c, 0x946, 0x94b, 
       0x954, 0x959, 0x95d, 0x966, 0x96a, 0x978, 0x985, 0x98a, 0x98e, 0x994, 
       0x99f, 0x9a1, 0x9a8, 0x9ab, 0x9b2, 0x9b7, 0x9bd, 0x9c0, 0x9c3, 0x9d2, 
       0x9d9, 0x9dc, 0x9df, 0x9e3, 0x9e8, 0x9ee, 0x9f2, 0x9fd, 0xa01, 0xa04, 
       0xa08, 0xa0c, 0xa10, 0xa14, 0xa1a, 0xa20, 0xa27, 0xa2f, 0xa35, 0xa3a, 
       0xa45, 0xa4e, 0xa52, 0xa5b, 0xa5f, 0xa69, 0xa6e, 0xa84, 0xa87, 0xa9a, 
       0xaaa, 0xaac, 0xab7, 0xac6, 0xad2, 0xad6, 0xae1, 0xae5, 0xaf1, 0xaf5, 
       0xb00, 0xb05, 0xb0a, 0xb0e, 0xb12, 0xb17, 0xb1b, 0xb1f, 0xb36, 0xb38, 
       0xb4a, 0xb4c, 0xb54, 0xb59, 0xb5e, 0xb63, 0xb70, 0xb75, 0xb7a, 0xb7f, 
       0xb84, 0xb89, 0xb8e, 0xb93, 0xb95, 0xb9c, 0xb9f, 0xbaa, 0xbb4, 0xbbc, 
       0xbc5, 0xbcb, 0xbdc, 0xbdf, 0xbef, 0xbf2, 0xc02, 0xc05, 0xc15, 0xc18, 
       0xc28, 0xc2b, 0xc3b, 0xc3e, 0xc4c, 0xc5b, 0xc5f, 0xc6f, 0xc75, 0xc7a, 
       0xc83, 0xc8a, 0xc8c, 0xc92, 0xc96, 0xc9c, 0xcab, 0xcb2, 0xcb7, 0xcc1, 
       0xcc8, 0xccb, 0xcd5, 0xcda, 0xcde, 0xce3, 0xce6, 0xceb, 
  };

  _serializedATN.insert(_serializedATN.end(), serializedATNSegment0,
    serializedATNSegment0 + sizeof(serializedATNSegment0) / sizeof(serializedATNSegment0[0]));
  _serializedATN.insert(_serializedATN.end(), serializedATNSegment1,
    serializedATNSegment1 + sizeof(serializedATNSegment1) / sizeof(serializedATNSegment1[0]));


  atn::ATNDeserializer deserializer;
  _atn = deserializer.deserialize(_serializedATN);

  size_t count = _atn.getNumberOfDecisions();
  _decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    _decisionToDFA.emplace_back(_atn.getDecisionState(i), i);
  }
}

HplsqlParser::Initializer HplsqlParser::_init;
